/* -*- mode: C -*-  */
/* vim:set ts=4 sw=4 sts=4 noet: */
/*
   IGraph library.
   Copyright (C) 2007-2012  Gabor Csardi <csardi.gabor@gmail.com>
   334 Harvard street, Cambridge, MA 02139 USA

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
   02110-1301 USA

*/

#undef HAVE_GFORTRAN


#include "igraph_arpack.h"
#include "igraph_arpack_internal.h"
#include "igraph_memory.h"

#include <math.h>
#include <stdio.h>
#include <string.h>
#include <f2c.h>
#include <fio.h>
#include <cblas.h>

#define log10e 0.43429448190325182765

void exit_(integer *rc) {
#ifdef NO_ONEXIT
	f_exit();
#endif
	exit(*rc);
}

char *F77_aloc(integer Len, const char *whence) {
	integer memfailure = 3;

	char *rv;
	unsigned int uLen = (unsigned int) Len;	/* for K&R C */

	if (!(rv = (char*)malloc(uLen))) {
		fprintf(stderr, "malloc(%u) failure in %s\n",
			uLen, whence);
		exit_(&memfailure);
		}
	return rv;
}


integer e_wsfe(Void)
{
	int n = en_fio();
	f__fmtbuf = NULL;
#ifdef ALWAYS_FLUSH
	if (!n && fflush(f__cf))
		err(f__elist->cierr, errno, "write end");
#endif
	return n;
}




s_cat(char *lp, char *rpp[], ftnint rnp[], ftnint *np, ftnlen ll)
{
	ftnlen i, nc;
	char *rp;
	ftnlen n = *np;
#ifndef NO_OVERWRITE
	ftnlen L, m;
	char *lp0, *lp1;

	lp0 = 0;
	lp1 = lp;
	L = ll;
	i = 0;
	while(i < n) {
		rp = rpp[i];
		m = rnp[i++];
		if (rp >= lp1 || rp + m <= lp) {
			if ((L -= m) <= 0) {
				n = i;
				break;
				}
			lp1 += m;
			continue;
			}
		lp0 = lp;
		lp = lp1 = F77_aloc(L = ll, "s_cat");
		break;
		}
	lp1 = lp;
#endif /* NO_OVERWRITE */
	for(i = 0 ; i < n ; ++i) {
		nc = ll;
		if(rnp[i] < nc)
			nc = rnp[i];
		ll -= nc;
		rp = rpp[i];
		while(--nc >= 0)
			*lp++ = *rp++;
		}
	while(--ll >= 0)
		*lp++ = ' ';
#ifndef NO_OVERWRITE
	if (lp0) {
		memcpy(lp0, lp1, L);
		free(lp1);
		}
#endif
}

integer s_cmp(char *a0, char *b0, ftnlen la, ftnlen lb)
{
	register unsigned char *a, *aend, *b, *bend;
	a = (unsigned char *)a0;
	b = (unsigned char *)b0;
	aend = a + la;
	bend = b + lb;

	if(la <= lb)
		{
		while(a < aend)
			if(*a != *b)
				return( *a - *b );
			else
				{ ++a; ++b; }

		while(b < bend)
			if(*b != ' ')
				return( ' ' - *b );
			else	++b;
		}

	else
		{
		while(b < bend)
			if(*a == *b)
				{ ++a; ++b; }
			else
				return( *a - *b );
		while(a < aend)
			if(*a != ' ')
				return(*a - ' ');
			else	++a;
		}
	return(0);
}


double d_lg10(doublereal *x) {
	return( log10e * log(*x) );	
}

double d_sign(doublereal *a, doublereal *b) {
	double x;
	x = (*a >= 0 ? *a : - *a);
	return( *b >= 0 ? x : -x);
}

integer i_dnnt(doublereal *x) {
	return (integer)(*x >= 0. ? floor(*x + .5) : -floor(.5 - *x));
}

double pow_dd(doublereal *ap, doublereal *bp) {
	return(pow(*ap, *bp) );
}

integer i_len(char *s, ftnlen n) {
	return(n);
}


/* > \brief \b DORM2R multiplies a general matrix by the orthogonal matrix from a QR factorization determined 
by sgeqrf (unblocked algorithm).   

    =========== DOCUMENTATION ===========   

   Online html documentation available at   
              http://www.netlib.org/lapack/explore-html/   

   > \htmlonly   
   > Download DORM2R + dependencies   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dorm2r.
f">   
   > [TGZ]</a>   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dorm2r.
f">   
   > [ZIP]</a>   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorm2r.
f">   
   > [TXT]</a>   
   > \endhtmlonly   

    Definition:   
    ===========   

         SUBROUTINE DORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
                            WORK, INFO )   

         CHARACTER          SIDE, TRANS   
         INTEGER            INFO, K, LDA, LDC, M, N   
         DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )   


   > \par Purpose:   
    =============   
   >   
   > \verbatim   
   >   
   > DORM2R overwrites the general real m by n matrix C with   
   >   
   >       Q * C  if SIDE = 'L' and TRANS = 'N', or   
   >   
   >       Q**T* C  if SIDE = 'L' and TRANS = 'T', or   
   >   
   >       C * Q  if SIDE = 'R' and TRANS = 'N', or   
   >   
   >       C * Q**T if SIDE = 'R' and TRANS = 'T',   
   >   
   > where Q is a real orthogonal matrix defined as the product of k   
   > elementary reflectors   
   >   
   >       Q = H(1) H(2) . . . H(k)   
   >   
   > as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n   
   > if SIDE = 'R'.   
   > \endverbatim   

    Arguments:   
    ==========   

   > \param[in] SIDE   
   > \verbatim   
   >          SIDE is CHARACTER*1   
   >          = 'L': apply Q or Q**T from the Left   
   >          = 'R': apply Q or Q**T from the Right   
   > \endverbatim   
   >   
   > \param[in] TRANS   
   > \verbatim   
   >          TRANS is CHARACTER*1   
   >          = 'N': apply Q  (No transpose)   
   >          = 'T': apply Q**T (Transpose)   
   > \endverbatim   
   >   
   > \param[in] M   
   > \verbatim   
   >          M is INTEGER   
   >          The number of rows of the matrix C. M >= 0.   
   > \endverbatim   
   >   
   > \param[in] N   
   > \verbatim   
   >          N is INTEGER   
   >          The number of columns of the matrix C. N >= 0.   
   > \endverbatim   
   >   
   > \param[in] K   
   > \verbatim   
   >          K is INTEGER   
   >          The number of elementary reflectors whose product defines   
   >          the matrix Q.   
   >          If SIDE = 'L', M >= K >= 0;   
   >          if SIDE = 'R', N >= K >= 0.   
   > \endverbatim   
   >   
   > \param[in] A   
   > \verbatim   
   >          A is DOUBLE PRECISION array, dimension (LDA,K)   
   >          The i-th column must contain the vector which defines the   
   >          elementary reflector H(i), for i = 1,2,...,k, as returned by   
   >          DGEQRF in the first k columns of its array argument A.   
   >          A is modified by the routine but restored on exit.   
   > \endverbatim   
   >   
   > \param[in] LDA   
   > \verbatim   
   >          LDA is INTEGER   
   >          The leading dimension of the array A.   
   >          If SIDE = 'L', LDA >= max(1,M);   
   >          if SIDE = 'R', LDA >= max(1,N).   
   > \endverbatim   
   >   
   > \param[in] TAU   
   > \verbatim   
   >          TAU is DOUBLE PRECISION array, dimension (K)   
   >          TAU(i) must contain the scalar factor of the elementary   
   >          reflector H(i), as returned by DGEQRF.   
   > \endverbatim   
   >   
   > \param[in,out] C   
   > \verbatim   
   >          C is DOUBLE PRECISION array, dimension (LDC,N)   
   >          On entry, the m by n matrix C.   
   >          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.   
   > \endverbatim   
   >   
   > \param[in] LDC   
   > \verbatim   
   >          LDC is INTEGER   
   >          The leading dimension of the array C. LDC >= max(1,M).   
   > \endverbatim   
   >   
   > \param[out] WORK   
   > \verbatim   
   >          WORK is DOUBLE PRECISION array, dimension   
   >                                   (N) if SIDE = 'L',   
   >                                   (M) if SIDE = 'R'   
   > \endverbatim   
   >   
   > \param[out] INFO   
   > \verbatim   
   >          INFO is INTEGER   
   >          = 0: successful exit   
   >          < 0: if INFO = -i, the i-th argument had an illegal value   
   > \endverbatim   

    Authors:   
    ========   

   > \author Univ. of Tennessee   
   > \author Univ. of California Berkeley   
   > \author Univ. of Colorado Denver   
   > \author NAG Ltd.   

   > \date September 2012   

   > \ingroup doubleOTHERcomputational   

    =====================================================================   
   Subroutine */ int igraphdorm2r_(char *side, char *trans, integer *m, integer *n, 
	integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *
	c__, integer *ldc, doublereal *work, integer *info)
{
	integer c__1 = 1;

    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    integer i__, i1, i2, i3, ic, jc, mi, ni, nq;
    doublereal aii;
    logical left;
    extern /* Subroutine */ int igraphdlarf_(char *, integer *, integer *, 
	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
	    doublereal *);
    extern logical igraphlsame_(char *, char *);
    extern /* Subroutine */ int igraphxerbla_(char *, integer *, ftnlen);
    logical notran;


/*  -- LAPACK computational routine (version 3.4.2) --   
    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
       September 2012   


    =====================================================================   


       Test the input arguments   

       Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = igraphlsame_(side, "L");
    notran = igraphlsame_(trans, "N");

/*     NQ is the order of Q */

    if (left) {
	nq = *m;
    } else {
	nq = *n;
    }
    if (! left && ! igraphlsame_(side, "R")) {
	*info = -1;
    } else if (! notran && ! igraphlsame_(trans, "T")) {
	*info = -2;
    } else if (*m < 0) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*k < 0 || *k > nq) {
	*info = -5;
    } else if (*lda < max(1,nq)) {
	*info = -7;
    } else if (*ldc < max(1,*m)) {
	*info = -10;
    }
    if (*info != 0) {
	i__1 = -(*info);
	igraphxerbla_("DORM2R", &i__1, (ftnlen)6);
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {
	return 0;
    }

    if (left && ! notran || ! left && notran) {
	i1 = 1;
	i2 = *k;
	i3 = 1;
    } else {
	i1 = *k;
	i2 = 1;
	i3 = -1;
    }

    if (left) {
	ni = *n;
	jc = 1;
    } else {
	mi = *m;
	ic = 1;
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	if (left) {

/*           H(i) is applied to C(i:m,1:n) */

	    mi = *m - i__ + 1;
	    ic = i__;
	} else {

/*           H(i) is applied to C(1:m,i:n) */

	    ni = *n - i__ + 1;
	    jc = i__;
	}

/*        Apply H(i) */

	aii = a[i__ + i__ * a_dim1];
	a[i__ + i__ * a_dim1] = 1.;
	igraphdlarf_(side, &mi, &ni, &a[i__ + i__ * a_dim1], &c__1, &tau[i__], &c__[
		ic + jc * c_dim1], ldc, &work[1]);
	a[i__ + i__ * a_dim1] = aii;
/* L10: */
    }
    return 0;

/*     End of DORM2R */

} /* igraphdorm2r_ */




/* > \brief \b DORM2L multiplies a general matrix by the orthogonal matrix from a QL factorization determined 
by sgeqlf (unblocked algorithm).   

    =========== DOCUMENTATION ===========   

   Online html documentation available at   
              http://www.netlib.org/lapack/explore-html/   

   > \htmlonly   
   > Download DORM2L + dependencies   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dorm2l.
f">   
   > [TGZ]</a>   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dorm2l.
f">   
   > [ZIP]</a>   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dorm2l.
f">   
   > [TXT]</a>   
   > \endhtmlonly   

    Definition:   
    ===========   

         SUBROUTINE DORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,   
                            WORK, INFO )   

         CHARACTER          SIDE, TRANS   
         INTEGER            INFO, K, LDA, LDC, M, N   
         DOUBLE PRECISION   A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )   


   > \par Purpose:   
    =============   
   >   
   > \verbatim   
   >   
   > DORM2L overwrites the general real m by n matrix C with   
   >   
   >       Q * C  if SIDE = 'L' and TRANS = 'N', or   
   >   
   >       Q**T * C  if SIDE = 'L' and TRANS = 'T', or   
   >   
   >       C * Q  if SIDE = 'R' and TRANS = 'N', or   
   >   
   >       C * Q**T if SIDE = 'R' and TRANS = 'T',   
   >   
   > where Q is a real orthogonal matrix defined as the product of k   
   > elementary reflectors   
   >   
   >       Q = H(k) . . . H(2) H(1)   
   >   
   > as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n   
   > if SIDE = 'R'.   
   > \endverbatim   

    Arguments:   
    ==========   

   > \param[in] SIDE   
   > \verbatim   
   >          SIDE is CHARACTER*1   
   >          = 'L': apply Q or Q**T from the Left   
   >          = 'R': apply Q or Q**T from the Right   
   > \endverbatim   
   >   
   > \param[in] TRANS   
   > \verbatim   
   >          TRANS is CHARACTER*1   
   >          = 'N': apply Q  (No transpose)   
   >          = 'T': apply Q**T (Transpose)   
   > \endverbatim   
   >   
   > \param[in] M   
   > \verbatim   
   >          M is INTEGER   
   >          The number of rows of the matrix C. M >= 0.   
   > \endverbatim   
   >   
   > \param[in] N   
   > \verbatim   
   >          N is INTEGER   
   >          The number of columns of the matrix C. N >= 0.   
   > \endverbatim   
   >   
   > \param[in] K   
   > \verbatim   
   >          K is INTEGER   
   >          The number of elementary reflectors whose product defines   
   >          the matrix Q.   
   >          If SIDE = 'L', M >= K >= 0;   
   >          if SIDE = 'R', N >= K >= 0.   
   > \endverbatim   
   >   
   > \param[in] A   
   > \verbatim   
   >          A is DOUBLE PRECISION array, dimension (LDA,K)   
   >          The i-th column must contain the vector which defines the   
   >          elementary reflector H(i), for i = 1,2,...,k, as returned by   
   >          DGEQLF in the last k columns of its array argument A.   
   >          A is modified by the routine but restored on exit.   
   > \endverbatim   
   >   
   > \param[in] LDA   
   > \verbatim   
   >          LDA is INTEGER   
   >          The leading dimension of the array A.   
   >          If SIDE = 'L', LDA >= max(1,M);   
   >          if SIDE = 'R', LDA >= max(1,N).   
   > \endverbatim   
   >   
   > \param[in] TAU   
   > \verbatim   
   >          TAU is DOUBLE PRECISION array, dimension (K)   
   >          TAU(i) must contain the scalar factor of the elementary   
   >          reflector H(i), as returned by DGEQLF.   
   > \endverbatim   
   >   
   > \param[in,out] C   
   > \verbatim   
   >          C is DOUBLE PRECISION array, dimension (LDC,N)   
   >          On entry, the m by n matrix C.   
   >          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.   
   > \endverbatim   
   >   
   > \param[in] LDC   
   > \verbatim   
   >          LDC is INTEGER   
   >          The leading dimension of the array C. LDC >= max(1,M).   
   > \endverbatim   
   >   
   > \param[out] WORK   
   > \verbatim   
   >          WORK is DOUBLE PRECISION array, dimension   
   >                                   (N) if SIDE = 'L',   
   >                                   (M) if SIDE = 'R'   
   > \endverbatim   
   >   
   > \param[out] INFO   
   > \verbatim   
   >          INFO is INTEGER   
   >          = 0: successful exit   
   >          < 0: if INFO = -i, the i-th argument had an illegal value   
   > \endverbatim   

    Authors:   
    ========   

   > \author Univ. of Tennessee   
   > \author Univ. of California Berkeley   
   > \author Univ. of Colorado Denver   
   > \author NAG Ltd.   

   > \date September 2012   

   > \ingroup doubleOTHERcomputational   

    =====================================================================   
   Subroutine */ int igraphdorm2l_(char *side, char *trans, integer *m, integer *n, 
	integer *k, doublereal *a, integer *lda, doublereal *tau, doublereal *
	c__, integer *ldc, doublereal *work, integer *info)
{
    /* System generated locals */
    integer a_dim1, a_offset, c_dim1, c_offset, i__1, i__2;

	integer c__1 = 1;

    /* Local variables */
    integer i__, i1, i2, i3, mi, ni, nq;
    doublereal aii;
    logical left;
    extern /* Subroutine */ int igraphdlarf_(char *, integer *, integer *, 
	    doublereal *, integer *, doublereal *, doublereal *, integer *, 
	    doublereal *);
    extern logical igraphlsame_(char *, char *);
    extern /* Subroutine */ int igraphxerbla_(char *, integer *, ftnlen);
    logical notran;


/*  -- LAPACK computational routine (version 3.4.2) --   
    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
       September 2012   


    =====================================================================   


       Test the input arguments   

       Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --tau;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --work;

    /* Function Body */
    *info = 0;
    left = igraphlsame_(side, "L");
    notran = igraphlsame_(trans, "N");

/*     NQ is the order of Q */

    if (left) {
	nq = *m;
    } else {
	nq = *n;
    }
    if (! left && ! igraphlsame_(side, "R")) {
	*info = -1;
    } else if (! notran && ! igraphlsame_(trans, "T")) {
	*info = -2;
    } else if (*m < 0) {
	*info = -3;
    } else if (*n < 0) {
	*info = -4;
    } else if (*k < 0 || *k > nq) {
	*info = -5;
    } else if (*lda < max(1,nq)) {
	*info = -7;
    } else if (*ldc < max(1,*m)) {
	*info = -10;
    }
    if (*info != 0) {
	i__1 = -(*info);
	igraphxerbla_("DORM2L", &i__1, (ftnlen)6);
	return 0;
    }

/*     Quick return if possible */

    if (*m == 0 || *n == 0 || *k == 0) {
	return 0;
    }

    if (left && notran || ! left && ! notran) {
	i1 = 1;
	i2 = *k;
	i3 = 1;
    } else {
	i1 = *k;
	i2 = 1;
	i3 = -1;
    }

    if (left) {
	ni = *n;
    } else {
	mi = *m;
    }

    i__1 = i2;
    i__2 = i3;
    for (i__ = i1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	if (left) {

/*           H(i) is applied to C(1:m-k+i,1:n) */

	    mi = *m - *k + i__;
	} else {

/*           H(i) is applied to C(1:m,1:n-k+i) */

	    ni = *n - *k + i__;
	}

/*        Apply H(i) */

	aii = a[nq - *k + i__ + i__ * a_dim1];
	a[nq - *k + i__ + i__ * a_dim1] = 1.;
	igraphdlarf_(side, &mi, &ni, &a[i__ * a_dim1 + 1], &c__1, &tau[i__], &c__[
		c_offset], ldc, &work[1]);
	a[nq - *k + i__ + i__ * a_dim1] = aii;
/* L10: */
    }
    return 0;

/*     End of DORM2L */

} /* igraphdorm2l_ */


int igraphdlarfg_(integer *n, doublereal *alpha, doublereal *x, 
	integer *incx, doublereal *tau)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *);

    /* Local variables */
    integer j, knt;
    doublereal beta;
    extern doublereal igraphdnrm2_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int igraphdscal_(integer *, doublereal *, doublereal *, 
	    integer *);
    doublereal xnorm;
    extern doublereal igraphdlapy2_(doublereal *, doublereal *), igraphdlamch_(char *);
    doublereal safmin, rsafmn;


/*  -- LAPACK auxiliary routine (version 3.4.2) --   
    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
       September 2012   


    =====================================================================   


       Parameter adjustments */
    --x;

    /* Function Body */
    if (*n <= 1) {
	*tau = 0.;
	return 0;
    }

    i__1 = *n - 1;
    xnorm = igraphdnrm2_(&i__1, &x[1], incx);

    if (xnorm == 0.) {

/*        H  =  I */

	*tau = 0.;
    } else {

/*        general case */

	d__1 = igraphdlapy2_(alpha, &xnorm);
	beta = -d_sign(&d__1, alpha);
	safmin = igraphdlamch_("S") / igraphdlamch_("E");
	knt = 0;
	if (abs(beta) < safmin) {

/*           XNORM, BETA may be inaccurate; scale X and recompute them */

	    rsafmn = 1. / safmin;
L10:
	    ++knt;
	    i__1 = *n - 1;
	    igraphdscal_(&i__1, &rsafmn, &x[1], incx);
	    beta *= rsafmn;
	    *alpha *= rsafmn;
	    if (abs(beta) < safmin) {
		goto L10;
	    }

/*           New BETA is at most 1, at least SAFMIN */

	    i__1 = *n - 1;
	    xnorm = igraphdnrm2_(&i__1, &x[1], incx);
	    d__1 = igraphdlapy2_(alpha, &xnorm);
	    beta = -d_sign(&d__1, alpha);
	}
	*tau = (beta - *alpha) / beta;
	i__1 = *n - 1;
	d__1 = 1. / (*alpha - beta);
	igraphdscal_(&i__1, &d__1, &x[1], incx);

/*        If ALPHA is subnormal, it may lose relative accuracy */

	i__1 = knt;
	for (j = 1; j <= i__1; ++j) {
	    beta *= safmin;
/* L20: */
	}
	*alpha = beta;
    }

    return 0;

/*     End of DLARFG */

} /* igraphdlarfg_ */




/* Table of constant values */

static integer dasum__c__1 = 1;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dsaupd   

   \Description:   

    Reverse communication interface for the Implicitly Restarted Arnoldi   
    Iteration.  For symmetric problems this reduces to a variant of the Lanczos   
    method.  This method has been designed to compute approximations to a   
    few eigenpairs of a linear operator OP that is real and symmetric   
    with respect to a real positive semi-definite symmetric matrix B,   
    i.e.   

         B*OP = (OP')*B.   

    Another way to express this condition is   

         < x,OPy > = < OPx,y >  where < z,w > = z'Bw  .   

    In the standard eigenproblem B is the identity matrix.   
    ( A' denotes transpose of A)   

    The computed approximate eigenvalues are called Ritz values and   
    the corresponding approximate eigenvectors are called Ritz vectors.   

    dsaupd is usually called iteratively to solve one of the   
    following problems:   

    Mode 1:  A*x = lambda*x, A symmetric   
             ===> OP = A  and  B = I.   

    Mode 2:  A*x = lambda*M*x, A symmetric, M symmetric positive definite   
             ===> OP = inv[M]*A  and  B = M.   
             ===> (If M can be factored see remark 3 below)   

    Mode 3:  K*x = lambda*M*x, K symmetric, M symmetric positive semi-definite   
             ===> OP = (inv[K - sigma*M])*M  and  B = M.   
             ===> Shift-and-Invert mode   

    Mode 4:  K*x = lambda*KG*x, K symmetric positive semi-definite,   
             KG symmetric indefinite   
             ===> OP = (inv[K - sigma*KG])*K  and  B = K.   
             ===> Buckling mode   

    Mode 5:  A*x = lambda*M*x, A symmetric, M symmetric positive semi-definite   
             ===> OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.   
             ===> Cayley transformed mode   

    NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v   
          should be accomplished either by a direct method   
          using a sparse matrix factorization and solving   

             [A - sigma*M]*w = v  or M*w = v,   

          or through an iterative method for solving these   
          systems.  If an iterative method is used, the   
          convergence test must be more stringent than   
          the accuracy requirements for the eigenvalue   
          approximations.   

   \Usage:   
    call dsaupd   
       ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,   
         IPNTR, WORKD, WORKL, LWORKL, INFO )   

   \Arguments   
    IDO     Integer.  (INPUT/OUTPUT)   
            Reverse communication flag.  IDO must be zero on the first   
            call to dsaupd.  IDO will be set internally to   
            indicate the type of operation to be performed.  Control is   
            then given back to the calling routine which has the   
            responsibility to carry out the requested operation and call   
            dsaupd with the result.  The operand is given in   
            WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).   
            (If Mode = 2 see remark 5 below)   
            -------------------------------------------------------------   
            IDO =  0: first call to the reverse communication interface   
            IDO = -1: compute  Y = OP * X  where   
                      IPNTR(1) is the pointer into WORKD for X,   
                      IPNTR(2) is the pointer into WORKD for Y.   
                      This is for the initialization phase to force the   
                      starting vector into the range of OP.   
            IDO =  1: compute  Y = OP * X where   
                      IPNTR(1) is the pointer into WORKD for X,   
                      IPNTR(2) is the pointer into WORKD for Y.   
                      In mode 3,4 and 5, the vector B * X is already   
                      available in WORKD(ipntr(3)).  It does not   
                      need to be recomputed in forming OP * X.   
            IDO =  2: compute  Y = B * X  where   
                      IPNTR(1) is the pointer into WORKD for X,   
                      IPNTR(2) is the pointer into WORKD for Y.   
            IDO =  3: compute the IPARAM(8) shifts where   
                      IPNTR(11) is the pointer into WORKL for   
                      placing the shifts. See remark 6 below.   
            IDO = 99: done   
            -------------------------------------------------------------   

    BMAT    Character*1.  (INPUT)   
            BMAT specifies the type of the matrix B that defines the   
            semi-inner product for the operator OP.   
            B = 'I' -> standard eigenvalue problem A*x = lambda*x   
            B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x   

    N       Integer.  (INPUT)   
            Dimension of the eigenproblem.   

    WHICH   Character*2.  (INPUT)   
            Specify which of the Ritz values of OP to compute.   

            'LA' - compute the NEV largest (algebraic) eigenvalues.   
            'SA' - compute the NEV smallest (algebraic) eigenvalues.   
            'LM' - compute the NEV largest (in magnitude) eigenvalues.   
            'SM' - compute the NEV smallest (in magnitude) eigenvalues.   
            'BE' - compute NEV eigenvalues, half from each end of the   
                   spectrum.  When NEV is odd, compute one more from the   
                   high end than from the low end.   
             (see remark 1 below)   

    NEV     Integer.  (INPUT)   
            Number of eigenvalues of OP to be computed. 0 < NEV < N.   

    TOL     Double precision scalar.  (INPUT)   
            Stopping criterion: the relative accuracy of the Ritz value   
            is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I)).   
            If TOL .LE. 0. is passed a default is set:   
            DEFAULT = DLAMCH('EPS')  (machine precision as computed   
                      by the LAPACK auxiliary subroutine DLAMCH).   

    RESID   Double precision array of length N.  (INPUT/OUTPUT)   
            On INPUT:   
            If INFO .EQ. 0, a random initial residual vector is used.   
            If INFO .NE. 0, RESID contains the initial residual vector,   
                            possibly from a previous run.   
            On OUTPUT:   
            RESID contains the final residual vector.   

    NCV     Integer.  (INPUT)   
            Number of columns of the matrix V (less than or equal to N).   
            This will indicate how many Lanczos vectors are generated   
            at each iteration.  After the startup phase in which NEV   
            Lanczos vectors are generated, the algorithm generates   
            NCV-NEV Lanczos vectors at each subsequent update iteration.   
            Most of the cost in generating each Lanczos vector is in the   
            matrix-vector product OP*x. (See remark 4 below).   

    V       Double precision N by NCV array.  (OUTPUT)   
            The NCV columns of V contain the Lanczos basis vectors.   

    LDV     Integer.  (INPUT)   
            Leading dimension of V exactly as declared in the calling   
            program.   

    IPARAM  Integer array of length 11.  (INPUT/OUTPUT)   
            IPARAM(1) = ISHIFT: method for selecting the implicit shifts.   
            The shifts selected at each iteration are used to restart   
            the Arnoldi iteration in an implicit fashion.   
            -------------------------------------------------------------   
            ISHIFT = 0: the shifts are provided by the user via   
                        reverse communication.  The NCV eigenvalues of   
                        the current tridiagonal matrix T are returned in   
                        the part of WORKL array corresponding to RITZ.   
                        See remark 6 below.   
            ISHIFT = 1: exact shifts with respect to the reduced   
                        tridiagonal matrix T.  This is equivalent to   
                        restarting the iteration with a starting vector   
                        that is a linear combination of Ritz vectors   
                        associated with the "wanted" Ritz values.   
            -------------------------------------------------------------   

            IPARAM(2) = LEVEC   
            No longer referenced. See remark 2 below.   

            IPARAM(3) = MXITER   
            On INPUT:  maximum number of Arnoldi update iterations allowed.   
            On OUTPUT: actual number of Arnoldi update iterations taken.   

            IPARAM(4) = NB: blocksize to be used in the recurrence.   
            The code currently works only for NB = 1.   

            IPARAM(5) = NCONV: number of "converged" Ritz values.   
            This represents the number of Ritz values that satisfy   
            the convergence criterion.   

            IPARAM(6) = IUPD   
            No longer referenced. Implicit restarting is ALWAYS used.   

            IPARAM(7) = MODE   
            On INPUT determines what type of eigenproblem is being solved.   
            Must be 1,2,3,4,5; See under \Description of dsaupd for the   
            five modes available.   

            IPARAM(8) = NP   
            When ido = 3 and the user provides shifts through reverse   
            communication (IPARAM(1)=0), dsaupd returns NP, the number   
            of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark   
            6 below.   

            IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,   
            OUTPUT: NUMOP  = total number of OP*x operations,   
                    NUMOPB = total number of B*x operations if BMAT='G',   
                    NUMREO = total number of steps of re-orthogonalization.   

    IPNTR   Integer array of length 11.  (OUTPUT)   
            Pointer to mark the starting locations in the WORKD and WORKL   
            arrays for matrices/vectors used by the Lanczos iteration.   
            -------------------------------------------------------------   
            IPNTR(1): pointer to the current operand vector X in WORKD.   
            IPNTR(2): pointer to the current result vector Y in WORKD.   
            IPNTR(3): pointer to the vector B * X in WORKD when used in   
                      the shift-and-invert mode.   
            IPNTR(4): pointer to the next available location in WORKL   
                      that is untouched by the program.   
            IPNTR(5): pointer to the NCV by 2 tridiagonal matrix T in WORKL.   
            IPNTR(6): pointer to the NCV RITZ values array in WORKL.   
            IPNTR(7): pointer to the Ritz estimates in array WORKL associated   
                      with the Ritz values located in RITZ in WORKL.   
            IPNTR(11): pointer to the NP shifts in WORKL. See Remark 6 below.   

            Note: IPNTR(8:10) is only referenced by dseupd. See Remark 2.   
            IPNTR(8): pointer to the NCV RITZ values of the original system.   
            IPNTR(9): pointer to the NCV corresponding error bounds.   
            IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors   
                       of the tridiagonal matrix T. Only referenced by   
                       dseupd if RVEC = .TRUE. See Remarks.   
            -------------------------------------------------------------   

    WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)   
            Distributed array to be used in the basic Arnoldi iteration   
            for reverse communication.  The user should not use WORKD   
            as temporary workspace during the iteration. Upon termination   
            WORKD(1:N) contains B*RESID(1:N). If the Ritz vectors are desired   
            subroutine dseupd uses this output.   
            See Data Distribution Note below.   

    WORKL   Double precision work array of length LWORKL.  (OUTPUT/WORKSPACE)   
            Private (replicated) array on each PE or array allocated on   
            the front end.  See Data Distribution Note below.   

    LWORKL  Integer.  (INPUT)   
            LWORKL must be at least NCV**2 + 8*NCV .   

    INFO    Integer.  (INPUT/OUTPUT)   
            If INFO .EQ. 0, a randomly initial residual vector is used.   
            If INFO .NE. 0, RESID contains the initial residual vector,   
                            possibly from a previous run.   
            Error flag on output.   
            =  0: Normal exit.   
            =  1: Maximum number of iterations taken.   
                  All possible eigenvalues of OP has been found. IPARAM(5)   
                  returns the number of wanted converged Ritz values.   
            =  2: No longer an informational error. Deprecated starting   
                  with release 2 of ARPACK.   
            =  3: No shifts could be applied during a cycle of the   
                  Implicitly restarted Arnoldi iteration. One possibility   
                  is to increase the size of NCV relative to NEV.   
                  See remark 4 below.   
            = -1: N must be positive.   
            = -2: NEV must be positive.   
            = -3: NCV must be greater than NEV and less than or equal to N.   
            = -4: The maximum number of Arnoldi update iterations allowed   
                  must be greater than zero.   
            = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.   
            = -6: BMAT must be one of 'I' or 'G'.   
            = -7: Length of private work array WORKL is not sufficient.   
            = -8: Error return from trid. eigenvalue calculation;   
                  Informatinal error from LAPACK routine dsteqr.   
            = -9: Starting vector is zero.   
            = -10: IPARAM(7) must be 1,2,3,4,5.   
            = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.   
            = -12: IPARAM(1) must be equal to 0 or 1.   
            = -13: NEV and WHICH = 'BE' are incompatable.   
            = -9999: Could not build an Arnoldi factorization.   
                     IPARAM(5) returns the size of the current Arnoldi   
                     factorization. The user is advised to check that   
                     enough workspace and array storage has been allocated.   


   \Remarks   
    1. The converged Ritz values are always returned in ascending   
       algebraic order.  The computed Ritz values are approximate   
       eigenvalues of OP.  The selection of WHICH should be made   
       with this in mind when Mode = 3,4,5.  After convergence,   
       approximate eigenvalues of the original problem may be obtained   
       with the ARPACK subroutine dseupd.   

    2. If the Ritz vectors corresponding to the converged Ritz values   
       are needed, the user must call dseupd immediately following completion   
       of dsaupd. This is new starting with version 2.1 of ARPACK.   

    3. If M can be factored into a Cholesky factorization M = LL'   
       then Mode = 2 should not be selected.  Instead one should use   
       Mode = 1 with  OP = inv(L)*A*inv(L').  Appropriate triangular   
       linear systems should be solved with L and L' rather   
       than computing inverses.  After convergence, an approximate   
       eigenvector z of the original problem is recovered by solving   
       L'z = x  where x is a Ritz vector of OP.   

    4. At present there is no a-priori analysis to guide the selection   
       of NCV relative to NEV.  The only formal requrement is that NCV > NEV.   
       However, it is recommended that NCV .ge. 2*NEV.  If many problems of   
       the same type are to be solved, one should experiment with increasing   
       NCV while keeping NEV fixed for a given test problem.  This will   
       usually decrease the required number of OP*x operations but it   
       also increases the work and storage required to maintain the orthogonal   
       basis vectors.   The optimal "cross-over" with respect to CPU time   
       is problem dependent and must be determined empirically.   

    5. If IPARAM(7) = 2 then in the Reverse commuication interface the user   
       must do the following. When IDO = 1, Y = OP * X is to be computed.   
       When IPARAM(7) = 2 OP = inv(B)*A. After computing A*X the user   
       must overwrite X with A*X. Y is then the solution to the linear set   
       of equations B*Y = A*X.   

    6. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the   
       NP = IPARAM(8) shifts in locations:   
       1   WORKL(IPNTR(11))   
       2   WORKL(IPNTR(11)+1)   
                          .   
                          .   
                          .   
       NP  WORKL(IPNTR(11)+NP-1).   

       The eigenvalues of the current tridiagonal matrix are located in   
       WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are in the   
       order defined by WHICH. The associated Ritz estimates are located in   
       WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).   

   -----------------------------------------------------------------------   

   \Data Distribution Note:   

    Fortran-D syntax:   
    ================   
    REAL       RESID(N), V(LDV,NCV), WORKD(3*N), WORKL(LWORKL)   
    DECOMPOSE  D1(N), D2(N,NCV)   
    ALIGN      RESID(I) with D1(I)   
    ALIGN      V(I,J)   with D2(I,J)   
    ALIGN      WORKD(I) with D1(I)     range (1:N)   
    ALIGN      WORKD(I) with D1(I-N)   range (N+1:2*N)   
    ALIGN      WORKD(I) with D1(I-2*N) range (2*N+1:3*N)   
    DISTRIBUTE D1(BLOCK), D2(BLOCK,:)   
    REPLICATED WORKL(LWORKL)   

    Cray MPP syntax:   
    ===============   
    REAL       RESID(N), V(LDV,NCV), WORKD(N,3), WORKL(LWORKL)   
    SHARED     RESID(BLOCK), V(BLOCK,:), WORKD(BLOCK,:)   
    REPLICATED WORKL(LWORKL)   


   \BeginLib   

   \References:   
    1. D.C. Sorensen, "Implicit Application of Polynomial Filters in   
       a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),   
       pp 357-385.   
    2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly   
       Restarted Arnoldi Iteration", Rice University Technical Report   
       TR95-13, Department of Computational and Applied Mathematics.   
    3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,   
       1980.   
    4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",   
       Computer Physics Communications, 53 (1989), pp 169-179.   
    5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to   
       Implement the Spectral Transformation", Math. Comp., 48 (1987),   
       pp 663-673.   
    6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos   
       Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",   
       SIAM J. Matr. Anal. Apps.,  January (1993).   
    7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines   
       for Updating the QR decomposition", ACM TOMS, December 1990,   
       Volume 16 Number 4, pp 369-377.   
    8. R.B. Lehoucq, D.C. Sorensen, "Implementation of Some Spectral   
       Transformations in a k-Step Arnoldi Method". In Preparation.   

   \Routines called:   
       dsaup2  ARPACK routine that implements the Implicitly Restarted   
               Arnoldi Iteration.   
       dstats  ARPACK routine that initialize timing and other statistics   
               variables.   
       ivout   ARPACK utility routine that prints integers.   
       second  ARPACK utility routine for timing.   
       dvout   ARPACK utility routine that prints vectors.   
       dlamch  LAPACK routine that determines machine constants.   

   \Authors   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       12/15/93: Version ' 2.4'   

   \SCCS Information: @(#)   
   FILE: saupd.F   SID: 2.7   DATE OF SID: 8/27/96   RELEASE: 2   

   \Remarks   
       1. None   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdsaupd_(integer *ido, char *bmat, integer *n, char *
	which, integer *nev, doublereal *tol, doublereal *resid, integer *ncv,
	 doublereal *v, integer *ldv, integer *iparam, integer *ipntr, 
	doublereal *workd, doublereal *workl, integer *lworkl, integer *info)
{
    /* Format strings */
    static char fmt_1000[] = "(//,5x,\002==================================="
	    "=======\002,/5x,\002= Symmetric implicit Arnoldi update code "
	    "=\002,/5x,\002= Version Number:\002,\002 2.4\002,19x,\002 =\002,"
	    "/5x,\002= Version Date:  \002,\002 07/31/96\002,14x,\002 =\002,/"
	    "5x,\002==========================================\002,/5x,\002= "
	    "Summary of timing statistics           =\002,/5x,\002==========="
	    "===============================\002,//)";
    static char fmt_1100[] = "(5x,\002Total number update iterations        "
	    "     = \002,i5,/5x,\002Total number of OP*x operations          "
	    "  = \002,i5,/5x,\002Total number of B*x operations             = "
	    "\002,i5,/5x,\002Total number of reorthogonalization steps  = "
	    "\002,i5,/5x,\002Total number of iterative refinement steps = "
	    "\002,i5,/5x,\002Total number of restart steps              = "
	    "\002,i5,/5x,\002Total time in user OP*x operation          = "
	    "\002,f12.6,/5x,\002Total time in user B*x operation           ="
	    " \002,f12.6,/5x,\002Total time in Arnoldi update routine       = "
	    "\002,f12.6,/5x,\002Total time in saup2 routine                ="
	    " \002,f12.6,/5x,\002Total time in basic Arnoldi iteration loop = "
	    "\002,f12.6,/5x,\002Total time in reorthogonalization phase    ="
	    " \002,f12.6,/5x,\002Total time in (re)start vector generation  = "
	    "\002,f12.6,/5x,\002Total time in trid eigenvalue subproblem   ="
	    " \002,f12.6,/5x,\002Total time in getting the shifts           = "
	    "\002,f12.6,/5x,\002Total time in applying the shifts          ="
	    " \002,f12.6,/5x,\002Total time in convergence testing          = "
	    "\002,f12.6)";

    /* System generated locals */
    integer v_dim1, v_offset, i__1, i__2;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *), e_wsfe(
	    void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    integer j;
    real t0, t1;
    IGRAPH_F77_SAVE integer nb, ih, iq, np, iw, ldh, ldq;
    integer nbx = 0;
    IGRAPH_F77_SAVE integer nev0, mode, ierr, iupd, next;
    integer nopx = 0;
    IGRAPH_F77_SAVE integer ritz;
    real tmvbx;
    extern /* Subroutine */ int igraphdvout_(integer *, integer *, doublereal *, 
	    integer *, char *, ftnlen), igraphivout_(integer *, integer *, integer *
	    , integer *, char *, ftnlen), igraphdsaup2_(integer *, char *, integer *
	    , char *, integer *, integer *, doublereal *, doublereal *, 
	    integer *, integer *, integer *, integer *, doublereal *, integer 
	    *, doublereal *, integer *, doublereal *, doublereal *, 
	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
	    integer *);
    real tgetv0, tsaup2;
    extern doublereal igraphdlamch_(char *);
    extern /* Subroutine */ int igraphsecond_(real *);
    integer logfil, ndigit;
    IGRAPH_F77_SAVE integer ishift;
    integer nitref, msaupd = 0;
    IGRAPH_F77_SAVE integer bounds;
    real titref, tseigt, tsaupd;
    extern /* Subroutine */ int igraphdstats_(void);
    IGRAPH_F77_SAVE integer msglvl;
    real tsaitr = 0.0;
    IGRAPH_F77_SAVE integer mxiter;
    real tsgets, tsapps;
    integer nrorth = 0;
    real tsconv = 0.0;
    integer nrstrt = 0;
    real tmvopx = 0.0;

    /* Fortran I/O blocks */
    static cilist io___28 = { 0, 6, 0, fmt_1000, 0 };
    static cilist io___29 = { 0, 6, 0, fmt_1100, 0 };



/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       Parameter adjustments */
    --workd;
    --resid;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    --iparam;
    --ipntr;
    --workl;

    /* Function Body */
    if (*ido == 0) {

/*        %-------------------------------%   
          | Initialize timing statistics  |   
          | & message level for debugging |   
          %-------------------------------% */

	igraphdstats_();
	igraphsecond_(&t0);
	msglvl = msaupd;

	ierr = 0;
	ishift = iparam[1];
	mxiter = iparam[3];
	nb = iparam[4];

/*        %--------------------------------------------%   
          | Revision 2 performs only implicit restart. |   
          %--------------------------------------------% */

	iupd = 1;
	mode = iparam[7];

/*        %----------------%   
          | Error checking |   
          %----------------% */

	if (*n <= 0) {
	    ierr = -1;
	} else if (*nev <= 0) {
	    ierr = -2;
	} else if (*ncv <= *nev || *ncv > *n) {
	    ierr = -3;
	}

/*        %----------------------------------------------%   
          | NP is the number of additional steps to      |   
          | extend the length NEV Lanczos factorization. |   
          %----------------------------------------------% */

	np = *ncv - *nev;

	if (mxiter <= 0) {
	    ierr = -4;
	}
	if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) != 0 && s_cmp(which, 
		"SM", (ftnlen)2, (ftnlen)2) != 0 && s_cmp(which, "LA", (
		ftnlen)2, (ftnlen)2) != 0 && s_cmp(which, "SA", (ftnlen)2, (
		ftnlen)2) != 0 && s_cmp(which, "BE", (ftnlen)2, (ftnlen)2) != 
		0) {
	    ierr = -5;
	}
	if (*(unsigned char *)bmat != 'I' && *(unsigned char *)bmat != 'G') {
	    ierr = -6;
	}

/* Computing 2nd power */
	i__1 = *ncv;
	if (*lworkl < i__1 * i__1 + (*ncv << 3)) {
	    ierr = -7;
	}
	if (mode < 1 || mode > 5) {
	    ierr = -10;
	} else if (mode == 1 && *(unsigned char *)bmat == 'G') {
	    ierr = -11;
	} else if (ishift < 0 || ishift > 1) {
	    ierr = -12;
	} else if (*nev == 1 && s_cmp(which, "BE", (ftnlen)2, (ftnlen)2) == 0)
		 {
	    ierr = -13;
	}

/*        %------------%   
          | Error Exit |   
          %------------% */

	if (ierr != 0) {
	    *info = ierr;
	    *ido = 99;
	    goto L9000;
	}

/*        %------------------------%   
          | Set default parameters |   
          %------------------------% */

	if (nb <= 0) {
	    nb = 1;
	}
	if (*tol <= 0.) {
	    *tol = igraphdlamch_("EpsMach");
	}

/*        %----------------------------------------------%   
          | NP is the number of additional steps to      |   
          | extend the length NEV Lanczos factorization. |   
          | NEV0 is the local variable designating the   |   
          | size of the invariant subspace desired.      |   
          %----------------------------------------------% */

	np = *ncv - *nev;
	nev0 = *nev;

/*        %-----------------------------%   
          | Zero out internal workspace |   
          %-----------------------------%   

   Computing 2nd power */
	i__2 = *ncv;
	i__1 = i__2 * i__2 + (*ncv << 3);
	for (j = 1; j <= i__1; ++j) {
	    workl[j] = 0.;
/* L10: */
	}

/*        %-------------------------------------------------------%   
          | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |   
          | etc... and the remaining workspace.                   |   
          | Also update pointer to be used on output.             |   
          | Memory is laid out as follows:                        |   
          | workl(1:2*ncv) := generated tridiagonal matrix        |   
          | workl(2*ncv+1:2*ncv+ncv) := ritz values               |   
          | workl(3*ncv+1:3*ncv+ncv) := computed error bounds     |   
          | workl(4*ncv+1:4*ncv+ncv*ncv) := rotation matrix Q     |   
          | workl(4*ncv+ncv*ncv+1:7*ncv+ncv*ncv) := workspace     |   
          %-------------------------------------------------------% */

	ldh = *ncv;
	ldq = *ncv;
	ih = 1;
	ritz = ih + (ldh << 1);
	bounds = ritz + *ncv;
	iq = bounds + *ncv;
/* Computing 2nd power */
	i__1 = *ncv;
	iw = iq + i__1 * i__1;
	next = iw + *ncv * 3;

	ipntr[4] = next;
	ipntr[5] = ih;
	ipntr[6] = ritz;
	ipntr[7] = bounds;
	ipntr[11] = iw;
    }

/*     %-------------------------------------------------------%   
       | Carry out the Implicitly restarted Lanczos Iteration. |   
       %-------------------------------------------------------% */

    igraphdsaup2_(ido, bmat, n, which, &nev0, &np, tol, &resid[1], &mode, &iupd, &
	    ishift, &mxiter, &v[v_offset], ldv, &workl[ih], &ldh, &workl[ritz]
	    , &workl[bounds], &workl[iq], &ldq, &workl[iw], &ipntr[1], &workd[
	    1], info);

/*     %--------------------------------------------------%   
       | ido .ne. 99 implies use of reverse communication |   
       | to compute operations involving OP or shifts.    |   
       %--------------------------------------------------% */

    if (*ido == 3) {
	iparam[8] = np;
    }
    if (*ido != 99) {
	goto L9000;
    }

    iparam[3] = mxiter;
    iparam[5] = np;
    iparam[9] = nopx;
    iparam[10] = nbx;
    iparam[11] = nrorth;

/*     %------------------------------------%   
       | Exit if there was an informational |   
       | error within dsaup2.               |   
       %------------------------------------% */

    if (*info < 0) {
	goto L9000;
    }
    if (*info == 2) {
	*info = 3;
    }

    if (msglvl > 0) {
	igraphivout_(&logfil, &dasum__c__1, &mxiter, &ndigit, "_saupd: number of update i"
		"terations taken", (ftnlen)41);
	igraphivout_(&logfil, &dasum__c__1, &np, &ndigit, "_saupd: number of \"converge"
		"d\" Ritz values", (ftnlen)41);
	igraphdvout_(&logfil, &np, &workl[ritz], &ndigit, "_saupd: final Ritz valu"
		"es", (ftnlen)25);
	igraphdvout_(&logfil, &np, &workl[bounds], &ndigit, "_saupd: corresponding"
		" error bounds", (ftnlen)34);
    }

    igraphsecond_(&t1);
    tsaupd = t1 - t0;

L9000:

    return 0;

/*     %---------------%   
       | End of dsaupd |   
       %---------------% */

} /* igraphdsaupd_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static doublereal daxpy__c_b3 = .66666666666666663;
static integer daxpy__c__1 = 1;
static integer daxpy__c__0 = 0;
static integer daxpy__c__3 = 3;
static logical daxpy__c_true = TRUE_;
static integer daxpy__c__2 = 2;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dsaup2   

   \Description:   
    Intermediate level interface called by dsaupd.   

   \Usage:   
    call dsaup2   
       ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,   
         ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL,   
         IPNTR, WORKD, INFO )   

   \Arguments   

    IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in dsaupd.   
    MODE, ISHIFT, MXITER: see the definition of IPARAM in dsaupd.   

    NP      Integer.  (INPUT/OUTPUT)   
            Contains the number of implicit shifts to apply during   
            each Arnoldi/Lanczos iteration.   
            If ISHIFT=1, NP is adjusted dynamically at each iteration   
            to accelerate convergence and prevent stagnation.   
            This is also roughly equal to the number of matrix-vector   
            products (involving the operator OP) per Arnoldi iteration.   
            The logic for adjusting is contained within the current   
            subroutine.   
            If ISHIFT=0, NP is the number of shifts the user needs   
            to provide via reverse comunication. 0 < NP < NCV-NEV.   
            NP may be less than NCV-NEV since a leading block of the current   
            upper Tridiagonal matrix has split off and contains "unwanted"   
            Ritz values.   
            Upon termination of the IRA iteration, NP contains the number   
            of "converged" wanted Ritz values.   

    IUPD    Integer.  (INPUT)   
            IUPD .EQ. 0: use explicit restart instead implicit update.   
            IUPD .NE. 0: use implicit update.   

    V       Double precision N by (NEV+NP) array.  (INPUT/OUTPUT)   
            The Lanczos basis vectors.   

    LDV     Integer.  (INPUT)   
            Leading dimension of V exactly as declared in the calling   
            program.   

    H       Double precision (NEV+NP) by 2 array.  (OUTPUT)   
            H is used to store the generated symmetric tridiagonal matrix   
            The subdiagonal is stored in the first column of H starting   
            at H(2,1).  The main diagonal is stored in the second column   
            of H starting at H(1,2). If dsaup2 converges store the   
            B-norm of the final residual vector in H(1,1).   

    LDH     Integer.  (INPUT)   
            Leading dimension of H exactly as declared in the calling   
            program.   

    RITZ    Double precision array of length NEV+NP.  (OUTPUT)   
            RITZ(1:NEV) contains the computed Ritz values of OP.   

    BOUNDS  Double precision array of length NEV+NP.  (OUTPUT)   
            BOUNDS(1:NEV) contain the error bounds corresponding to RITZ.   

    Q       Double precision (NEV+NP) by (NEV+NP) array.  (WORKSPACE)   
            Private (replicated) work array used to accumulate the   
            rotation in the shift application step.   

    LDQ     Integer.  (INPUT)   
            Leading dimension of Q exactly as declared in the calling   
            program.   

    WORKL   Double precision array of length at least 3*(NEV+NP).  (INPUT/WORKSPACE)   
            Private (replicated) array on each PE or array allocated on   
            the front end.  It is used in the computation of the   
            tridiagonal eigenvalue problem, the calculation and   
            application of the shifts and convergence checking.   
            If ISHIFT .EQ. O and IDO .EQ. 3, the first NP locations   
            of WORKL are used in reverse communication to hold the user   
            supplied shifts.   

    IPNTR   Integer array of length 3.  (OUTPUT)   
            Pointer to mark the starting locations in the WORKD for   
            vectors used by the Lanczos iteration.   
            -------------------------------------------------------------   
            IPNTR(1): pointer to the current operand vector X.   
            IPNTR(2): pointer to the current result vector Y.   
            IPNTR(3): pointer to the vector B * X when used in one of   
                      the spectral transformation modes.  X is the current   
                      operand.   
            -------------------------------------------------------------   

    WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)   
            Distributed array to be used in the basic Lanczos iteration   
            for reverse communication.  The user should not use WORKD   
            as temporary workspace during the iteration !!!!!!!!!!   
            See Data Distribution Note in dsaupd.   

    INFO    Integer.  (INPUT/OUTPUT)   
            If INFO .EQ. 0, a randomly initial residual vector is used.   
            If INFO .NE. 0, RESID contains the initial residual vector,   
                            possibly from a previous run.   
            Error flag on output.   
            =     0: Normal return.   
            =     1: All possible eigenvalues of OP has been found.   
                     NP returns the size of the invariant subspace   
                     spanning the operator OP.   
            =     2: No shifts could be applied.   
            =    -8: Error return from trid. eigenvalue calculation;   
                     This should never happen.   
            =    -9: Starting vector is zero.   
            = -9999: Could not build an Lanczos factorization.   
                     Size that was built in returned in NP.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \References:   
    1. D.C. Sorensen, "Implicit Application of Polynomial Filters in   
       a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),   
       pp 357-385.   
    2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly   
       Restarted Arnoldi Iteration", Rice University Technical Report   
       TR95-13, Department of Computational and Applied Mathematics.   
    3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,   
       1980.   
    4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",   
       Computer Physics Communications, 53 (1989), pp 169-179.   
    5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to   
       Implement the Spectral Transformation", Math. Comp., 48 (1987),   
       pp 663-673.   
    6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos   
       Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",   
       SIAM J. Matr. Anal. Apps.,  January (1993).   
    7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines   
       for Updating the QR decomposition", ACM TOMS, December 1990,   
       Volume 16 Number 4, pp 369-377.   

   \Routines called:   
       dgetv0  ARPACK initial vector generation routine.   
       dsaitr  ARPACK Lanczos factorization routine.   
       dsapps  ARPACK application of implicit shifts routine.   
       dsconv  ARPACK convergence of Ritz values routine.   
       dseigt  ARPACK compute Ritz values and error bounds routine.   
       dsgets  ARPACK reorder Ritz values and error bounds routine.   
       dsortr  ARPACK sorting routine.   
       ivout   ARPACK utility routine that prints integers.   
       second  ARPACK utility routine for timing.   
       dvout   ARPACK utility routine that prints vectors.   
       dlamch  LAPACK routine that determines machine constants.   
       dcopy   Level 1 BLAS that copies one vector to another.   
       ddot    Level 1 BLAS that computes the scalar product of two vectors.   
       dnrm2   Level 1 BLAS that computes the norm of a vector.   
       dscal   Level 1 BLAS that scales a vector.   
       dswap   Level 1 BLAS that swaps two vectors.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       12/15/93: Version ' 2.4'   
       xx/xx/95: Version ' 2.4'.  (R.B. Lehoucq)   

   \SCCS Information: @(#)   
   FILE: saup2.F   SID: 2.6   DATE OF SID: 8/16/96   RELEASE: 2   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdsaup2_(integer *ido, char *bmat, integer *n, char *
	which, integer *nev, integer *np, doublereal *tol, doublereal *resid, 
	integer *mode, integer *iupd, integer *ishift, integer *mxiter, 
	doublereal *v, integer *ldv, doublereal *h__, integer *ldh, 
	doublereal *ritz, doublereal *bounds, doublereal *q, integer *ldq, 
	doublereal *workl, integer *ipntr, doublereal *workd, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, q_dim1, q_offset, v_dim1, v_offset, i__1, i__2, 
	    i__3;
    doublereal d__1, d__2, d__3;

    /* Builtin functions */
    double pow_dd(doublereal *, doublereal *);
    integer s_cmp(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    double sqrt(doublereal);

    /* Local variables */
    integer j;
    real t0, t1, t2, t3;
    integer kp[3];
    IGRAPH_F77_SAVE integer np0;
    integer nbx = 0;
    IGRAPH_F77_SAVE integer nev0;
    extern doublereal igraphddot_(integer *, doublereal *, integer *, doublereal *, 
	    integer *);
    IGRAPH_F77_SAVE doublereal eps23;
    integer ierr;
    IGRAPH_F77_SAVE integer iter;
    doublereal temp;
    integer nevd2;
    extern doublereal igraphdnrm2_(integer *, doublereal *, integer *);
    IGRAPH_F77_SAVE logical getv0;
    integer nevm2;
    IGRAPH_F77_SAVE logical cnorm;
    extern /* Subroutine */ int igraphdcopy_(integer *, doublereal *, integer *, 
	    doublereal *, integer *), igraphdswap_(integer *, doublereal *, integer 
	    *, doublereal *, integer *);
    IGRAPH_F77_SAVE integer nconv;
    IGRAPH_F77_SAVE logical initv;
    IGRAPH_F77_SAVE doublereal rnorm;
    real tmvbx = 0.0;
    extern /* Subroutine */ int igraphdvout_(integer *, integer *, doublereal *, 
	    integer *, char *, ftnlen), igraphivout_(integer *, integer *, integer *
	    , integer *, char *, ftnlen), igraphdgetv0_(integer *, char *, integer *
	    , logical *, integer *, integer *, doublereal *, integer *, 
	    doublereal *, doublereal *, integer *, doublereal *, integer *);
    integer msaup2 = 0;
    real tsaup2;
    extern doublereal igraphdlamch_(char *);
    integer nevbef;
    extern /* Subroutine */ int igraphsecond_(real *);
    integer logfil, ndigit;
    extern /* Subroutine */ int igraphdseigt_(doublereal *, integer *, doublereal *,
	     integer *, doublereal *, doublereal *, doublereal *, integer *);
    IGRAPH_F77_SAVE logical update;
    extern /* Subroutine */ int igraphdsaitr_(integer *, char *, integer *, integer 
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, doublereal *, integer *, integer *, doublereal *, 
	    integer *), igraphdsgets_(integer *, char *, integer *, integer 
	    *, doublereal *, doublereal *, doublereal *), igraphdsapps_(
	    integer *, integer *, integer *, doublereal *, doublereal *, 
	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
	    integer *, doublereal *), igraphdsconv_(integer *, doublereal *, 
	    doublereal *, doublereal *, integer *);
    IGRAPH_F77_SAVE logical ushift;
    char wprime[2];
    IGRAPH_F77_SAVE integer msglvl;
    integer nptemp;
    extern /* Subroutine */ int igraphdsortr_(char *, logical *, integer *, 
	    doublereal *, doublereal *);
    IGRAPH_F77_SAVE integer kplusp;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %---------------------%   
       | Intrinsic Functions |   
       %---------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       Parameter adjustments */
    --workd;
    --resid;
    --workl;
    --bounds;
    --ritz;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --ipntr;

    /* Function Body */
    if (*ido == 0) {

/*        %-------------------------------%   
          | Initialize timing statistics  |   
          | & message level for debugging |   
          %-------------------------------% */

	igraphsecond_(&t0);
	msglvl = msaup2;

/*        %---------------------------------%   
          | Set machine dependent constant. |   
          %---------------------------------% */

	eps23 = igraphdlamch_("Epsilon-Machine");
	eps23 = pow_dd(&eps23, &daxpy__c_b3);

/*        %-------------------------------------%   
          | nev0 and np0 are integer variables  |   
          | hold the initial values of NEV & NP |   
          %-------------------------------------% */

	nev0 = *nev;
	np0 = *np;

/*        %-------------------------------------%   
          | kplusp is the bound on the largest  |   
          |        Lanczos factorization built. |   
          | nconv is the current number of      |   
          |        "converged" eigenvlues.      |   
          | iter is the counter on the current  |   
          |      iteration step.                |   
          %-------------------------------------% */

	kplusp = nev0 + np0;
	nconv = 0;
	iter = 0;

/*        %--------------------------------------------%   
          | Set flags for computing the first NEV steps |   
          | of the Lanczos factorization.              |   
          %--------------------------------------------% */

	getv0 = TRUE_;
	update = FALSE_;
	ushift = FALSE_;
	cnorm = FALSE_;

	if (*info != 0) {

/*        %--------------------------------------------%   
          | User provides the initial residual vector. |   
          %--------------------------------------------% */

	    initv = TRUE_;
	    *info = 0;
	} else {
	    initv = FALSE_;
	}
    }

/*     %---------------------------------------------%   
       | Get a possibly random starting vector and   |   
       | force it into the range of the operator OP. |   
       %---------------------------------------------%   

   L10: */

    if (getv0) {
	igraphdgetv0_(ido, bmat, &daxpy__c__1, &initv, n, &daxpy__c__1, &v[v_offset], ldv, &resid[
		1], &rnorm, &ipntr[1], &workd[1], info);

	if (*ido != 99) {
	    goto L9000;
	}

	if (rnorm == 0.) {

/*           %-----------------------------------------%   
             | The initial vector is zero. Error exit. |   
             %-----------------------------------------% */

	    *info = -9;
	    goto L1200;
	}
	getv0 = FALSE_;
	*ido = 0;
    }

/*     %------------------------------------------------------------%   
       | Back from reverse communication: continue with update step |   
       %------------------------------------------------------------% */

    if (update) {
	goto L20;
    }

/*     %-------------------------------------------%   
       | Back from computing user specified shifts |   
       %-------------------------------------------% */

    if (ushift) {
	goto L50;
    }

/*     %-------------------------------------%   
       | Back from computing residual norm   |   
       | at the end of the current iteration |   
       %-------------------------------------% */

    if (cnorm) {
	goto L100;
    }

/*     %----------------------------------------------------------%   
       | Compute the first NEV steps of the Lanczos factorization |   
       %----------------------------------------------------------% */

    igraphdsaitr_(ido, bmat, n, &daxpy__c__0, &nev0, mode, &resid[1], &rnorm, &v[v_offset],
	     ldv, &h__[h_offset], ldh, &ipntr[1], &workd[1], info);

/*     %---------------------------------------------------%   
       | ido .ne. 99 implies use of reverse communication  |   
       | to compute operations involving OP and possibly B |   
       %---------------------------------------------------% */

    if (*ido != 99) {
	goto L9000;
    }

    if (*info > 0) {

/*        %-----------------------------------------------------%   
          | dsaitr was unable to build an Lanczos factorization |   
          | of length NEV0. INFO is returned with the size of   |   
          | the factorization built. Exit main loop.            |   
          %-----------------------------------------------------% */

	*np = *info;
	*mxiter = iter;
	*info = -9999;
	goto L1200;
    }

/*     %--------------------------------------------------------------%   
       |                                                              |   
       |           M A I N  LANCZOS  I T E R A T I O N  L O O P       |   
       |           Each iteration implicitly restarts the Lanczos     |   
       |           factorization in place.                            |   
       |                                                              |   
       %--------------------------------------------------------------% */

L1000:

    ++iter;

    if (msglvl > 0) {
	igraphivout_(&logfil, &daxpy__c__1, &iter, &ndigit, "_saup2: **** Start of major "
		"iteration number ****", (ftnlen)49);
    }
    if (msglvl > 1) {
	igraphivout_(&logfil, &daxpy__c__1, nev, &ndigit, "_saup2: The length of the curr"
		"ent Lanczos factorization", (ftnlen)55);
	igraphivout_(&logfil, &daxpy__c__1, np, &ndigit, "_saup2: Extend the Lanczos fact"
		"orization by", (ftnlen)43);
    }

/*        %------------------------------------------------------------%   
          | Compute NP additional steps of the Lanczos factorization. |   
          %------------------------------------------------------------% */

    *ido = 0;
L20:
    update = TRUE_;

    igraphdsaitr_(ido, bmat, n, nev, np, mode, &resid[1], &rnorm, &v[v_offset], ldv,
	     &h__[h_offset], ldh, &ipntr[1], &workd[1], info);

/*        %---------------------------------------------------%   
          | ido .ne. 99 implies use of reverse communication  |   
          | to compute operations involving OP and possibly B |   
          %---------------------------------------------------% */

    if (*ido != 99) {
	goto L9000;
    }

    if (*info > 0) {

/*           %-----------------------------------------------------%   
             | dsaitr was unable to build an Lanczos factorization |   
             | of length NEV0+NP0. INFO is returned with the size  |   
             | of the factorization built. Exit main loop.         |   
             %-----------------------------------------------------% */

	*np = *info;
	*mxiter = iter;
	*info = -9999;
	goto L1200;
    }
    update = FALSE_;

    if (msglvl > 1) {
	igraphdvout_(&logfil, &daxpy__c__1, &rnorm, &ndigit, "_saup2: Current B-norm of r"
		"esidual for factorization", (ftnlen)52);
    }

/*        %--------------------------------------------------------%   
          | Compute the eigenvalues and corresponding error bounds |   
          | of the current symmetric tridiagonal matrix.           |   
          %--------------------------------------------------------% */

    igraphdseigt_(&rnorm, &kplusp, &h__[h_offset], ldh, &ritz[1], &bounds[1], &
	    workl[1], &ierr);

    if (ierr != 0) {
	*info = -8;
	goto L1200;
    }

/*        %----------------------------------------------------%   
          | Make a copy of eigenvalues and corresponding error |   
          | bounds obtained from _seigt.                       |   
          %----------------------------------------------------% */

    igraphdcopy_(&kplusp, &ritz[1], &daxpy__c__1, &workl[kplusp + 1], &daxpy__c__1);
    igraphdcopy_(&kplusp, &bounds[1], &daxpy__c__1, &workl[(kplusp << 1) + 1], &daxpy__c__1);

/*        %---------------------------------------------------%   
          | Select the wanted Ritz values and their bounds    |   
          | to be used in the convergence test.               |   
          | The selection is based on the requested number of |   
          | eigenvalues instead of the current NEV and NP to  |   
          | prevent possible misconvergence.                  |   
          | * Wanted Ritz values := RITZ(NP+1:NEV+NP)         |   
          | * Shifts := RITZ(1:NP) := WORKL(1:NP)             |   
          %---------------------------------------------------% */

    *nev = nev0;
    *np = np0;
    igraphdsgets_(ishift, which, nev, np, &ritz[1], &bounds[1], &workl[1]);

/*        %-------------------%   
          | Convergence test. |   
          %-------------------% */

    igraphdcopy_(nev, &bounds[*np + 1], &daxpy__c__1, &workl[*np + 1], &daxpy__c__1);
    igraphdsconv_(nev, &ritz[*np + 1], &workl[*np + 1], tol, &nconv);

    if (msglvl > 2) {
	kp[0] = *nev;
	kp[1] = *np;
	kp[2] = nconv;
	igraphivout_(&logfil, &daxpy__c__3, kp, &ndigit, "_saup2: NEV, NP, NCONV are", (
		ftnlen)26);
	igraphdvout_(&logfil, &kplusp, &ritz[1], &ndigit, "_saup2: The eigenvalues"
		" of H", (ftnlen)28);
	igraphdvout_(&logfil, &kplusp, &bounds[1], &ndigit, "_saup2: Ritz estimate"
		"s of the current NCV Ritz values", (ftnlen)53);
    }

/*        %---------------------------------------------------------%   
          | Count the number of unwanted Ritz values that have zero |   
          | Ritz estimates. If any Ritz estimates are equal to zero |   
          | then a leading block of H of order equal to at least    |   
          | the number of Ritz values with zero Ritz estimates has  |   
          | split off. None of these Ritz values may be removed by  |   
          | shifting. Decrease NP the number of shifts to apply. If |   
          | no shifts may be applied, then prepare to exit          |   
          %---------------------------------------------------------% */

    nptemp = *np;
    i__1 = nptemp;
    for (j = 1; j <= i__1; ++j) {
	if (bounds[j] == 0.) {
	    --(*np);
	    ++(*nev);
	}
/* L30: */
    }

    if (nconv >= nev0 || iter > *mxiter || *np == 0) {

/*           %------------------------------------------------%   
             | Prepare to exit. Put the converged Ritz values |   
             | and corresponding bounds in RITZ(1:NCONV) and  |   
             | BOUNDS(1:NCONV) respectively. Then sort. Be    |   
             | careful when NCONV > NP since we don't want to |   
             | swap overlapping locations.                    |   
             %------------------------------------------------% */

	if (s_cmp(which, "BE", (ftnlen)2, (ftnlen)2) == 0) {

/*              %-----------------------------------------------------%   
                | Both ends of the spectrum are requested.            |   
                | Sort the eigenvalues into algebraically decreasing  |   
                | order first then swap low end of the spectrum next  |   
                | to high end in appropriate locations.               |   
                | NOTE: when np < floor(nev/2) be careful not to swap |   
                | overlapping locations.                              |   
                %-----------------------------------------------------% */

	    s_copy(wprime, "SA", (ftnlen)2, (ftnlen)2);
	    igraphdsortr_(wprime, &daxpy__c_true, &kplusp, &ritz[1], &bounds[1])
		    ;
	    nevd2 = *nev / 2;
	    nevm2 = *nev - nevd2;
	    if (*nev > 1) {
		i__1 = min(nevd2,*np);
/* Computing MAX */
		i__2 = kplusp - nevd2 + 1, i__3 = kplusp - *np + 1;
		igraphdswap_(&i__1, &ritz[nevm2 + 1], &daxpy__c__1, &ritz[max(i__2,i__3)], 
			&daxpy__c__1);
		i__1 = min(nevd2,*np);
/* Computing MAX */
		i__2 = kplusp - nevd2 + 1, i__3 = kplusp - *np;
		igraphdswap_(&i__1, &bounds[nevm2 + 1], &daxpy__c__1, &bounds[max(i__2,
			i__3) + 1], &daxpy__c__1);
	    }

	} else {

/*              %--------------------------------------------------%   
                | LM, SM, LA, SA case.                             |   
                | Sort the eigenvalues of H into the an order that |   
                | is opposite to WHICH, and apply the resulting    |   
                | order to BOUNDS.  The eigenvalues are sorted so  |   
                | that the wanted part are always within the first |   
                | NEV locations.                                   |   
                %--------------------------------------------------% */

	    if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0) {
		s_copy(wprime, "SM", (ftnlen)2, (ftnlen)2);
	    }
	    if (s_cmp(which, "SM", (ftnlen)2, (ftnlen)2) == 0) {
		s_copy(wprime, "LM", (ftnlen)2, (ftnlen)2);
	    }
	    if (s_cmp(which, "LA", (ftnlen)2, (ftnlen)2) == 0) {
		s_copy(wprime, "SA", (ftnlen)2, (ftnlen)2);
	    }
	    if (s_cmp(which, "SA", (ftnlen)2, (ftnlen)2) == 0) {
		s_copy(wprime, "LA", (ftnlen)2, (ftnlen)2);
	    }

	    igraphdsortr_(wprime, &daxpy__c_true, &kplusp, &ritz[1], &bounds[1])
		    ;

	}

/*           %--------------------------------------------------%   
             | Scale the Ritz estimate of each Ritz value       |   
             | by 1 / max(eps23,magnitude of the Ritz value).   |   
             %--------------------------------------------------% */

	i__1 = nev0;
	for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
	    d__2 = eps23, d__3 = (d__1 = ritz[j], abs(d__1));
	    temp = max(d__2,d__3);
	    bounds[j] /= temp;
/* L35: */
	}

/*           %----------------------------------------------------%   
             | Sort the Ritz values according to the scaled Ritz  |   
             | esitmates.  This will push all the converged ones  |   
             | towards the front of ritzr, ritzi, bounds          |   
             | (in the case when NCONV < NEV.)                    |   
             %----------------------------------------------------% */

	s_copy(wprime, "LA", (ftnlen)2, (ftnlen)2);
	igraphdsortr_(wprime, &daxpy__c_true, &nev0, &bounds[1], &ritz[1]);

/*           %----------------------------------------------%   
             | Scale the Ritz estimate back to its original |   
             | value.                                       |   
             %----------------------------------------------% */

	i__1 = nev0;
	for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
	    d__2 = eps23, d__3 = (d__1 = ritz[j], abs(d__1));
	    temp = max(d__2,d__3);
	    bounds[j] *= temp;
/* L40: */
	}

/*           %--------------------------------------------------%   
             | Sort the "converged" Ritz values again so that   |   
             | the "threshold" values and their associated Ritz |   
             | estimates appear at the appropriate position in  |   
             | ritz and bound.                                  |   
             %--------------------------------------------------% */

	if (s_cmp(which, "BE", (ftnlen)2, (ftnlen)2) == 0) {

/*              %------------------------------------------------%   
                | Sort the "converged" Ritz values in increasing |   
                | order.  The "threshold" values are in the      |   
                | middle.                                        |   
                %------------------------------------------------% */

	    s_copy(wprime, "LA", (ftnlen)2, (ftnlen)2);
	    igraphdsortr_(wprime, &daxpy__c_true, &nconv, &ritz[1], &bounds[1]);

	} else {

/*              %----------------------------------------------%   
                | In LM, SM, LA, SA case, sort the "converged" |   
                | Ritz values according to WHICH so that the   |   
                | "threshold" value appears at the front of    |   
                | ritz.                                        |   
                %----------------------------------------------% */
	    igraphdsortr_(which, &daxpy__c_true, &nconv, &ritz[1], &bounds[1]);

	}

/*           %------------------------------------------%   
             |  Use h( 1,1 ) as storage to communicate  |   
             |  rnorm to _seupd if needed               |   
             %------------------------------------------% */

	h__[h_dim1 + 1] = rnorm;

	if (msglvl > 1) {
	    igraphdvout_(&logfil, &kplusp, &ritz[1], &ndigit, "_saup2: Sorted Ritz"
		    " values.", (ftnlen)27);
	    igraphdvout_(&logfil, &kplusp, &bounds[1], &ndigit, "_saup2: Sorted ri"
		    "tz estimates.", (ftnlen)30);
	}

/*           %------------------------------------%   
             | Max iterations have been exceeded. |   
             %------------------------------------% */

	if (iter > *mxiter && nconv < *nev) {
	    *info = 1;
	}

/*           %---------------------%   
             | No shifts to apply. |   
             %---------------------% */

	if (*np == 0 && nconv < nev0) {
	    *info = 2;
	}

	*np = nconv;
	goto L1100;

    } else if (nconv < *nev && *ishift == 1) {

/*           %---------------------------------------------------%   
             | Do not have all the requested eigenvalues yet.    |   
             | To prevent possible stagnation, adjust the number |   
             | of Ritz values and the shifts.                    |   
             %---------------------------------------------------% */

	nevbef = *nev;
/* Computing MIN */
	i__1 = nconv, i__2 = *np / 2;
	*nev += min(i__1,i__2);
	if (*nev == 1 && kplusp >= 6) {
	    *nev = kplusp / 2;
	} else if (*nev == 1 && kplusp > 2) {
	    *nev = 2;
	}
	*np = kplusp - *nev;

/*           %---------------------------------------%   
             | If the size of NEV was just increased |   
             | resort the eigenvalues.               |   
             %---------------------------------------% */

	if (nevbef < *nev) {
	    igraphdsgets_(ishift, which, nev, np, &ritz[1], &bounds[1], &workl[1]);
	}

    }

    if (msglvl > 0) {
	igraphivout_(&logfil, &daxpy__c__1, &nconv, &ndigit, "_saup2: no. of \"converge"
		"d\" Ritz values at this iter.", (ftnlen)52);
	if (msglvl > 1) {
	    kp[0] = *nev;
	    kp[1] = *np;
	    igraphivout_(&logfil, &daxpy__c__2, kp, &ndigit, "_saup2: NEV and NP are", (
		    ftnlen)22);
	    igraphdvout_(&logfil, nev, &ritz[*np + 1], &ndigit, "_saup2: \"wante"
		    "d\" Ritz values.", (ftnlen)29);
	    igraphdvout_(&logfil, nev, &bounds[*np + 1], &ndigit, "_saup2: Ritz es"
		    "timates of the \"wanted\" values ", (ftnlen)46);
	}
    }

    if (*ishift == 0) {

/*           %-----------------------------------------------------%   
             | User specified shifts: reverse communication to     |   
             | compute the shifts. They are returned in the first  |   
             | NP locations of WORKL.                              |   
             %-----------------------------------------------------% */

	ushift = TRUE_;
	*ido = 3;
	goto L9000;
    }

L50:

/*        %------------------------------------%   
          | Back from reverse communication;   |   
          | User specified shifts are returned |   
          | in WORKL(1:*NP)                   |   
          %------------------------------------% */

    ushift = FALSE_;


/*        %---------------------------------------------------------%   
          | Move the NP shifts to the first NP locations of RITZ to |   
          | free up WORKL.  This is for the non-exact shift case;   |   
          | in the exact shift case, dsgets already handles this.   |   
          %---------------------------------------------------------% */

    if (*ishift == 0) {
	igraphdcopy_(np, &workl[1], &daxpy__c__1, &ritz[1], &daxpy__c__1);
    }

    if (msglvl > 2) {
	igraphivout_(&logfil, &daxpy__c__1, np, &ndigit, "_saup2: The number of shifts to"
		" apply ", (ftnlen)38);
	igraphdvout_(&logfil, np, &workl[1], &ndigit, "_saup2: shifts selected", (
		ftnlen)23);
	if (*ishift == 1) {
	    igraphdvout_(&logfil, np, &bounds[1], &ndigit, "_saup2: corresponding "
		    "Ritz estimates", (ftnlen)36);
	}
    }

/*        %---------------------------------------------------------%   
          | Apply the NP0 implicit shifts by QR bulge chasing.      |   
          | Each shift is applied to the entire tridiagonal matrix. |   
          | The first 2*N locations of WORKD are used as workspace. |   
          | After dsapps is done, we have a Lanczos                 |   
          | factorization of length NEV.                            |   
          %---------------------------------------------------------% */

    igraphdsapps_(n, nev, np, &ritz[1], &v[v_offset], ldv, &h__[h_offset], ldh, &
	    resid[1], &q[q_offset], ldq, &workd[1]);

/*        %---------------------------------------------%   
          | Compute the B-norm of the updated residual. |   
          | Keep B*RESID in WORKD(1:N) to be used in    |   
          | the first step of the next call to dsaitr.  |   
          %---------------------------------------------% */

    cnorm = TRUE_;
    igraphsecond_(&t2);
    if (*(unsigned char *)bmat == 'G') {
	++nbx;
	igraphdcopy_(n, &resid[1], &daxpy__c__1, &workd[*n + 1], &daxpy__c__1);
	ipntr[1] = *n + 1;
	ipntr[2] = 1;
	*ido = 2;

/*           %----------------------------------%   
             | Exit in order to compute B*RESID |   
             %----------------------------------% */

	goto L9000;
    } else if (*(unsigned char *)bmat == 'I') {
	igraphdcopy_(n, &resid[1], &daxpy__c__1, &workd[1], &daxpy__c__1);
    }

L100:

/*        %----------------------------------%   
          | Back from reverse communication; |   
          | WORKD(1:N) := B*RESID            |   
          %----------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvbx += t3 - t2;
    }

    if (*(unsigned char *)bmat == 'G') {
	rnorm = igraphddot_(n, &resid[1], &daxpy__c__1, &workd[1], &daxpy__c__1);
	rnorm = sqrt((abs(rnorm)));
    } else if (*(unsigned char *)bmat == 'I') {
	rnorm = igraphdnrm2_(n, &resid[1], &daxpy__c__1);
    }
    cnorm = FALSE_;
/* L130: */

    if (msglvl > 2) {
	igraphdvout_(&logfil, &daxpy__c__1, &rnorm, &ndigit, "_saup2: B-norm of residual "
		"for NEV factorization", (ftnlen)48);
	igraphdvout_(&logfil, nev, &h__[(h_dim1 << 1) + 1], &ndigit, "_saup2: main"
		" diagonal of compressed H matrix", (ftnlen)44);
	i__1 = *nev - 1;
	igraphdvout_(&logfil, &i__1, &h__[h_dim1 + 2], &ndigit, "_saup2: subdiagon"
		"al of compressed H matrix", (ftnlen)42);
    }

    goto L1000;

/*     %---------------------------------------------------------------%   
       |                                                               |   
       |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |   
       |                                                               |   
       %---------------------------------------------------------------% */

L1100:

    *mxiter = iter;
    *nev = nconv;

L1200:
    *ido = 99;

/*     %------------%   
       | Error exit |   
       %------------% */

    igraphsecond_(&t1);
    tsaup2 = t1 - t0;

L9000:
    return 0;

/*     %---------------%   
       | End of dsaup2 |   
       %---------------% */

} /* igraphdsaup2_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/




/* \SCCS Information: @(#)   
   FILE: stats.F   SID: 2.1   DATE OF SID: 4/19/96   RELEASE: 2   
       %---------------------------------------------%   
       | Initialize statistic and timing information |   
       | for symmetric Arnoldi code.                 |   
       %---------------------------------------------%   
   Subroutine */ int igraphdstats_(void)
{
    integer nbx, nopx;
    real trvec, tmvbx, tgetv0, tsaup2;
    integer nitref;
    real titref, tseigt, tsaupd, tsaitr, tsgets, tsapps;
    integer nrorth;
    real tsconv;
    integer nrstrt;
    real tmvopx;

/*     %--------------------------------%   
       | See stat.doc for documentation |   
       %--------------------------------%   
       %-----------------------%   
       | Executable Statements |   
       %-----------------------% */
    nopx = 0;
    nbx = 0;
    nrorth = 0;
    nitref = 0;
    nrstrt = 0;
    tsaupd = 0.f;
    tsaup2 = 0.f;
    tsaitr = 0.f;
    tseigt = 0.f;
    tsgets = 0.f;
    tsapps = 0.f;
    tsconv = 0.f;
    titref = 0.f;
    tgetv0 = 0.f;
    trvec = 0.f;
/*     %----------------------------------------------------%   
       | User time including reverse communication overhead |   
       %----------------------------------------------------% */
    tmvopx = 0.f;
    tmvbx = 0.f;
    return 0;

/*     End of dstats */

} /* igraphdstats_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer ddot__c__1 = 1;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dsesrt   

   \Description:   
    Sort the array X in the order specified by WHICH and optionally   
    apply the permutation to the columns of the matrix A.   

   \Usage:   
    call dsesrt   
       ( WHICH, APPLY, N, X, NA, A, LDA)   

   \Arguments   
    WHICH   Character*2.  (Input)   
            'LM' -> X is sorted into increasing order of magnitude.   
            'SM' -> X is sorted into decreasing order of magnitude.   
            'LA' -> X is sorted into increasing order of algebraic.   
            'SA' -> X is sorted into decreasing order of algebraic.   

    APPLY   Logical.  (Input)   
            APPLY = .TRUE.  -> apply the sorted order to A.   
            APPLY = .FALSE. -> do not apply the sorted order to A.   

    N       Integer.  (INPUT)   
            Dimension of the array X.   

    X      Double precision array of length N.  (INPUT/OUTPUT)   
            The array to be sorted.   

    NA      Integer.  (INPUT)   
            Number of rows of the matrix A.   

    A      Double precision array of length NA by N.  (INPUT/OUTPUT)   

    LDA     Integer.  (INPUT)   
            Leading dimension of A.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Routines   
       dswap  Level 1 BLAS that swaps the contents of two vectors.   

   \Authors   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       12/15/93: Version ' 2.1'.   
                 Adapted from the sort routine in LANSO and   
                 the ARPACK code dsortr   

   \SCCS Information: @(#)   
   FILE: sesrt.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdsesrt_(char *which, logical *apply, integer *n, 
	doublereal *x, integer *na, doublereal *a, integer *lda)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1;
    doublereal d__1, d__2;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    integer i__, j, igap;
    doublereal temp;
    extern /* Subroutine */ int igraphdswap_(integer *, doublereal *, integer *, 
	    doublereal *, integer *);


/*     %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1 * 0;
    a -= a_offset;

    /* Function Body */
    igap = *n / 2;

    if (s_cmp(which, "SA", (ftnlen)2, (ftnlen)2) == 0) {

/*        X is sorted into decreasing order of algebraic. */

L10:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L20:

	    if (j < 0) {
		goto L30;
	    }

	    if (x[j] < x[j + igap]) {
		temp = x[j];
		x[j] = x[j + igap];
		x[j + igap] = temp;
		if (*apply) {
		    igraphdswap_(na, &a[j * a_dim1 + 1], &ddot__c__1, &a[(j + igap) * 
			    a_dim1 + 1], &ddot__c__1);
		}
	    } else {
		goto L30;
	    }
	    j -= igap;
	    goto L20;
L30:
	    ;
	}
	igap /= 2;
	goto L10;

    } else if (s_cmp(which, "SM", (ftnlen)2, (ftnlen)2) == 0) {

/*        X is sorted into decreasing order of magnitude. */

L40:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L50:

	    if (j < 0) {
		goto L60;
	    }

	    if ((d__1 = x[j], abs(d__1)) < (d__2 = x[j + igap], abs(d__2))) {
		temp = x[j];
		x[j] = x[j + igap];
		x[j + igap] = temp;
		if (*apply) {
		    igraphdswap_(na, &a[j * a_dim1 + 1], &ddot__c__1, &a[(j + igap) * 
			    a_dim1 + 1], &ddot__c__1);
		}
	    } else {
		goto L60;
	    }
	    j -= igap;
	    goto L50;
L60:
	    ;
	}
	igap /= 2;
	goto L40;

    } else if (s_cmp(which, "LA", (ftnlen)2, (ftnlen)2) == 0) {

/*        X is sorted into increasing order of algebraic. */

L70:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L80:

	    if (j < 0) {
		goto L90;
	    }

	    if (x[j] > x[j + igap]) {
		temp = x[j];
		x[j] = x[j + igap];
		x[j + igap] = temp;
		if (*apply) {
		    igraphdswap_(na, &a[j * a_dim1 + 1], &ddot__c__1, &a[(j + igap) * 
			    a_dim1 + 1], &ddot__c__1);
		}
	    } else {
		goto L90;
	    }
	    j -= igap;
	    goto L80;
L90:
	    ;
	}
	igap /= 2;
	goto L70;

    } else if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0) {

/*        X is sorted into increasing order of magnitude. */

L100:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L110:

	    if (j < 0) {
		goto L120;
	    }

	    if ((d__1 = x[j], abs(d__1)) > (d__2 = x[j + igap], abs(d__2))) {
		temp = x[j];
		x[j] = x[j + igap];
		x[j + igap] = temp;
		if (*apply) {
		    igraphdswap_(na, &a[j * a_dim1 + 1], &ddot__c__1, &a[(j + igap) * 
			    a_dim1 + 1], &ddot__c__1);
		}
	    } else {
		goto L120;
	    }
	    j -= igap;
	    goto L110;
L120:
	    ;
	}
	igap /= 2;
	goto L100;
    }

L9000:
    return 0;

/*     %---------------%   
       | End of dsesrt |   
       %---------------% */

} /* igraphdsesrt_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dsortr   

   \Description:   
    Sort the array X1 in the order specified by WHICH and optionally   
    applies the permutation to the array X2.   

   \Usage:   
    call dsortr   
       ( WHICH, APPLY, N, X1, X2 )   

   \Arguments   
    WHICH   Character*2.  (Input)   
            'LM' -> X1 is sorted into increasing order of magnitude.   
            'SM' -> X1 is sorted into decreasing order of magnitude.   
            'LA' -> X1 is sorted into increasing order of algebraic.   
            'SA' -> X1 is sorted into decreasing order of algebraic.   

    APPLY   Logical.  (Input)   
            APPLY = .TRUE.  -> apply the sorted order to X2.   
            APPLY = .FALSE. -> do not apply the sorted order to X2.   

    N       Integer.  (INPUT)   
            Size of the arrays.   

    X1      Double precision array of length N.  (INPUT/OUTPUT)   
            The array to be sorted.   

    X2      Double precision array of length N.  (INPUT/OUTPUT)   
            Only referenced if APPLY = .TRUE.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       12/16/93: Version ' 2.1'.   
                 Adapted from the sort routine in LANSO.   

   \SCCS Information: @(#)   
   FILE: sortr.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdsortr_(char *which, logical *apply, integer *n, 
	doublereal *x1, doublereal *x2)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    integer i__, j, igap;
    doublereal temp;


/*     %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------% */

    igap = *n / 2;

    if (s_cmp(which, "SA", (ftnlen)2, (ftnlen)2) == 0) {

/*        X1 is sorted into decreasing order of algebraic. */

L10:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L20:

	    if (j < 0) {
		goto L30;
	    }

	    if (x1[j] < x1[j + igap]) {
		temp = x1[j];
		x1[j] = x1[j + igap];
		x1[j + igap] = temp;
		if (*apply) {
		    temp = x2[j];
		    x2[j] = x2[j + igap];
		    x2[j + igap] = temp;
		}
	    } else {
		goto L30;
	    }
	    j -= igap;
	    goto L20;
L30:
	    ;
	}
	igap /= 2;
	goto L10;

    } else if (s_cmp(which, "SM", (ftnlen)2, (ftnlen)2) == 0) {

/*        X1 is sorted into decreasing order of magnitude. */

L40:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L50:

	    if (j < 0) {
		goto L60;
	    }

	    if ((d__1 = x1[j], abs(d__1)) < (d__2 = x1[j + igap], abs(d__2))) 
		    {
		temp = x1[j];
		x1[j] = x1[j + igap];
		x1[j + igap] = temp;
		if (*apply) {
		    temp = x2[j];
		    x2[j] = x2[j + igap];
		    x2[j + igap] = temp;
		}
	    } else {
		goto L60;
	    }
	    j -= igap;
	    goto L50;
L60:
	    ;
	}
	igap /= 2;
	goto L40;

    } else if (s_cmp(which, "LA", (ftnlen)2, (ftnlen)2) == 0) {

/*        X1 is sorted into increasing order of algebraic. */

L70:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L80:

	    if (j < 0) {
		goto L90;
	    }

	    if (x1[j] > x1[j + igap]) {
		temp = x1[j];
		x1[j] = x1[j + igap];
		x1[j + igap] = temp;
		if (*apply) {
		    temp = x2[j];
		    x2[j] = x2[j + igap];
		    x2[j + igap] = temp;
		}
	    } else {
		goto L90;
	    }
	    j -= igap;
	    goto L80;
L90:
	    ;
	}
	igap /= 2;
	goto L70;

    } else if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0) {

/*        X1 is sorted into increasing order of magnitude. */

L100:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L110:

	    if (j < 0) {
		goto L120;
	    }

	    if ((d__1 = x1[j], abs(d__1)) > (d__2 = x1[j + igap], abs(d__2))) 
		    {
		temp = x1[j];
		x1[j] = x1[j + igap];
		x1[j + igap] = temp;
		if (*apply) {
		    temp = x2[j];
		    x2[j] = x2[j + igap];
		    x2[j + igap] = temp;
		}
	    } else {
		goto L120;
	    }
	    j -= igap;
	    goto L110;
L120:
	    ;
	}
	igap /= 2;
	goto L100;
    }

L9000:
    return 0;

/*     %---------------%   
       | End of dsortr |   
       %---------------% */

} /* igraphdsortr_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dsortc   

   \Description:   
    Sorts the complex array in XREAL and XIMAG into the order   
    specified by WHICH and optionally applies the permutation to the   
    real array Y. It is assumed that if an element of XIMAG is   
    nonzero, then its negative is also an element. In other words,   
    both members of a complex conjugate pair are to be sorted and the   
    pairs are kept adjacent to each other.   

   \Usage:   
    call dsortc   
       ( WHICH, APPLY, N, XREAL, XIMAG, Y )   

   \Arguments   
    WHICH   Character*2.  (Input)   
            'LM' -> sort XREAL,XIMAG into increasing order of magnitude.   
            'SM' -> sort XREAL,XIMAG into decreasing order of magnitude.   
            'LR' -> sort XREAL into increasing order of algebraic.   
            'SR' -> sort XREAL into decreasing order of algebraic.   
            'LI' -> sort XIMAG into increasing order of magnitude.   
            'SI' -> sort XIMAG into decreasing order of magnitude.   
            NOTE: If an element of XIMAG is non-zero, then its negative   
                  is also an element.   

    APPLY   Logical.  (Input)   
            APPLY = .TRUE.  -> apply the sorted order to array Y.   
            APPLY = .FALSE. -> do not apply the sorted order to array Y.   

    N       Integer.  (INPUT)   
            Size of the arrays.   

    XREAL,  Double precision array of length N.  (INPUT/OUTPUT)   
    XIMAG   Real and imaginary part of the array to be sorted.   

    Y       Double precision array of length N.  (INPUT/OUTPUT)   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       xx/xx/92: Version ' 2.1'   
                 Adapted from the sort routine in LANSO.   

   \SCCS Information: @(#)   
   FILE: sortc.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdsortc_(char *which, logical *apply, integer *n, 
	doublereal *xreal, doublereal *ximag, doublereal *y)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    integer i__, j, igap;
    doublereal temp, temp1, temp2;
    extern doublereal igraphdlapy2_(doublereal *, doublereal *);


/*     %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------% */

    igap = *n / 2;

    if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0) {

/*        %------------------------------------------------------%   
          | Sort XREAL,XIMAG into increasing order of magnitude. |   
          %------------------------------------------------------% */

L10:
	if (igap == 0) {
	    goto L9000;
	}

	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L20:

	    if (j < 0) {
		goto L30;
	    }

	    temp1 = igraphdlapy2_(&xreal[j], &ximag[j]);
	    temp2 = igraphdlapy2_(&xreal[j + igap], &ximag[j + igap]);

	    if (temp1 > temp2) {
		temp = xreal[j];
		xreal[j] = xreal[j + igap];
		xreal[j + igap] = temp;

		temp = ximag[j];
		ximag[j] = ximag[j + igap];
		ximag[j + igap] = temp;

		if (*apply) {
		    temp = y[j];
		    y[j] = y[j + igap];
		    y[j + igap] = temp;
		}
	    } else {
		goto L30;
	    }
	    j -= igap;
	    goto L20;
L30:
	    ;
	}
	igap /= 2;
	goto L10;

    } else if (s_cmp(which, "SM", (ftnlen)2, (ftnlen)2) == 0) {

/*        %------------------------------------------------------%   
          | Sort XREAL,XIMAG into decreasing order of magnitude. |   
          %------------------------------------------------------% */

L40:
	if (igap == 0) {
	    goto L9000;
	}

	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L50:

	    if (j < 0) {
		goto L60;
	    }

	    temp1 = igraphdlapy2_(&xreal[j], &ximag[j]);
	    temp2 = igraphdlapy2_(&xreal[j + igap], &ximag[j + igap]);

	    if (temp1 < temp2) {
		temp = xreal[j];
		xreal[j] = xreal[j + igap];
		xreal[j + igap] = temp;

		temp = ximag[j];
		ximag[j] = ximag[j + igap];
		ximag[j + igap] = temp;

		if (*apply) {
		    temp = y[j];
		    y[j] = y[j + igap];
		    y[j + igap] = temp;
		}
	    } else {
		goto L60;
	    }
	    j -= igap;
	    goto L50;
L60:
	    ;
	}
	igap /= 2;
	goto L40;

    } else if (s_cmp(which, "LR", (ftnlen)2, (ftnlen)2) == 0) {

/*        %------------------------------------------------%   
          | Sort XREAL into increasing order of algebraic. |   
          %------------------------------------------------% */

L70:
	if (igap == 0) {
	    goto L9000;
	}

	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L80:

	    if (j < 0) {
		goto L90;
	    }

	    if (xreal[j] > xreal[j + igap]) {
		temp = xreal[j];
		xreal[j] = xreal[j + igap];
		xreal[j + igap] = temp;

		temp = ximag[j];
		ximag[j] = ximag[j + igap];
		ximag[j + igap] = temp;

		if (*apply) {
		    temp = y[j];
		    y[j] = y[j + igap];
		    y[j + igap] = temp;
		}
	    } else {
		goto L90;
	    }
	    j -= igap;
	    goto L80;
L90:
	    ;
	}
	igap /= 2;
	goto L70;

    } else if (s_cmp(which, "SR", (ftnlen)2, (ftnlen)2) == 0) {

/*        %------------------------------------------------%   
          | Sort XREAL into decreasing order of algebraic. |   
          %------------------------------------------------% */

L100:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L110:

	    if (j < 0) {
		goto L120;
	    }

	    if (xreal[j] < xreal[j + igap]) {
		temp = xreal[j];
		xreal[j] = xreal[j + igap];
		xreal[j + igap] = temp;

		temp = ximag[j];
		ximag[j] = ximag[j + igap];
		ximag[j + igap] = temp;

		if (*apply) {
		    temp = y[j];
		    y[j] = y[j + igap];
		    y[j + igap] = temp;
		}
	    } else {
		goto L120;
	    }
	    j -= igap;
	    goto L110;
L120:
	    ;
	}
	igap /= 2;
	goto L100;

    } else if (s_cmp(which, "LI", (ftnlen)2, (ftnlen)2) == 0) {

/*        %------------------------------------------------%   
          | Sort XIMAG into increasing order of magnitude. |   
          %------------------------------------------------% */

L130:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L140:

	    if (j < 0) {
		goto L150;
	    }

	    if ((d__1 = ximag[j], abs(d__1)) > (d__2 = ximag[j + igap], abs(
		    d__2))) {
		temp = xreal[j];
		xreal[j] = xreal[j + igap];
		xreal[j + igap] = temp;

		temp = ximag[j];
		ximag[j] = ximag[j + igap];
		ximag[j + igap] = temp;

		if (*apply) {
		    temp = y[j];
		    y[j] = y[j + igap];
		    y[j + igap] = temp;
		}
	    } else {
		goto L150;
	    }
	    j -= igap;
	    goto L140;
L150:
	    ;
	}
	igap /= 2;
	goto L130;

    } else if (s_cmp(which, "SI", (ftnlen)2, (ftnlen)2) == 0) {

/*        %------------------------------------------------%   
          | Sort XIMAG into decreasing order of magnitude. |   
          %------------------------------------------------% */

L160:
	if (igap == 0) {
	    goto L9000;
	}
	i__1 = *n - 1;
	for (i__ = igap; i__ <= i__1; ++i__) {
	    j = i__ - igap;
L170:

	    if (j < 0) {
		goto L180;
	    }

	    if ((d__1 = ximag[j], abs(d__1)) < (d__2 = ximag[j + igap], abs(
		    d__2))) {
		temp = xreal[j];
		xreal[j] = xreal[j + igap];
		xreal[j + igap] = temp;

		temp = ximag[j];
		ximag[j] = ximag[j + igap];
		ximag[j + igap] = temp;

		if (*apply) {
		    temp = y[j];
		    y[j] = y[j + igap];
		    y[j + igap] = temp;
		}
	    } else {
		goto L180;
	    }
	    j -= igap;
	    goto L170;
L180:
	    ;
	}
	igap /= 2;
	goto L160;
    }

L9000:
    return 0;

/*     %---------------%   
       | End of dsortc |   
       %---------------% */

} /* igraphdsortc_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer dgeev__c__1 = 1;
static doublereal dgeev__c_b24 = 1.;
static doublereal dgeev__c_b26 = 0.;
static doublereal dgeev__c_b29 = -1.;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dgetv0   

   \Description:   
    Generate a random initial residual vector for the Arnoldi process.   
    Force the residual vector to be in the range of the operator OP.   

   \Usage:   
    call dgetv0   
       ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM,   
         IPNTR, WORKD, IERR )   

   \Arguments   
    IDO     Integer.  (INPUT/OUTPUT)   
            Reverse communication flag.  IDO must be zero on the first   
            call to dgetv0.   
            -------------------------------------------------------------   
            IDO =  0: first call to the reverse communication interface   
            IDO = -1: compute  Y = OP * X  where   
                      IPNTR(1) is the pointer into WORKD for X,   
                      IPNTR(2) is the pointer into WORKD for Y.   
                      This is for the initialization phase to force the   
                      starting vector into the range of OP.   
            IDO =  2: compute  Y = B * X  where   
                      IPNTR(1) is the pointer into WORKD for X,   
                      IPNTR(2) is the pointer into WORKD for Y.   
            IDO = 99: done   
            -------------------------------------------------------------   

    BMAT    Character*1.  (INPUT)   
            BMAT specifies the type of the matrix B in the (generalized)   
            eigenvalue problem A*x = lambda*B*x.   
            B = 'I' -> standard eigenvalue problem A*x = lambda*x   
            B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x   

    ITRY    Integer.  (INPUT)   
            ITRY counts the number of times that dgetv0 is called.   
            It should be set to 1 on the initial call to dgetv0.   

    INITV   Logical variable.  (INPUT)   
            .TRUE.  => the initial residual vector is given in RESID.   
            .FALSE. => generate a random initial residual vector.   

    N       Integer.  (INPUT)   
            Dimension of the problem.   

    J       Integer.  (INPUT)   
            Index of the residual vector to be generated, with respect to   
            the Arnoldi process.  J > 1 in case of a "restart".   

    V       Double precision N by J array.  (INPUT)   
            The first J-1 columns of V contain the current Arnoldi basis   
            if this is a "restart".   

    LDV     Integer.  (INPUT)   
            Leading dimension of V exactly as declared in the calling   
            program.   

    RESID   Double precision array of length N.  (INPUT/OUTPUT)   
            Initial residual vector to be generated.  If RESID is   
            provided, force RESID into the range of the operator OP.   

    RNORM   Double precision scalar.  (OUTPUT)   
            B-norm of the generated residual.   

    IPNTR   Integer array of length 3.  (OUTPUT)   

    WORKD   Double precision work array of length 2*N.  (REVERSE COMMUNICATION).   
            On exit, WORK(1:N) = B*RESID to be used in SSAITR.   

    IERR    Integer.  (OUTPUT)   
            =  0: Normal exit.   
            = -1: Cannot generate a nontrivial restarted residual vector   
                  in the range of the operator OP.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \References:   
    1. D.C. Sorensen, "Implicit Application of Polynomial Filters in   
       a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),   
       pp 357-385.   
    2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly   
       Restarted Arnoldi Iteration", Rice University Technical Report   
       TR95-13, Department of Computational and Applied Mathematics.   

   \Routines called:   
       second  ARPACK utility routine for timing.   
       dvout   ARPACK utility routine for vector output.   
       dlarnv  LAPACK routine for generating a random vector.   
       dgemv   Level 2 BLAS routine for matrix vector multiplication.   
       dcopy   Level 1 BLAS that copies one vector to another.   
       ddot    Level 1 BLAS that computes the scalar product of two vectors.   
       dnrm2   Level 1 BLAS that computes the norm of a vector.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \SCCS Information: @(#)   
   FILE: getv0.F   SID: 2.6   DATE OF SID: 8/27/96   RELEASE: 2   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdgetv0_(integer *ido, char *bmat, integer *itry, logical 
	*initv, integer *n, integer *j, doublereal *v, integer *ldv, 
	doublereal *resid, doublereal *rnorm, integer *ipntr, doublereal *
	workd, integer *ierr)
{
    /* Initialized data */

    IGRAPH_F77_SAVE logical inits = TRUE_;

    /* System generated locals */
    integer v_dim1, v_offset, i__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    real t0, t1, t2, t3;
    integer jj, nbx = 0;
    extern doublereal igraphddot_(integer *, doublereal *, integer *, doublereal *, 
	    integer *);
    IGRAPH_F77_SAVE integer iter;
    IGRAPH_F77_SAVE logical orth;
    integer nopx = 0;
    extern doublereal igraphdnrm2_(integer *, doublereal *, integer *);
    IGRAPH_F77_SAVE integer iseed[4];
    extern /* Subroutine */ int igraphdgemv_(char *, integer *, integer *, 
	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
	    doublereal *, doublereal *, integer *);
    integer idist;
    extern /* Subroutine */ int igraphdcopy_(integer *, doublereal *, integer *, 
	    doublereal *, integer *);
    IGRAPH_F77_SAVE logical first;
    real tmvbx = 0;
    extern /* Subroutine */ int igraphdvout_(integer *, integer *, doublereal *, 
	    integer *, char *, ftnlen);
    integer mgetv0 = 0;
    real tgetv0 = 0;
    IGRAPH_F77_SAVE doublereal rnorm0;
    extern /* Subroutine */ int igraphsecond_(real *);
    integer logfil, ndigit;
    extern /* Subroutine */ int igraphdlarnv_(integer *, integer *, integer *, 
	    doublereal *);
    IGRAPH_F77_SAVE integer msglvl;
    real tmvopx = 0;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %------------------------%   
       | Local Scalars & Arrays |   
       %------------------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %---------------------%   
       | Intrinsic Functions |   
       %---------------------%   


       %-----------------%   
       | Data Statements |   
       %-----------------%   

       Parameter adjustments */
    --workd;
    --resid;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    --ipntr;

    /* Function Body   

       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   


       %-----------------------------------%   
       | Initialize the seed of the LAPACK |   
       | random number generator           |   
       %-----------------------------------% */

    if (inits) {
	iseed[0] = 1;
	iseed[1] = 3;
	iseed[2] = 5;
	iseed[3] = 7;
	inits = FALSE_;
    }

    if (*ido == 0) {

/*        %-------------------------------%   
          | Initialize timing statistics  |   
          | & message level for debugging |   
          %-------------------------------% */

	igraphsecond_(&t0);
	msglvl = mgetv0;

	*ierr = 0;
	iter = 0;
	first = FALSE_;
	orth = FALSE_;

/*        %-----------------------------------------------------%   
          | Possibly generate a random starting vector in RESID |   
          | Use a LAPACK random number generator used by the    |   
          | matrix generation routines.                         |   
          |    idist = 1: uniform (0,1)  distribution;          |   
          |    idist = 2: uniform (-1,1) distribution;          |   
          |    idist = 3: normal  (0,1)  distribution;          |   
          %-----------------------------------------------------% */

	if (! (*initv)) {
	    idist = 2;
	    igraphdlarnv_(&idist, iseed, n, &resid[1]);
	}

/*        %----------------------------------------------------------%   
          | Force the starting vector into the range of OP to handle |   
          | the generalized problem when B is possibly (singular).   |   
          %----------------------------------------------------------% */

	igraphsecond_(&t2);
	if (*(unsigned char *)bmat == 'G') {
	    ++nopx;
	    ipntr[1] = 1;
	    ipntr[2] = *n + 1;
	    igraphdcopy_(n, &resid[1], &dgeev__c__1, &workd[1], &dgeev__c__1);
	    *ido = -1;
	    goto L9000;
	}
    }

/*     %-----------------------------------------%   
       | Back from computing OP*(initial-vector) |   
       %-----------------------------------------% */

    if (first) {
	goto L20;
    }

/*     %-----------------------------------------------%   
       | Back from computing B*(orthogonalized-vector) |   
       %-----------------------------------------------% */

    if (orth) {
	goto L40;
    }

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvopx += t3 - t2;
    }

/*     %------------------------------------------------------%   
       | Starting vector is now in the range of OP; r = OP*r; |   
       | Compute B-norm of starting vector.                   |   
       %------------------------------------------------------% */

    igraphsecond_(&t2);
    first = TRUE_;
    if (*(unsigned char *)bmat == 'G') {
	++nbx;
	igraphdcopy_(n, &workd[*n + 1], &dgeev__c__1, &resid[1], &dgeev__c__1);
	ipntr[1] = *n + 1;
	ipntr[2] = 1;
	*ido = 2;
	goto L9000;
    } else if (*(unsigned char *)bmat == 'I') {
	igraphdcopy_(n, &resid[1], &dgeev__c__1, &workd[1], &dgeev__c__1);
    }

L20:

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvbx += t3 - t2;
    }

    first = FALSE_;
    if (*(unsigned char *)bmat == 'G') {
	rnorm0 = igraphddot_(n, &resid[1], &dgeev__c__1, &workd[1], &dgeev__c__1);
	rnorm0 = sqrt((abs(rnorm0)));
    } else if (*(unsigned char *)bmat == 'I') {
	rnorm0 = igraphdnrm2_(n, &resid[1], &dgeev__c__1);
    }
    *rnorm = rnorm0;

/*     %---------------------------------------------%   
       | Exit if this is the very first Arnoldi step |   
       %---------------------------------------------% */

    if (*j == 1) {
	goto L50;
    }

/*     %----------------------------------------------------------------   
       | Otherwise need to B-orthogonalize the starting vector against |   
       | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |   
       | This is the case where an invariant subspace is encountered   |   
       | in the middle of the Arnoldi factorization.                   |   
       |                                                               |   
       |       s = V^{T}*B*r;   r = r - V*s;                           |   
       |                                                               |   
       | Stopping criteria used for iter. ref. is discussed in         |   
       | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |   
       %---------------------------------------------------------------% */

    orth = TRUE_;
L30:

    i__1 = *j - 1;
    igraphdgemv_("T", n, &i__1, &dgeev__c_b24, &v[v_offset], ldv, &workd[1], &dgeev__c__1, &dgeev__c_b26,
	     &workd[*n + 1], &dgeev__c__1);
    i__1 = *j - 1;
    igraphdgemv_("N", n, &i__1, &dgeev__c_b29, &v[v_offset], ldv, &workd[*n + 1], &dgeev__c__1, &
	    dgeev__c_b24, &resid[1], &dgeev__c__1);

/*     %----------------------------------------------------------%   
       | Compute the B-norm of the orthogonalized starting vector |   
       %----------------------------------------------------------% */

    igraphsecond_(&t2);
    if (*(unsigned char *)bmat == 'G') {
	++nbx;
	igraphdcopy_(n, &resid[1], &dgeev__c__1, &workd[*n + 1], &dgeev__c__1);
	ipntr[1] = *n + 1;
	ipntr[2] = 1;
	*ido = 2;
	goto L9000;
    } else if (*(unsigned char *)bmat == 'I') {
	igraphdcopy_(n, &resid[1], &dgeev__c__1, &workd[1], &dgeev__c__1);
    }

L40:

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvbx += t3 - t2;
    }

    if (*(unsigned char *)bmat == 'G') {
	*rnorm = igraphddot_(n, &resid[1], &dgeev__c__1, &workd[1], &dgeev__c__1);
	*rnorm = sqrt((abs(*rnorm)));
    } else if (*(unsigned char *)bmat == 'I') {
	*rnorm = igraphdnrm2_(n, &resid[1], &dgeev__c__1);
    }

/*     %--------------------------------------%   
       | Check for further orthogonalization. |   
       %--------------------------------------% */

    if (msglvl > 2) {
	igraphdvout_(&logfil, &dgeev__c__1, &rnorm0, &ndigit, "_getv0: re-orthonalization"
		" ; rnorm0 is", (ftnlen)38);
	igraphdvout_(&logfil, &dgeev__c__1, rnorm, &ndigit, "_getv0: re-orthonalization ;"
		" rnorm is", (ftnlen)37);
    }

    if (*rnorm > rnorm0 * .717f) {
	goto L50;
    }

    ++iter;
    if (iter <= 1) {

/*        %-----------------------------------%   
          | Perform iterative refinement step |   
          %-----------------------------------% */

	rnorm0 = *rnorm;
	goto L30;
    } else {

/*        %------------------------------------%   
          | Iterative refinement step "failed" |   
          %------------------------------------% */

	i__1 = *n;
	for (jj = 1; jj <= i__1; ++jj) {
	    resid[jj] = 0.;
/* L45: */
	}
	*rnorm = 0.;
	*ierr = -1;
    }

L50:

    if (msglvl > 0) {
	igraphdvout_(&logfil, &dgeev__c__1, rnorm, &ndigit, "_getv0: B-norm of initial / "
		"restarted starting vector", (ftnlen)53);
    }
    if (msglvl > 2) {
	igraphdvout_(&logfil, n, &resid[1], &ndigit, "_getv0: initial / restarted "
		"starting vector", (ftnlen)43);
    }
    *ido = 99;

    igraphsecond_(&t1);
    tgetv0 += t1 - t0;

L9000:
    return 0;

/*     %---------------%   
       | End of dgetv0 |   
       %---------------% */

} /* igraphdgetv0_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer dgeevx__c__1 = 1;
static logical dgeevx__c_false = FALSE_;
static doublereal dgeevx__c_b24 = 1.;
static doublereal dgeevx__c_b49 = 0.;
static doublereal dgeevx__c_b57 = -1.;
static integer dgeevx__c__2 = 2;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dsaitr   

   \Description:   
    Reverse communication interface for applying NP additional steps to   
    a K step symmetric Arnoldi factorization.   

    Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T   

            with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.   

    Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T   

            with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.   

    where OP and B are as in dsaupd.  The B-norm of r_{k+p} is also   
    computed and returned.   

   \Usage:   
    call dsaitr   
       ( IDO, BMAT, N, K, NP, MODE, RESID, RNORM, V, LDV, H, LDH,   
         IPNTR, WORKD, INFO )   

   \Arguments   
    IDO     Integer.  (INPUT/OUTPUT)   
            Reverse communication flag.   
            -------------------------------------------------------------   
            IDO =  0: first call to the reverse communication interface   
            IDO = -1: compute  Y = OP * X  where   
                      IPNTR(1) is the pointer into WORK for X,   
                      IPNTR(2) is the pointer into WORK for Y.   
                      This is for the restart phase to force the new   
                      starting vector into the range of OP.   
            IDO =  1: compute  Y = OP * X  where   
                      IPNTR(1) is the pointer into WORK for X,   
                      IPNTR(2) is the pointer into WORK for Y,   
                      IPNTR(3) is the pointer into WORK for B * X.   
            IDO =  2: compute  Y = B * X  where   
                      IPNTR(1) is the pointer into WORK for X,   
                      IPNTR(2) is the pointer into WORK for Y.   
            IDO = 99: done   
            -------------------------------------------------------------   
            When the routine is used in the "shift-and-invert" mode, the   
            vector B * Q is already available and does not need to be   
            recomputed in forming OP * Q.   

    BMAT    Character*1.  (INPUT)   
            BMAT specifies the type of matrix B that defines the   
            semi-inner product for the operator OP.  See dsaupd.   
            B = 'I' -> standard eigenvalue problem A*x = lambda*x   
            B = 'G' -> generalized eigenvalue problem A*x = lambda*M*x   

    N       Integer.  (INPUT)   
            Dimension of the eigenproblem.   

    K       Integer.  (INPUT)   
            Current order of H and the number of columns of V.   

    NP      Integer.  (INPUT)   
            Number of additional Arnoldi steps to take.   

    MODE    Integer.  (INPUT)   
            Signifies which form for "OP". If MODE=2 then   
            a reduction in the number of B matrix vector multiplies   
            is possible since the B-norm of OP*x is equivalent to   
            the inv(B)-norm of A*x.   

    RESID   Double precision array of length N.  (INPUT/OUTPUT)   
            On INPUT:  RESID contains the residual vector r_{k}.   
            On OUTPUT: RESID contains the residual vector r_{k+p}.   

    RNORM   Double precision scalar.  (INPUT/OUTPUT)   
            On INPUT the B-norm of r_{k}.   
            On OUTPUT the B-norm of the updated residual r_{k+p}.   

    V       Double precision N by K+NP array.  (INPUT/OUTPUT)   
            On INPUT:  V contains the Arnoldi vectors in the first K   
            columns.   
            On OUTPUT: V contains the new NP Arnoldi vectors in the next   
            NP columns.  The first K columns are unchanged.   

    LDV     Integer.  (INPUT)   
            Leading dimension of V exactly as declared in the calling   
            program.   

    H       Double precision (K+NP) by 2 array.  (INPUT/OUTPUT)   
            H is used to store the generated symmetric tridiagonal matrix   
            with the subdiagonal in the first column starting at H(2,1)   
            and the main diagonal in the second column.   

    LDH     Integer.  (INPUT)   
            Leading dimension of H exactly as declared in the calling   
            program.   

    IPNTR   Integer array of length 3.  (OUTPUT)   
            Pointer to mark the starting locations in the WORK for   
            vectors used by the Arnoldi iteration.   
            -------------------------------------------------------------   
            IPNTR(1): pointer to the current operand vector X.   
            IPNTR(2): pointer to the current result vector Y.   
            IPNTR(3): pointer to the vector B * X when used in the   
                      shift-and-invert mode.  X is the current operand.   
            -------------------------------------------------------------   

    WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)   
            Distributed array to be used in the basic Arnoldi iteration   
            for reverse communication.  The calling program should not   
            use WORKD as temporary workspace during the iteration !!!!!!   
            On INPUT, WORKD(1:N) = B*RESID where RESID is associated   
            with the K step Arnoldi factorization. Used to save some   
            computation at the first step.   
            On OUTPUT, WORKD(1:N) = B*RESID where RESID is associated   
            with the K+NP step Arnoldi factorization.   

    INFO    Integer.  (OUTPUT)   
            = 0: Normal exit.   
            > 0: Size of an invariant subspace of OP is found that is   
                 less than K + NP.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \Routines called:   
       dgetv0  ARPACK routine to generate the initial vector.   
       ivout   ARPACK utility routine that prints integers.   
       dmout   ARPACK utility routine that prints matrices.   
       dvout   ARPACK utility routine that prints vectors.   
       dlamch  LAPACK routine that determines machine constants.   
       dlascl  LAPACK routine for careful scaling of a matrix.   
       dgemv   Level 2 BLAS routine for matrix vector multiplication.   
       daxpy   Level 1 BLAS that computes a vector triad.   
       dscal   Level 1 BLAS that scales a vector.   
       dcopy   Level 1 BLAS that copies one vector to another .   
       ddot    Level 1 BLAS that computes the scalar product of two vectors.   
       dnrm2   Level 1 BLAS that computes the norm of a vector.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       xx/xx/93: Version ' 2.4'   

   \SCCS Information: @(#)   
   FILE: saitr.F   SID: 2.6   DATE OF SID: 8/28/96   RELEASE: 2   

   \Remarks   
    The algorithm implemented is:   

    restart = .false.   
    Given V_{k} = [v_{1}, ..., v_{k}], r_{k};   
    r_{k} contains the initial residual vector even for k = 0;   
    Also assume that rnorm = || B*r_{k} || and B*r_{k} are already   
    computed by the calling program.   

    betaj = rnorm ; p_{k+1} = B*r_{k} ;   
    For  j = k+1, ..., k+np  Do   
       1) if ( betaj < tol ) stop or restart depending on j.   
          if ( restart ) generate a new starting vector.   
       2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];   
          p_{j} = p_{j}/betaj   
       3) r_{j} = OP*v_{j} where OP is defined as in dsaupd   
          For shift-invert mode p_{j} = B*v_{j} is already available.   
          wnorm = || OP*v_{j} ||   
       4) Compute the j-th step residual vector.   
          w_{j} =  V_{j}^T * B * OP * v_{j}   
          r_{j} =  OP*v_{j} - V_{j} * w_{j}   
          alphaj <- j-th component of w_{j}   
          rnorm = || r_{j} ||   
          betaj+1 = rnorm   
          If (rnorm > 0.717*wnorm) accept step and go back to 1)   
       5) Re-orthogonalization step:   
          s = V_{j}'*B*r_{j}   
          r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||   
          alphaj = alphaj + s_{j};   
       6) Iterative refinement step:   
          If (rnorm1 > 0.717*rnorm) then   
             rnorm = rnorm1   
             accept step and go back to 1)   
          Else   
             rnorm = rnorm1   
             If this is the first time in step 6), go to 5)   
             Else r_{j} lies in the span of V_{j} numerically.   
                Set r_{j} = 0 and rnorm = 0; go to 1)   
          EndIf   
    End Do   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdsaitr_(integer *ido, char *bmat, integer *n, integer *k,
	 integer *np, integer *mode, doublereal *resid, doublereal *rnorm, 
	doublereal *v, integer *ldv, doublereal *h__, integer *ldh, integer *
	ipntr, doublereal *workd, integer *info)
{
    /* Initialized data */

    IGRAPH_F77_SAVE logical first = TRUE_;

    /* System generated locals */
    integer h_dim1, h_offset, v_dim1, v_offset, i__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    integer i__;
    IGRAPH_F77_SAVE integer j;
    real t0, t1, t2 = 0.0, t3, t4, t5;
    integer jj;
    IGRAPH_F77_SAVE integer ipj, irj;
    integer nbx = 0;
    IGRAPH_F77_SAVE integer ivj;
    extern doublereal igraphddot_(integer *, doublereal *, integer *, doublereal *, 
	    integer *);
    IGRAPH_F77_SAVE integer ierr, iter;
    integer nopx = 0;
    IGRAPH_F77_SAVE integer itry;
    extern doublereal igraphdnrm2_(integer *, doublereal *, integer *);
    doublereal temp1;
    IGRAPH_F77_SAVE logical orth1, orth2, step3, step4;
    extern /* Subroutine */ int igraphdscal_(integer *, doublereal *, doublereal *, 
	    integer *), igraphdgemv_(char *, integer *, integer *, doublereal *, 
	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
	    doublereal *, integer *);
    integer infol;
    extern /* Subroutine */ int igraphdcopy_(integer *, doublereal *, integer *, 
	    doublereal *, integer *);
    doublereal xtemp[2];
    real tmvbx = 0;
    extern /* Subroutine */ int igraphdvout_(integer *, integer *, doublereal *, 
	    integer *, char *, ftnlen);
    IGRAPH_F77_SAVE doublereal wnorm;
    extern /* Subroutine */ int igraphivout_(integer *, integer *, integer *, 
	    integer *, char *, ftnlen), igraphdgetv0_(integer *, char *, integer *, 
	    logical *, integer *, integer *, doublereal *, integer *, 
	    doublereal *, doublereal *, integer *, doublereal *, integer *);
    IGRAPH_F77_SAVE doublereal rnorm1;
    extern doublereal igraphdlamch_(char *);
    extern /* Subroutine */ int igraphdlascl_(char *, integer *, integer *, 
	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
	    integer *, integer *), igraphsecond_(real *);
    integer logfil;
    IGRAPH_F77_SAVE doublereal safmin;
    integer ndigit = 0, nitref = 0;
    real titref = 0;
    integer msaitr = 0;
    IGRAPH_F77_SAVE integer msglvl;
    real tsaitr = 0;
    integer nrorth = 0;
    IGRAPH_F77_SAVE logical rstart;
    integer nrstrt = 0;
    real tmvopx = 0;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %-----------------------%   
       | Local Array Arguments |   
       %-----------------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %-----------------%   
       | Data statements |   
       %-----------------%   

       Parameter adjustments */
    --workd;
    --resid;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --ipntr;

    /* Function Body   

       %-----------------------%   
       | Executable Statements |   
       %-----------------------% */

    if (first) {
	first = FALSE_;

/*        %--------------------------------%   
          | safmin = safe minimum is such  |   
          | that 1/sfmin does not overflow |   
          %--------------------------------% */

	safmin = igraphdlamch_("safmin");
    }

    if (*ido == 0) {

/*        %-------------------------------%   
          | Initialize timing statistics  |   
          | & message level for debugging |   
          %-------------------------------% */

	igraphsecond_(&t0);
	msglvl = msaitr;

/*        %------------------------------%   
          | Initial call to this routine |   
          %------------------------------% */

	*info = 0;
	step3 = FALSE_;
	step4 = FALSE_;
	rstart = FALSE_;
	orth1 = FALSE_;
	orth2 = FALSE_;

/*        %--------------------------------%   
          | Pointer to the current step of |   
          | the factorization to build     |   
          %--------------------------------% */

	j = *k + 1;

/*        %------------------------------------------%   
          | Pointers used for reverse communication  |   
          | when using WORKD.                        |   
          %------------------------------------------% */

	ipj = 1;
	irj = ipj + *n;
	ivj = irj + *n;
    }

/*     %-------------------------------------------------%   
       | When in reverse communication mode one of:      |   
       | STEP3, STEP4, ORTH1, ORTH2, RSTART              |   
       | will be .true.                                  |   
       | STEP3: return from computing OP*v_{j}.          |   
       | STEP4: return from computing B-norm of OP*v_{j} |   
       | ORTH1: return from computing B-norm of r_{j+1}  |   
       | ORTH2: return from computing B-norm of          |   
       |        correction to the residual vector.       |   
       | RSTART: return from OP computations needed by   |   
       |         dgetv0.                                 |   
       %-------------------------------------------------% */

    if (step3) {
	goto L50;
    }
    if (step4) {
	goto L60;
    }
    if (orth1) {
	goto L70;
    }
    if (orth2) {
	goto L90;
    }
    if (rstart) {
	goto L30;
    }

/*     %------------------------------%   
       | Else this is the first step. |   
       %------------------------------%   

       %--------------------------------------------------------------%   
       |                                                              |   
       |        A R N O L D I     I T E R A T I O N     L O O P       |   
       |                                                              |   
       | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |   
       %--------------------------------------------------------------% */

L1000:

    if (msglvl > 2) {
	igraphivout_(&logfil, &dgeevx__c__1, &j, &ndigit, "_saitr: generating Arnoldi vect"
		"or no.", (ftnlen)37);
	igraphdvout_(&logfil, &dgeevx__c__1, rnorm, &ndigit, "_saitr: B-norm of the curren"
		"t residual =", (ftnlen)40);
    }

/*        %---------------------------------------------------------%   
          | Check for exact zero. Equivalent to determing whether a |   
          | j-step Arnoldi factorization is present.                |   
          %---------------------------------------------------------% */

    if (*rnorm > 0.) {
	goto L40;
    }

/*           %---------------------------------------------------%   
             | Invariant subspace found, generate a new starting |   
             | vector which is orthogonal to the current Arnoldi |   
             | basis and continue the iteration.                 |   
             %---------------------------------------------------% */

    if (msglvl > 0) {
	igraphivout_(&logfil, &dgeevx__c__1, &j, &ndigit, "_saitr: ****** restart at step "
		"******", (ftnlen)37);
    }

/*           %---------------------------------------------%   
             | ITRY is the loop variable that controls the |   
             | maximum amount of times that a restart is   |   
             | attempted. NRSTRT is used by stat.h         |   
             %---------------------------------------------% */

    ++nrstrt;
    itry = 1;
L20:
    rstart = TRUE_;
    *ido = 0;
L30:

/*           %--------------------------------------%   
             | If in reverse communication mode and |   
             | RSTART = .true. flow returns here.   |   
             %--------------------------------------% */

    igraphdgetv0_(ido, bmat, &itry, &dgeevx__c_false, n, &j, &v[v_offset], ldv, &resid[1], 
	    rnorm, &ipntr[1], &workd[1], &ierr);
    if (*ido != 99) {
	goto L9000;
    }
    if (ierr < 0) {
	++itry;
	if (itry <= 3) {
	    goto L20;
	}

/*              %------------------------------------------------%   
                | Give up after several restart attempts.        |   
                | Set INFO to the size of the invariant subspace |   
                | which spans OP and exit.                       |   
                %------------------------------------------------% */

	*info = j - 1;
	igraphsecond_(&t1);
	tsaitr += t1 - t0;
	*ido = 99;
	goto L9000;
    }

L40:

/*        %---------------------------------------------------------%   
          | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |   
          | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |   
          | when reciprocating a small RNORM, test against lower    |   
          | machine bound.                                          |   
          %---------------------------------------------------------% */

    igraphdcopy_(n, &resid[1], &dgeevx__c__1, &v[j * v_dim1 + 1], &dgeevx__c__1);
    if (*rnorm >= safmin) {
	temp1 = 1. / *rnorm;
	igraphdscal_(n, &temp1, &v[j * v_dim1 + 1], &dgeevx__c__1);
	igraphdscal_(n, &temp1, &workd[ipj], &dgeevx__c__1);
    } else {

/*            %-----------------------------------------%   
              | To scale both v_{j} and p_{j} carefully |   
              | use LAPACK routine SLASCL               |   
              %-----------------------------------------% */

	igraphdlascl_("General", &i__, &i__, rnorm, &dgeevx__c_b24, n, &dgeevx__c__1, &v[j * v_dim1 
		+ 1], n, &infol);
	igraphdlascl_("General", &i__, &i__, rnorm, &dgeevx__c_b24, n, &dgeevx__c__1, &workd[ipj], 
		n, &infol);
    }

/*        %------------------------------------------------------%   
          | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |   
          | Note that this is not quite yet r_{j}. See STEP 4    |   
          %------------------------------------------------------% */

    step3 = TRUE_;
    ++nopx;
    igraphsecond_(&t2);
    igraphdcopy_(n, &v[j * v_dim1 + 1], &dgeevx__c__1, &workd[ivj], &dgeevx__c__1);
    ipntr[1] = ivj;
    ipntr[2] = irj;
    ipntr[3] = ipj;
    *ido = 1;

/*        %-----------------------------------%   
          | Exit in order to compute OP*v_{j} |   
          %-----------------------------------% */

    goto L9000;
L50:

/*        %-----------------------------------%   
          | Back from reverse communication;  |   
          | WORKD(IRJ:IRJ+N-1) := OP*v_{j}.   |   
          %-----------------------------------% */

    igraphsecond_(&t3);
    tmvopx += t3 - t2;

    step3 = FALSE_;

/*        %------------------------------------------%   
          | Put another copy of OP*v_{j} into RESID. |   
          %------------------------------------------% */

    igraphdcopy_(n, &workd[irj], &dgeevx__c__1, &resid[1], &dgeevx__c__1);

/*        %-------------------------------------------%   
          | STEP 4:  Finish extending the symmetric   |   
          |          Arnoldi to length j. If MODE = 2 |   
          |          then B*OP = B*inv(B)*A = A and   |   
          |          we don't need to compute B*OP.   |   
          | NOTE: If MODE = 2 WORKD(IVJ:IVJ+N-1) is   |   
          | assumed to have A*v_{j}.                  |   
          %-------------------------------------------% */

    if (*mode == 2) {
	goto L65;
    }
    igraphsecond_(&t2);
    if (*(unsigned char *)bmat == 'G') {
	++nbx;
	step4 = TRUE_;
	ipntr[1] = irj;
	ipntr[2] = ipj;
	*ido = 2;

/*           %-------------------------------------%   
             | Exit in order to compute B*OP*v_{j} |   
             %-------------------------------------% */

	goto L9000;
    } else if (*(unsigned char *)bmat == 'I') {
	igraphdcopy_(n, &resid[1], &dgeevx__c__1, &workd[ipj], &dgeevx__c__1);
    }
L60:

/*        %-----------------------------------%   
          | Back from reverse communication;  |   
          | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}. |   
          %-----------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvbx += t3 - t2;
    }

    step4 = FALSE_;

/*        %-------------------------------------%   
          | The following is needed for STEP 5. |   
          | Compute the B-norm of OP*v_{j}.     |   
          %-------------------------------------% */

L65:
    if (*mode == 2) {

/*           %----------------------------------%   
             | Note that the B-norm of OP*v_{j} |   
             | is the inv(B)-norm of A*v_{j}.   |   
             %----------------------------------% */

	wnorm = igraphddot_(n, &resid[1], &dgeevx__c__1, &workd[ivj], &dgeevx__c__1);
	wnorm = sqrt((abs(wnorm)));
    } else if (*(unsigned char *)bmat == 'G') {
	wnorm = igraphddot_(n, &resid[1], &dgeevx__c__1, &workd[ipj], &dgeevx__c__1);
	wnorm = sqrt((abs(wnorm)));
    } else if (*(unsigned char *)bmat == 'I') {
	wnorm = igraphdnrm2_(n, &resid[1], &dgeevx__c__1);
    }

/*        %-----------------------------------------%   
          | Compute the j-th residual corresponding |   
          | to the j step factorization.            |   
          | Use Classical Gram Schmidt and compute: |   
          | w_{j} <-  V_{j}^T * B * OP * v_{j}      |   
          | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |   
          %-----------------------------------------%   


          %------------------------------------------%   
          | Compute the j Fourier coefficients w_{j} |   
          | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |   
          %------------------------------------------% */

    if (*mode != 2) {
	igraphdgemv_("T", n, &j, &dgeevx__c_b24, &v[v_offset], ldv, &workd[ipj], &dgeevx__c__1, &
		dgeevx__c_b49, &workd[irj], &dgeevx__c__1);
    } else if (*mode == 2) {
	igraphdgemv_("T", n, &j, &dgeevx__c_b24, &v[v_offset], ldv, &workd[ivj], &dgeevx__c__1, &
		dgeevx__c_b49, &workd[irj], &dgeevx__c__1);
    }

/*        %--------------------------------------%   
          | Orthgonalize r_{j} against V_{j}.    |   
          | RESID contains OP*v_{j}. See STEP 3. |   
          %--------------------------------------% */

    igraphdgemv_("N", n, &j, &dgeevx__c_b57, &v[v_offset], ldv, &workd[irj], &dgeevx__c__1, &dgeevx__c_b24, 
	    &resid[1], &dgeevx__c__1);

/*        %--------------------------------------%   
          | Extend H to have j rows and columns. |   
          %--------------------------------------% */

    h__[j + (h_dim1 << 1)] = workd[irj + j - 1];
    if (j == 1 || rstart) {
	h__[j + h_dim1] = 0.;
    } else {
	h__[j + h_dim1] = *rnorm;
    }
    igraphsecond_(&t4);

    orth1 = TRUE_;
    iter = 0;

    igraphsecond_(&t2);
    if (*(unsigned char *)bmat == 'G') {
	++nbx;
	igraphdcopy_(n, &resid[1], &dgeevx__c__1, &workd[irj], &dgeevx__c__1);
	ipntr[1] = irj;
	ipntr[2] = ipj;
	*ido = 2;

/*           %----------------------------------%   
             | Exit in order to compute B*r_{j} |   
             %----------------------------------% */

	goto L9000;
    } else if (*(unsigned char *)bmat == 'I') {
	igraphdcopy_(n, &resid[1], &dgeevx__c__1, &workd[ipj], &dgeevx__c__1);
    }
L70:

/*        %---------------------------------------------------%   
          | Back from reverse communication if ORTH1 = .true. |   
          | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |   
          %---------------------------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvbx += t3 - t2;
    }

    orth1 = FALSE_;

/*        %------------------------------%   
          | Compute the B-norm of r_{j}. |   
          %------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	*rnorm = igraphddot_(n, &resid[1], &dgeevx__c__1, &workd[ipj], &dgeevx__c__1);
	*rnorm = sqrt((abs(*rnorm)));
    } else if (*(unsigned char *)bmat == 'I') {
	*rnorm = igraphdnrm2_(n, &resid[1], &dgeevx__c__1);
    }

/*        %-----------------------------------------------------------%   
          | STEP 5: Re-orthogonalization / Iterative refinement phase |   
          | Maximum NITER_ITREF tries.                                |   
          |                                                           |   
          |          s      = V_{j}^T * B * r_{j}                     |   
          |          r_{j}  = r_{j} - V_{j}*s                         |   
          |          alphaj = alphaj + s_{j}                          |   
          |                                                           |   
          | The stopping criteria used for iterative refinement is    |   
          | discussed in Parlett's book SEP, page 107 and in Gragg &  |   
          | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |   
          | Determine if we need to correct the residual. The goal is |   
          | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |   
          %-----------------------------------------------------------% */

    if (*rnorm > wnorm * .717f) {
	goto L100;
    }
    ++nrorth;

/*        %---------------------------------------------------%   
          | Enter the Iterative refinement phase. If further  |   
          | refinement is necessary, loop back here. The loop |   
          | variable is ITER. Perform a step of Classical     |   
          | Gram-Schmidt using all the Arnoldi vectors V_{j}  |   
          %---------------------------------------------------% */

L80:

    if (msglvl > 2) {
	xtemp[0] = wnorm;
	xtemp[1] = *rnorm;
	igraphdvout_(&logfil, &dgeevx__c__2, xtemp, &ndigit, "_saitr: re-orthonalization ;"
		" wnorm and rnorm are", (ftnlen)48);
    }

/*        %----------------------------------------------------%   
          | Compute V_{j}^T * B * r_{j}.                       |   
          | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |   
          %----------------------------------------------------% */

    igraphdgemv_("T", n, &j, &dgeevx__c_b24, &v[v_offset], ldv, &workd[ipj], &dgeevx__c__1, &dgeevx__c_b49, 
	    &workd[irj], &dgeevx__c__1);

/*        %----------------------------------------------%   
          | Compute the correction to the residual:      |   
          | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).  |   
          | The correction to H is v(:,1:J)*H(1:J,1:J) + |   
          | v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j, but only   |   
          | H(j,j) is updated.                           |   
          %----------------------------------------------% */

    igraphdgemv_("N", n, &j, &dgeevx__c_b57, &v[v_offset], ldv, &workd[irj], &dgeevx__c__1, &dgeevx__c_b24, 
	    &resid[1], &dgeevx__c__1);

    if (j == 1 || rstart) {
	h__[j + h_dim1] = 0.;
    }
    h__[j + (h_dim1 << 1)] += workd[irj + j - 1];

    orth2 = TRUE_;
    igraphsecond_(&t2);
    if (*(unsigned char *)bmat == 'G') {
	++nbx;
	igraphdcopy_(n, &resid[1], &dgeevx__c__1, &workd[irj], &dgeevx__c__1);
	ipntr[1] = irj;
	ipntr[2] = ipj;
	*ido = 2;

/*           %-----------------------------------%   
             | Exit in order to compute B*r_{j}. |   
             | r_{j} is the corrected residual.  |   
             %-----------------------------------% */

	goto L9000;
    } else if (*(unsigned char *)bmat == 'I') {
	igraphdcopy_(n, &resid[1], &dgeevx__c__1, &workd[ipj], &dgeevx__c__1);
    }
L90:

/*        %---------------------------------------------------%   
          | Back from reverse communication if ORTH2 = .true. |   
          %---------------------------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvbx += t3 - t2;
    }

/*        %-----------------------------------------------------%   
          | Compute the B-norm of the corrected residual r_{j}. |   
          %-----------------------------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	rnorm1 = igraphddot_(n, &resid[1], &dgeevx__c__1, &workd[ipj], &dgeevx__c__1);
	rnorm1 = sqrt((abs(rnorm1)));
    } else if (*(unsigned char *)bmat == 'I') {
	rnorm1 = igraphdnrm2_(n, &resid[1], &dgeevx__c__1);
    }

    if (msglvl > 0 && iter > 0) {
	igraphivout_(&logfil, &dgeevx__c__1, &j, &ndigit, "_saitr: Iterative refinement fo"
		"r Arnoldi residual", (ftnlen)49);
	if (msglvl > 2) {
	    xtemp[0] = *rnorm;
	    xtemp[1] = rnorm1;
	    igraphdvout_(&logfil, &dgeevx__c__2, xtemp, &ndigit, "_saitr: iterative refine"
		    "ment ; rnorm and rnorm1 are", (ftnlen)51);
	}
    }

/*        %-----------------------------------------%   
          | Determine if we need to perform another |   
          | step of re-orthogonalization.           |   
          %-----------------------------------------% */

    if (rnorm1 > *rnorm * .717f) {

/*           %--------------------------------%   
             | No need for further refinement |   
             %--------------------------------% */

	*rnorm = rnorm1;

    } else {

/*           %-------------------------------------------%   
             | Another step of iterative refinement step |   
             | is required. NITREF is used by stat.h     |   
             %-------------------------------------------% */

	++nitref;
	*rnorm = rnorm1;
	++iter;
	if (iter <= 1) {
	    goto L80;
	}

/*           %-------------------------------------------------%   
             | Otherwise RESID is numerically in the span of V |   
             %-------------------------------------------------% */

	i__1 = *n;
	for (jj = 1; jj <= i__1; ++jj) {
	    resid[jj] = 0.;
/* L95: */
	}
	*rnorm = 0.;
    }

/*        %----------------------------------------------%   
          | Branch here directly if iterative refinement |   
          | wasn't necessary or after at most NITER_REF  |   
          | steps of iterative refinement.               |   
          %----------------------------------------------% */

L100:

    rstart = FALSE_;
    orth2 = FALSE_;

    igraphsecond_(&t5);
    titref += t5 - t4;

/*        %----------------------------------------------------------%   
          | Make sure the last off-diagonal element is non negative  |   
          | If not perform a similarity transformation on H(1:j,1:j) |   
          | and scale v(:,j) by -1.                                  |   
          %----------------------------------------------------------% */

    if (h__[j + h_dim1] < 0.) {
	h__[j + h_dim1] = -h__[j + h_dim1];
	if (j < *k + *np) {
	    igraphdscal_(n, &dgeevx__c_b57, &v[(j + 1) * v_dim1 + 1], &dgeevx__c__1);
	} else {
	    igraphdscal_(n, &dgeevx__c_b57, &resid[1], &dgeevx__c__1);
	}
    }

/*        %------------------------------------%   
          | STEP 6: Update  j = j+1;  Continue |   
          %------------------------------------% */

    ++j;
    if (j > *k + *np) {
	igraphsecond_(&t1);
	tsaitr += t1 - t0;
	*ido = 99;

	if (msglvl > 1) {
	    i__1 = *k + *np;
	    igraphdvout_(&logfil, &i__1, &h__[(h_dim1 << 1) + 1], &ndigit, "_saitr"
		    ": main diagonal of matrix H of step K+NP.", (ftnlen)47);
	    if (*k + *np > 1) {
		i__1 = *k + *np - 1;
		igraphdvout_(&logfil, &i__1, &h__[h_dim1 + 2], &ndigit, "_saitr: s"
			"ub diagonal of matrix H of step K+NP.", (ftnlen)46);
	    }
	}

	goto L9000;
    }

/*        %--------------------------------------------------------%   
          | Loop back to extend the factorization by another step. |   
          %--------------------------------------------------------% */

    goto L1000;

/*     %---------------------------------------------------------------%   
       |                                                               |   
       |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |   
       |                                                               |   
       %---------------------------------------------------------------% */

L9000:
    return 0;

/*     %---------------%   
       | End of dsaitr |   
       %---------------% */

} /* igraphdsaitr_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static doublereal dgehd2__c_b4 = 0.;
static doublereal dgehd2__c_b5 = 1.;
static integer dgehd2__c__1 = 1;
static doublereal dgehd2__c_b20 = -1.;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dsapps   

   \Description:   
    Given the Arnoldi factorization   

       A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,   

    apply NP shifts implicitly resulting in   

       A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q   

    where Q is an orthogonal matrix of order KEV+NP. Q is the product of   
    rotations resulting from the NP bulge chasing sweeps.  The updated Arnoldi   
    factorization becomes:   

       A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.   

   \Usage:   
    call dsapps   
       ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, WORKD )   

   \Arguments   
    N       Integer.  (INPUT)   
            Problem size, i.e. dimension of matrix A.   

    KEV     Integer.  (INPUT)   
            INPUT: KEV+NP is the size of the input matrix H.   
            OUTPUT: KEV is the size of the updated matrix HNEW.   

    NP      Integer.  (INPUT)   
            Number of implicit shifts to be applied.   

    SHIFT   Double precision array of length NP.  (INPUT)   
            The shifts to be applied.   

    V       Double precision N by (KEV+NP) array.  (INPUT/OUTPUT)   
            INPUT: V contains the current KEV+NP Arnoldi vectors.   
            OUTPUT: VNEW = V(1:n,1:KEV); the updated Arnoldi vectors   
            are in the first KEV columns of V.   

    LDV     Integer.  (INPUT)   
            Leading dimension of V exactly as declared in the calling   
            program.   

    H       Double precision (KEV+NP) by 2 array.  (INPUT/OUTPUT)   
            INPUT: H contains the symmetric tridiagonal matrix of the   
            Arnoldi factorization with the subdiagonal in the 1st column   
            starting at H(2,1) and the main diagonal in the 2nd column.   
            OUTPUT: H contains the updated tridiagonal matrix in the   
            KEV leading submatrix.   

    LDH     Integer.  (INPUT)   
            Leading dimension of H exactly as declared in the calling   
            program.   

    RESID   Double precision array of length (N).  (INPUT/OUTPUT)   
            INPUT: RESID contains the the residual vector r_{k+p}.   
            OUTPUT: RESID is the updated residual vector rnew_{k}.   

    Q       Double precision KEV+NP by KEV+NP work array.  (WORKSPACE)   
            Work array used to accumulate the rotations during the bulge   
            chase sweep.   

    LDQ     Integer.  (INPUT)   
            Leading dimension of Q exactly as declared in the calling   
            program.   

    WORKD   Double precision work array of length 2*N.  (WORKSPACE)   
            Distributed array used in the application of the accumulated   
            orthogonal matrix Q.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \References:   
    1. D.C. Sorensen, "Implicit Application of Polynomial Filters in   
       a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),   
       pp 357-385.   
    2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly   
       Restarted Arnoldi Iteration", Rice University Technical Report   
       TR95-13, Department of Computational and Applied Mathematics.   

   \Routines called:   
       ivout   ARPACK utility routine that prints integers.   
       second  ARPACK utility routine for timing.   
       dvout   ARPACK utility routine that prints vectors.   
       dlamch  LAPACK routine that determines machine constants.   
       dlartg  LAPACK Givens rotation construction routine.   
       dlacpy  LAPACK matrix copy routine.   
       dlaset  LAPACK matrix initialization routine.   
       dgemv   Level 2 BLAS routine for matrix vector multiplication.   
       daxpy   Level 1 BLAS that computes a vector triad.   
       dcopy   Level 1 BLAS that copies one vector to another.   
       dscal   Level 1 BLAS that scales a vector.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       12/16/93: Version ' 2.1'   

   \SCCS Information: @(#)   
   FILE: sapps.F   SID: 2.5   DATE OF SID: 4/19/96   RELEASE: 2   

   \Remarks   
    1. In this version, each shift is applied to all the subblocks of   
       the tridiagonal matrix H and not just to the submatrix that it   
       comes from. This routine assumes that the subdiagonal elements   
       of H that are stored in h(1:kev+np,1) are nonegative upon input   
       and enforce this condition upon output. This version incorporates   
       deflation. See code for documentation.   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdsapps_(integer *n, integer *kev, integer *np, 
	doublereal *shift, doublereal *v, integer *ldv, doublereal *h__, 
	integer *ldh, doublereal *resid, doublereal *q, integer *ldq, 
	doublereal *workd)
{
    /* Initialized data */

    IGRAPH_F77_SAVE logical first = TRUE_;

    /* System generated locals */
    integer h_dim1, h_offset, q_dim1, q_offset, v_dim1, v_offset, i__1, i__2, 
	    i__3, i__4;
    doublereal d__1, d__2;

    /* Local variables */
    doublereal c__, f, g;
    integer i__, j;
    doublereal r__, s, a1, a2, a3, a4;
    real t0, t1;
    integer jj;
    doublereal big;
    integer iend, itop;
    extern /* Subroutine */ int igraphdscal_(integer *, doublereal *, doublereal *, 
	    integer *), igraphdgemv_(char *, integer *, integer *, doublereal *, 
	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
	    doublereal *, integer *), igraphdcopy_(integer *, doublereal *, 
	    integer *, doublereal *, integer *), igraphdvout_(
	    integer *, integer *, doublereal *, integer *, char *, ftnlen), 
	    igraphivout_(integer *, integer *, integer *, integer *, char *, ftnlen)
	    ;
    extern doublereal igraphdlamch_(char *);
    extern /* Subroutine */ int igraphsecond_(real *), igraphdlacpy_(char *, integer *, 
	    integer *, doublereal *, integer *, doublereal *, integer *), igraphdlartg_(doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *), igraphdlaset_(char *, integer *, integer *,
	     doublereal *, doublereal *, doublereal *, integer *);
    IGRAPH_F77_SAVE doublereal epsmch;
    integer logfil, ndigit, msapps = 0, msglvl, istart;
    real tsapps = 0;
    integer kplusp;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   



       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %----------------------%   
       | Intrinsics Functions |   
       %----------------------%   


       %----------------%   
       | Data statments |   
       %----------------%   

       Parameter adjustments */
    --workd;
    --resid;
    --shift;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;

    /* Function Body   

       %-----------------------%   
       | Executable Statements |   
       %-----------------------% */

    if (first) {
	epsmch = igraphdlamch_("Epsilon-Machine");
	first = FALSE_;
    }
    itop = 1;

/*     %-------------------------------%   
       | Initialize timing statistics  |   
       | & message level for debugging |   
       %-------------------------------% */

    igraphsecond_(&t0);
    msglvl = msapps;

    kplusp = *kev + *np;

/*     %----------------------------------------------%   
       | Initialize Q to the identity matrix of order |   
       | kplusp used to accumulate the rotations.     |   
       %----------------------------------------------% */

    igraphdlaset_("All", &kplusp, &kplusp, &dgehd2__c_b4, &dgehd2__c_b5, &q[q_offset], ldq);

/*     %----------------------------------------------%   
       | Quick return if there are no shifts to apply |   
       %----------------------------------------------% */

    if (*np == 0) {
	goto L9000;
    }

/*     %----------------------------------------------------------%   
       | Apply the np shifts implicitly. Apply each shift to the  |   
       | whole matrix and not just to the submatrix from which it |   
       | comes.                                                   |   
       %----------------------------------------------------------% */

    i__1 = *np;
    for (jj = 1; jj <= i__1; ++jj) {

	istart = itop;

/*        %----------------------------------------------------------%   
          | Check for splitting and deflation. Currently we consider |   
          | an off-diagonal element h(i+1,1) negligible if           |   
          |         h(i+1,1) .le. epsmch*( |h(i,2)| + |h(i+1,2)| )   |   
          | for i=1:KEV+NP-1.                                        |   
          | If above condition tests true then we set h(i+1,1) = 0.  |   
          | Note that h(1:KEV+NP,1) are assumed to be non negative.  |   
          %----------------------------------------------------------% */

L20:

/*        %------------------------------------------------%   
          | The following loop exits early if we encounter |   
          | a negligible off diagonal element.             |   
          %------------------------------------------------% */

	i__2 = kplusp - 1;
	for (i__ = istart; i__ <= i__2; ++i__) {
	    big = (d__1 = h__[i__ + (h_dim1 << 1)], abs(d__1)) + (d__2 = h__[
		    i__ + 1 + (h_dim1 << 1)], abs(d__2));
	    if (h__[i__ + 1 + h_dim1] <= epsmch * big) {
		if (msglvl > 0) {
		    igraphivout_(&logfil, &dgehd2__c__1, &i__, &ndigit, "_sapps: deflation"
			    " at row/column no.", (ftnlen)35);
		    igraphivout_(&logfil, &dgehd2__c__1, &jj, &ndigit, "_sapps: occured be"
			    "fore shift number.", (ftnlen)36);
		    igraphdvout_(&logfil, &dgehd2__c__1, &h__[i__ + 1 + h_dim1], &ndigit, 
			    "_sapps: the corresponding off diagonal element", 
			    (ftnlen)46);
		}
		h__[i__ + 1 + h_dim1] = 0.;
		iend = i__;
		goto L40;
	    }
/* L30: */
	}
	iend = kplusp;
L40:

	if (istart < iend) {

/*           %--------------------------------------------------------%   
             | Construct the plane rotation G'(istart,istart+1,theta) |   
             | that attempts to drive h(istart+1,1) to zero.          |   
             %--------------------------------------------------------% */

	    f = h__[istart + (h_dim1 << 1)] - shift[jj];
	    g = h__[istart + 1 + h_dim1];
	    igraphdlartg_(&f, &g, &c__, &s, &r__);

/*            %-------------------------------------------------------%   
              | Apply rotation to the left and right of H;            |   
              | H <- G' * H * G,  where G = G(istart,istart+1,theta). |   
              | This will create a "bulge".                           |   
              %-------------------------------------------------------% */

	    a1 = c__ * h__[istart + (h_dim1 << 1)] + s * h__[istart + 1 + 
		    h_dim1];
	    a2 = c__ * h__[istart + 1 + h_dim1] + s * h__[istart + 1 + (
		    h_dim1 << 1)];
	    a4 = c__ * h__[istart + 1 + (h_dim1 << 1)] - s * h__[istart + 1 + 
		    h_dim1];
	    a3 = c__ * h__[istart + 1 + h_dim1] - s * h__[istart + (h_dim1 << 
		    1)];
	    h__[istart + (h_dim1 << 1)] = c__ * a1 + s * a2;
	    h__[istart + 1 + (h_dim1 << 1)] = c__ * a4 - s * a3;
	    h__[istart + 1 + h_dim1] = c__ * a3 + s * a4;

/*            %----------------------------------------------------%   
              | Accumulate the rotation in the matrix Q;  Q <- Q*G |   
              %----------------------------------------------------%   

   Computing MIN */
	    i__3 = istart + jj;
	    i__2 = min(i__3,kplusp);
	    for (j = 1; j <= i__2; ++j) {
		a1 = c__ * q[j + istart * q_dim1] + s * q[j + (istart + 1) * 
			q_dim1];
		q[j + (istart + 1) * q_dim1] = -s * q[j + istart * q_dim1] + 
			c__ * q[j + (istart + 1) * q_dim1];
		q[j + istart * q_dim1] = a1;
/* L60: */
	    }


/*            %----------------------------------------------%   
              | The following loop chases the bulge created. |   
              | Note that the previous rotation may also be  |   
              | done within the following loop. But it is    |   
              | kept separate to make the distinction among  |   
              | the bulge chasing sweeps and the first plane |   
              | rotation designed to drive h(istart+1,1) to  |   
              | zero.                                        |   
              %----------------------------------------------% */

	    i__2 = iend - 1;
	    for (i__ = istart + 1; i__ <= i__2; ++i__) {

/*               %----------------------------------------------%   
                 | Construct the plane rotation G'(i,i+1,theta) |   
                 | that zeros the i-th bulge that was created   |   
                 | by G(i-1,i,theta). g represents the bulge.   |   
                 %----------------------------------------------% */

		f = h__[i__ + h_dim1];
		g = s * h__[i__ + 1 + h_dim1];

/*               %----------------------------------%   
                 | Final update with G(i-1,i,theta) |   
                 %----------------------------------% */

		h__[i__ + 1 + h_dim1] = c__ * h__[i__ + 1 + h_dim1];
		igraphdlartg_(&f, &g, &c__, &s, &r__);

/*               %-------------------------------------------%   
                 | The following ensures that h(1:iend-1,1), |   
                 | the first iend-2 off diagonal of elements |   
                 | H, remain non negative.                   |   
                 %-------------------------------------------% */

		if (r__ < 0.) {
		    r__ = -r__;
		    c__ = -c__;
		    s = -s;
		}

/*               %--------------------------------------------%   
                 | Apply rotation to the left and right of H; |   
                 | H <- G * H * G',  where G = G(i,i+1,theta) |   
                 %--------------------------------------------% */

		h__[i__ + h_dim1] = r__;

		a1 = c__ * h__[i__ + (h_dim1 << 1)] + s * h__[i__ + 1 + 
			h_dim1];
		a2 = c__ * h__[i__ + 1 + h_dim1] + s * h__[i__ + 1 + (h_dim1 
			<< 1)];
		a3 = c__ * h__[i__ + 1 + h_dim1] - s * h__[i__ + (h_dim1 << 1)
			];
		a4 = c__ * h__[i__ + 1 + (h_dim1 << 1)] - s * h__[i__ + 1 + 
			h_dim1];

		h__[i__ + (h_dim1 << 1)] = c__ * a1 + s * a2;
		h__[i__ + 1 + (h_dim1 << 1)] = c__ * a4 - s * a3;
		h__[i__ + 1 + h_dim1] = c__ * a3 + s * a4;

/*               %----------------------------------------------------%   
                 | Accumulate the rotation in the matrix Q;  Q <- Q*G |   
                 %----------------------------------------------------%   

   Computing MIN */
		i__4 = j + jj;
		i__3 = min(i__4,kplusp);
		for (j = 1; j <= i__3; ++j) {
		    a1 = c__ * q[j + i__ * q_dim1] + s * q[j + (i__ + 1) * 
			    q_dim1];
		    q[j + (i__ + 1) * q_dim1] = -s * q[j + i__ * q_dim1] + 
			    c__ * q[j + (i__ + 1) * q_dim1];
		    q[j + i__ * q_dim1] = a1;
/* L50: */
		}

/* L70: */
	    }

	}

/*        %--------------------------%   
          | Update the block pointer |   
          %--------------------------% */

	istart = iend + 1;

/*        %------------------------------------------%   
          | Make sure that h(iend,1) is non-negative |   
          | If not then set h(iend,1) <-- -h(iend,1) |   
          | and negate the last column of Q.         |   
          | We have effectively carried out a        |   
          | similarity on transformation H           |   
          %------------------------------------------% */

	if (h__[iend + h_dim1] < 0.) {
	    h__[iend + h_dim1] = -h__[iend + h_dim1];
	    igraphdscal_(&kplusp, &dgehd2__c_b20, &q[iend * q_dim1 + 1], &dgehd2__c__1);
	}

/*        %--------------------------------------------------------%   
          | Apply the same shift to the next block if there is any |   
          %--------------------------------------------------------% */

	if (iend < kplusp) {
	    goto L20;
	}

/*        %-----------------------------------------------------%   
          | Check if we can increase the the start of the block |   
          %-----------------------------------------------------% */

	i__2 = kplusp - 1;
	for (i__ = itop; i__ <= i__2; ++i__) {
	    if (h__[i__ + 1 + h_dim1] > 0.) {
		goto L90;
	    }
	    ++itop;
/* L80: */
	}

/*        %-----------------------------------%   
          | Finished applying the jj-th shift |   
          %-----------------------------------% */

L90:
	;
    }

/*     %------------------------------------------%   
       | All shifts have been applied. Check for  |   
       | more possible deflation that might occur |   
       | after the last shift is applied.         |   
       %------------------------------------------% */

    i__1 = kplusp - 1;
    for (i__ = itop; i__ <= i__1; ++i__) {
	big = (d__1 = h__[i__ + (h_dim1 << 1)], abs(d__1)) + (d__2 = h__[i__ 
		+ 1 + (h_dim1 << 1)], abs(d__2));
	if (h__[i__ + 1 + h_dim1] <= epsmch * big) {
	    if (msglvl > 0) {
		igraphivout_(&logfil, &dgehd2__c__1, &i__, &ndigit, "_sapps: deflation at "
			"row/column no.", (ftnlen)35);
		igraphdvout_(&logfil, &dgehd2__c__1, &h__[i__ + 1 + h_dim1], &ndigit, "_sa"
			"pps: the corresponding off diagonal element", (ftnlen)
			46);
	    }
	    h__[i__ + 1 + h_dim1] = 0.;
	}
/* L100: */
    }

/*     %-------------------------------------------------%   
       | Compute the (kev+1)-st column of (V*Q) and      |   
       | temporarily store the result in WORKD(N+1:2*N). |   
       | This is not necessary if h(kev+1,1) = 0.         |   
       %-------------------------------------------------% */

    if (h__[*kev + 1 + h_dim1] > 0.) {
	igraphdgemv_("N", n, &kplusp, &dgehd2__c_b5, &v[v_offset], ldv, &q[(*kev + 1) * 
		q_dim1 + 1], &dgehd2__c__1, &dgehd2__c_b4, &workd[*n + 1], &dgehd2__c__1);
    }

/*     %-------------------------------------------------------%   
       | Compute column 1 to kev of (V*Q) in backward order    |   
       | taking advantage that Q is an upper triangular matrix |   
       | with lower bandwidth np.                              |   
       | Place results in v(:,kplusp-kev:kplusp) temporarily.  |   
       %-------------------------------------------------------% */

    i__1 = *kev;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = kplusp - i__ + 1;
	igraphdgemv_("N", n, &i__2, &dgehd2__c_b5, &v[v_offset], ldv, &q[(*kev - i__ + 1) * 
		q_dim1 + 1], &dgehd2__c__1, &dgehd2__c_b4, &workd[1], &dgehd2__c__1);
	igraphdcopy_(n, &workd[1], &dgehd2__c__1, &v[(kplusp - i__ + 1) * v_dim1 + 1], &
		dgehd2__c__1);
/* L130: */
    }

/*     %-------------------------------------------------%   
       |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |   
       %-------------------------------------------------% */

    igraphdlacpy_("All", n, kev, &v[(*np + 1) * v_dim1 + 1], ldv, &v[v_offset], ldv);

/*     %--------------------------------------------%   
       | Copy the (kev+1)-st column of (V*Q) in the |   
       | appropriate place if h(kev+1,1) .ne. zero. |   
       %--------------------------------------------% */

    if (h__[*kev + 1 + h_dim1] > 0.) {
	igraphdcopy_(n, &workd[*n + 1], &dgehd2__c__1, &v[(*kev + 1) * v_dim1 + 1], &dgehd2__c__1);
    }

/*     %-------------------------------------%   
       | Update the residual vector:         |   
       |    r <- sigmak*r + betak*v(:,kev+1) |   
       | where                               |   
       |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |   
       |    betak = e_{kev+1}'*H*e_{kev}     |   
       %-------------------------------------% */

    igraphdscal_(n, &q[kplusp + *kev * q_dim1], &resid[1], &dgehd2__c__1);
    if (h__[*kev + 1 + h_dim1] > 0.) {
		cblas_daxpy(n, h__[*kev + 1 + h_dim1], &v[(*kev + 1) * v_dim1 + 1], 1, &resid[1], 1);
		//igraphdaxpy_(n, &h__[*kev + 1 + h_dim1], &v[(*kev + 1) * v_dim1 + 1], &dgehd2__c__1, &resid[1], &dgehd2__c__1);
    }

    if (msglvl > 1) {
	igraphdvout_(&logfil, &dgehd2__c__1, &q[kplusp + *kev * q_dim1], &ndigit, "_sapps:"
		" sigmak of the updated residual vector", (ftnlen)45);
	igraphdvout_(&logfil, &dgehd2__c__1, &h__[*kev + 1 + h_dim1], &ndigit, "_sapps: be"
		"tak of the updated residual vector", (ftnlen)44);
	igraphdvout_(&logfil, kev, &h__[(h_dim1 << 1) + 1], &ndigit, "_sapps: upda"
		"ted main diagonal of H for next iteration", (ftnlen)53);
	if (*kev > 1) {
	    i__1 = *kev - 1;
	    igraphdvout_(&logfil, &i__1, &h__[h_dim1 + 2], &ndigit, "_sapps: updat"
		    "ed sub diagonal of H for next iteration", (ftnlen)52);
	}
    }

    igraphsecond_(&t1);
    tsapps += t1 - t0;

L9000:
    return 0;

/*     %---------------%   
       | End of dsapps |   
       %---------------% */

} /* igraphdsapps_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static doublereal dgehrd__c_b3 = .66666666666666663;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dsconv   

   \Description:   
    Convergence testing for the symmetric Arnoldi eigenvalue routine.   

   \Usage:   
    call dsconv   
       ( N, RITZ, BOUNDS, TOL, NCONV )   

   \Arguments   
    N       Integer.  (INPUT)   
            Number of Ritz values to check for convergence.   

    RITZ    Double precision array of length N.  (INPUT)   
            The Ritz values to be checked for convergence.   

    BOUNDS  Double precision array of length N.  (INPUT)   
            Ritz estimates associated with the Ritz values in RITZ.   

    TOL     Double precision scalar.  (INPUT)   
            Desired relative accuracy for a Ritz value to be considered   
            "converged".   

    NCONV   Integer scalar.  (OUTPUT)   
            Number of "converged" Ritz values.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Routines called:   
       second  ARPACK utility routine for timing.   
       dlamch  LAPACK routine that determines machine constants.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \SCCS Information: @(#)   
   FILE: sconv.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2   

   \Remarks   
       1. Starting with version 2.4, this routine no longer uses the   
          Parlett strategy using the gap conditions.   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdsconv_(integer *n, doublereal *ritz, doublereal *bounds,
	 doublereal *tol, integer *nconv)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2, d__3;

    /* Builtin functions */
    double pow_dd(doublereal *, doublereal *);

    /* Local variables */
    integer i__;
    real t0, t1;
    doublereal eps23, temp;
    extern doublereal igraphdlamch_(char *);
    extern /* Subroutine */ int igraphsecond_(real *);
    real tsconv = 0;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %-------------------%   
       | External routines |   
       %-------------------%   

       %---------------------%   
       | Intrinsic Functions |   
       %---------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       Parameter adjustments */
    --bounds;
    --ritz;

    /* Function Body */
    igraphsecond_(&t0);

    eps23 = igraphdlamch_("Epsilon-Machine");
    eps23 = pow_dd(&eps23, &dgehrd__c_b3);

    *nconv = 0;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*        %-----------------------------------------------------%   
          | The i-th Ritz value is considered "converged"       |   
          | when: bounds(i) .le. TOL*max(eps23, abs(ritz(i)))   |   
          %-----------------------------------------------------%   

   Computing MAX */
	d__2 = eps23, d__3 = (d__1 = ritz[i__], abs(d__1));
	temp = max(d__2,d__3);
	if (bounds[i__] <= *tol * temp) {
	    ++(*nconv);
	}

/* L10: */
    }

    igraphsecond_(&t1);
    tsconv += t1 - t0;

    return 0;

/*     %---------------%   
       | End of dsconv |   
       %---------------% */

} /* igraphdsconv_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer dgemm__c__1 = 1;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dseigt   

   \Description:   
    Compute the eigenvalues of the current symmetric tridiagonal matrix   
    and the corresponding error bounds given the current residual norm.   

   \Usage:   
    call dseigt   
       ( RNORM, N, H, LDH, EIG, BOUNDS, WORKL, IERR )   

   \Arguments   
    RNORM   Double precision scalar.  (INPUT)   
            RNORM contains the residual norm corresponding to the current   
            symmetric tridiagonal matrix H.   

    N       Integer.  (INPUT)   
            Size of the symmetric tridiagonal matrix H.   

    H       Double precision N by 2 array.  (INPUT)   
            H contains the symmetric tridiagonal matrix with the   
            subdiagonal in the first column starting at H(2,1) and the   
            main diagonal in second column.   

    LDH     Integer.  (INPUT)   
            Leading dimension of H exactly as declared in the calling   
            program.   

    EIG     Double precision array of length N.  (OUTPUT)   
            On output, EIG contains the N eigenvalues of H possibly   
            unsorted.  The BOUNDS arrays are returned in the   
            same sorted order as EIG.   

    BOUNDS  Double precision array of length N.  (OUTPUT)   
            On output, BOUNDS contains the error estimates corresponding   
            to the eigenvalues EIG.  This is equal to RNORM times the   
            last components of the eigenvectors corresponding to the   
            eigenvalues in EIG.   

    WORKL   Double precision work array of length 3*N.  (WORKSPACE)   
            Private (replicated) array on each PE or array allocated on   
            the front end.   

    IERR    Integer.  (OUTPUT)   
            Error exit flag from dstqrb.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \Routines called:   
       dstqrb  ARPACK routine that computes the eigenvalues and the   
               last components of the eigenvectors of a symmetric   
               and tridiagonal matrix.   
       second  ARPACK utility routine for timing.   
       dvout   ARPACK utility routine that prints vectors.   
       dcopy   Level 1 BLAS that copies one vector to another.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       xx/xx/92: Version ' 2.4'   

   \SCCS Information: @(#)   
   FILE: seigt.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2   

   \Remarks   
       None   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdseigt_(doublereal *rnorm, integer *n, doublereal *h__, 
	integer *ldh, doublereal *eig, doublereal *bounds, doublereal *workl, 
	integer *ierr)
{
    /* System generated locals */
    integer h_dim1, h_offset, i__1;
    doublereal d__1;

    /* Local variables */
    integer k;
    real t0, t1;
    extern /* Subroutine */ int igraphdcopy_(integer *, doublereal *, integer *, 
	    doublereal *, integer *), igraphdvout_(integer *, integer *, doublereal 
	    *, integer *, char *, ftnlen), igraphsecond_(real *);
    integer logfil, ndigit, mseigt = 0;
    extern /* Subroutine */ int igraphdstqrb_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *);
    real tseigt = 0.0;
    integer msglvl;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       %-------------------------------%   
       | Initialize timing statistics  |   
       | & message level for debugging |   
       %-------------------------------%   

       Parameter adjustments */
    --workl;
    --bounds;
    --eig;
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;

    /* Function Body */
    igraphsecond_(&t0);
    msglvl = mseigt;

    if (msglvl > 0) {
	igraphdvout_(&logfil, n, &h__[(h_dim1 << 1) + 1], &ndigit, "_seigt: main d"
		"iagonal of matrix H", (ftnlen)33);
	if (*n > 1) {
	    i__1 = *n - 1;
	    igraphdvout_(&logfil, &i__1, &h__[h_dim1 + 2], &ndigit, "_seigt: sub d"
		    "iagonal of matrix H", (ftnlen)32);
	}
    }

    igraphdcopy_(n, &h__[(h_dim1 << 1) + 1], &dgemm__c__1, &eig[1], &dgemm__c__1);
    i__1 = *n - 1;
    igraphdcopy_(&i__1, &h__[h_dim1 + 2], &dgemm__c__1, &workl[1], &dgemm__c__1);
    igraphdstqrb_(n, &eig[1], &workl[1], &bounds[1], &workl[*n + 1], ierr);
    if (*ierr != 0) {
	goto L9000;
    }
    if (msglvl > 1) {
	igraphdvout_(&logfil, n, &bounds[1], &ndigit, "_seigt: last row of the eig"
		"envector matrix for H", (ftnlen)48);
    }

/*     %-----------------------------------------------%   
       | Finally determine the error bounds associated |   
       | with the n Ritz values of H.                  |   
       %-----------------------------------------------% */

    i__1 = *n;
    for (k = 1; k <= i__1; ++k) {
	bounds[k] = *rnorm * (d__1 = bounds[k], abs(d__1));
/* L30: */
    }

    igraphsecond_(&t1);
    tseigt += t1 - t0;

L9000:
    return 0;

/*     %---------------%   
       | End of dseigt |   
       %---------------% */

} /* igraphdseigt_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static logical dgemv__c_true = TRUE_;
static integer dgemv__c__1 = 1;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dsgets   

   \Description:   
    Given the eigenvalues of the symmetric tridiagonal matrix H,   
    computes the NP shifts AMU that are zeros of the polynomial of   
    degree NP which filters out components of the unwanted eigenvectors   
    corresponding to the AMU's based on some given criteria.   

    NOTE: This is called even in the case of user specified shifts in   
    order to sort the eigenvalues, and error bounds of H for later use.   

   \Usage:   
    call dsgets   
       ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS, SHIFTS )   

   \Arguments   
    ISHIFT  Integer.  (INPUT)   
            Method for selecting the implicit shifts at each iteration.   
            ISHIFT = 0: user specified shifts   
            ISHIFT = 1: exact shift with respect to the matrix H.   

    WHICH   Character*2.  (INPUT)   
            Shift selection criteria.   
            'LM' -> KEV eigenvalues of largest magnitude are retained.   
            'SM' -> KEV eigenvalues of smallest magnitude are retained.   
            'LA' -> KEV eigenvalues of largest value are retained.   
            'SA' -> KEV eigenvalues of smallest value are retained.   
            'BE' -> KEV eigenvalues, half from each end of the spectrum.   
                    If KEV is odd, compute one more from the high end.   

    KEV      Integer.  (INPUT)   
            KEV+NP is the size of the matrix H.   

    NP      Integer.  (INPUT)   
            Number of implicit shifts to be computed.   

    RITZ    Double precision array of length KEV+NP.  (INPUT/OUTPUT)   
            On INPUT, RITZ contains the eigenvalues of H.   
            On OUTPUT, RITZ are sorted so that the unwanted eigenvalues   
            are in the first NP locations and the wanted part is in   
            the last KEV locations.  When exact shifts are selected, the   
            unwanted part corresponds to the shifts to be applied.   

    BOUNDS  Double precision array of length KEV+NP.  (INPUT/OUTPUT)   
            Error bounds corresponding to the ordering in RITZ.   

    SHIFTS  Double precision array of length NP.  (INPUT/OUTPUT)   
            On INPUT:  contains the user specified shifts if ISHIFT = 0.   
            On OUTPUT: contains the shifts sorted into decreasing order   
            of magnitude with respect to the Ritz estimates contained in   
            BOUNDS. If ISHIFT = 0, SHIFTS is not modified on exit.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \Routines called:   
       dsortr  ARPACK utility sorting routine.   
       ivout   ARPACK utility routine that prints integers.   
       second  ARPACK utility routine for timing.   
       dvout   ARPACK utility routine that prints vectors.   
       dcopy   Level 1 BLAS that copies one vector to another.   
       dswap   Level 1 BLAS that swaps the contents of two vectors.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       xx/xx/93: Version ' 2.1'   

   \SCCS Information: @(#)   
   FILE: sgets.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2   

   \Remarks   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdsgets_(integer *ishift, char *which, integer *kev, 
	integer *np, doublereal *ritz, doublereal *bounds, doublereal *shifts)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    real t0, t1;
    integer kevd2;
    extern /* Subroutine */ int igraphdswap_(integer *, doublereal *, integer *, 
	    doublereal *, integer *), igraphdcopy_(integer *, doublereal *, integer 
	    *, doublereal *, integer *), igraphdvout_(integer *, integer *, 
	    doublereal *, integer *, char *, ftnlen), igraphivout_(integer *, 
	    integer *, integer *, integer *, char *, ftnlen), igraphsecond_(real *);
    integer logfil, ndigit, msgets = 0, msglvl;
    real tsgets = 0.0;
    extern /* Subroutine */ int igraphdsortr_(char *, logical *, integer *, 
	    doublereal *, doublereal *);


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %---------------------%   
       | Intrinsic Functions |   
       %---------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       %-------------------------------%   
       | Initialize timing statistics  |   
       | & message level for debugging |   
       %-------------------------------%   

       Parameter adjustments */
    --shifts;
    --bounds;
    --ritz;

    /* Function Body */
    igraphsecond_(&t0);
    msglvl = msgets;

    if (s_cmp(which, "BE", (ftnlen)2, (ftnlen)2) == 0) {

/*        %-----------------------------------------------------%   
          | Both ends of the spectrum are requested.            |   
          | Sort the eigenvalues into algebraically increasing  |   
          | order first then swap high end of the spectrum next |   
          | to low end in appropriate locations.                |   
          | NOTE: when np < floor(kev/2) be careful not to swap |   
          | overlapping locations.                              |   
          %-----------------------------------------------------% */

	i__1 = *kev + *np;
	igraphdsortr_("LA", &dgemv__c_true, &i__1, &ritz[1], &bounds[1]);
	kevd2 = *kev / 2;
	if (*kev > 1) {
	    i__1 = min(kevd2,*np);
	    igraphdswap_(&i__1, &ritz[1], &dgemv__c__1, &ritz[max(kevd2,*np) + 1], &dgemv__c__1);
	    i__1 = min(kevd2,*np);
	    igraphdswap_(&i__1, &bounds[1], &dgemv__c__1, &bounds[max(kevd2,*np) + 1], &
		    dgemv__c__1);
	}

    } else {

/*        %----------------------------------------------------%   
          | LM, SM, LA, SA case.                               |   
          | Sort the eigenvalues of H into the desired order   |   
          | and apply the resulting order to BOUNDS.           |   
          | The eigenvalues are sorted so that the wanted part |   
          | are always in the last KEV locations.               |   
          %----------------------------------------------------% */

	i__1 = *kev + *np;
	igraphdsortr_(which, &dgemv__c_true, &i__1, &ritz[1], &bounds[1]);
    }

    if (*ishift == 1 && *np > 0) {

/*        %-------------------------------------------------------%   
          | Sort the unwanted Ritz values used as shifts so that  |   
          | the ones with largest Ritz estimates are first.       |   
          | This will tend to minimize the effects of the         |   
          | forward instability of the iteration when the shifts  |   
          | are applied in subroutine dsapps.                     |   
          %-------------------------------------------------------% */

	igraphdsortr_("SM", &dgemv__c_true, np, &bounds[1], &ritz[1]);
	igraphdcopy_(np, &ritz[1], &dgemv__c__1, &shifts[1], &dgemv__c__1);
    }

    igraphsecond_(&t1);
    tsgets += t1 - t0;

    if (msglvl > 0) {
	igraphivout_(&logfil, &dgemv__c__1, kev, &ndigit, "_sgets: KEV is", (ftnlen)14);
	igraphivout_(&logfil, &dgemv__c__1, np, &ndigit, "_sgets: NP is", (ftnlen)13);
	i__1 = *kev + *np;
	igraphdvout_(&logfil, &i__1, &ritz[1], &ndigit, "_sgets: Eigenvalues of cu"
		"rrent H matrix", (ftnlen)39);
	i__1 = *kev + *np;
	igraphdvout_(&logfil, &i__1, &bounds[1], &ndigit, "_sgets: Associated Ritz"
		" estimates", (ftnlen)33);
    }

    return 0;

/*     %---------------%   
       | End of dsgets |   
       %---------------% */

} /* igraphdsgets_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer dgeqr2__c__0 = 0;
static integer dgeqr2__c__1 = 1;
static doublereal dgeqr2__c_b31 = 1.;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dstqrb   

   \Description:   
    Computes all eigenvalues and the last component of the eigenvectors   
    of a symmetric tridiagonal matrix using the implicit QL or QR method.   

    This is mostly a modification of the LAPACK routine dsteqr.   
    See Remarks.   

   \Usage:   
    call dstqrb   
       ( N, D, E, Z, WORK, INFO )   

   \Arguments   
    N       Integer.  (INPUT)   
            The number of rows and columns in the matrix.  N >= 0.   

    D       Double precision array, dimension (N).  (INPUT/OUTPUT)   
            On entry, D contains the diagonal elements of the   
            tridiagonal matrix.   
            On exit, D contains the eigenvalues, in ascending order.   
            If an error exit is made, the eigenvalues are correct   
            for indices 1,2,...,INFO-1, but they are unordered and   
            may not be the smallest eigenvalues of the matrix.   

    E       Double precision array, dimension (N-1).  (INPUT/OUTPUT)   
            On entry, E contains the subdiagonal elements of the   
            tridiagonal matrix in positions 1 through N-1.   
            On exit, E has been destroyed.   

    Z       Double precision array, dimension (N).  (OUTPUT)   
            On exit, Z contains the last row of the orthonormal   
            eigenvector matrix of the symmetric tridiagonal matrix.   
            If an error exit is made, Z contains the last row of the   
            eigenvector matrix associated with the stored eigenvalues.   

    WORK    Double precision array, dimension (max(1,2*N-2)).  (WORKSPACE)   
            Workspace used in accumulating the transformation for   
            computing the last components of the eigenvectors.   

    INFO    Integer.  (OUTPUT)   
            = 0:  normal return.   
            < 0:  if INFO = -i, the i-th argument had an illegal value.   
            > 0:  if INFO = +i, the i-th eigenvalue has not converged   
                                after a total of  30*N  iterations.   

   \Remarks   
    1. None.   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \Routines called:   
       daxpy   Level 1 BLAS that computes a vector triad.   
       dcopy   Level 1 BLAS that copies one vector to another.   
       dswap   Level 1 BLAS that swaps the contents of two vectors.   
       lsame   LAPACK character comparison routine.   
       dlae2   LAPACK routine that computes the eigenvalues of a 2-by-2   
               symmetric matrix.   
       dlaev2  LAPACK routine that eigendecomposition of a 2-by-2 symmetric   
               matrix.   
       dlamch  LAPACK routine that determines machine constants.   
       dlanst  LAPACK routine that computes the norm of a matrix.   
       dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.   
       dlartg  LAPACK Givens rotation construction routine.   
       dlascl  LAPACK routine for careful scaling of a matrix.   
       dlaset  LAPACK matrix initialization routine.   
       dlasr   LAPACK routine that applies an orthogonal transformation to   
               a matrix.   
       dlasrt  LAPACK sorting routine.   
       dsteqr  LAPACK routine that computes eigenvalues and eigenvectors   
               of a symmetric tridiagonal matrix.   
       xerbla  LAPACK error handler routine.   

   \Authors   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \SCCS Information: @(#)   
   FILE: stqrb.F   SID: 2.5   DATE OF SID: 8/27/96   RELEASE: 2   

   \Remarks   
       1. Starting with version 2.5, this routine is a modified version   
          of LAPACK version 2.0 subroutine SSTEQR. No lines are deleted,   
          only commeted out and new lines inserted.   
          All lines commented out have "c$$$" at the beginning.   
          Note that the LAPACK version 1.0 subroutine SSTEQR contained   
          bugs.   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdstqrb_(integer *n, doublereal *d__, doublereal *e, 
	doublereal *z__, doublereal *work, integer *info)
{
    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal), d_sign(doublereal *, doublereal *);

    /* Local variables */
    doublereal b, c__, f, g;
    integer i__, j, k, l, m;
    doublereal p, r__, s;
    integer l1, ii, mm, lm1, mm1, nm1;
    doublereal rt1, rt2, eps;
    integer lsv;
    doublereal tst, eps2;
    integer lend, jtot;
    extern /* Subroutine */ int igraphdlae2_(doublereal *, doublereal *, doublereal 
	    *, doublereal *, doublereal *), igraphdlasr_(char *, char *, char *, 
	    integer *, integer *, doublereal *, doublereal *, doublereal *, 
	    integer *);
    doublereal anorm;
    extern /* Subroutine */ int igraphdlaev2_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *);
    integer lendm1, lendp1;
    extern doublereal igraphdlapy2_(doublereal *, doublereal *), igraphdlamch_(char *);
    integer iscale;
    extern /* Subroutine */ int igraphdlascl_(char *, integer *, integer *, 
	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
	    integer *, integer *);
    doublereal safmin;
    extern /* Subroutine */ int igraphdlartg_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *);
    doublereal safmax;
    extern doublereal igraphdlanst_(char *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int igraphdlasrt_(char *, integer *, doublereal *, 
	    integer *);
    integer lendsv, nmaxit, icompz;
    doublereal ssfmax, ssfmin;


/*     %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   



       test the input parameters.   

       Parameter adjustments */
    --work;
    --z__;
    --e;
    --d__;

    /* Function Body */
    *info = 0;

/* $$$      IF( LSAME( COMPZ, 'N' ) ) THEN   
   $$$         ICOMPZ = 0   
   $$$      ELSE IF( LSAME( COMPZ, 'V' ) ) THEN   
   $$$         ICOMPZ = 1   
   $$$      ELSE IF( LSAME( COMPZ, 'I' ) ) THEN   
   $$$         ICOMPZ = 2   
   $$$      ELSE   
   $$$         ICOMPZ = -1   
   $$$      END IF   
   $$$      IF( ICOMPZ.LT.0 ) THEN   
   $$$         INFO = -1   
   $$$      ELSE IF( N.LT.0 ) THEN   
   $$$         INFO = -2   
   $$$      ELSE IF( ( LDZ.LT.1 ) .OR. ( ICOMPZ.GT.0 .AND. LDZ.LT.MAX( 1,   
   $$$     $         N ) ) ) THEN   
   $$$         INFO = -6   
   $$$      END IF   
   $$$      IF( INFO.NE.0 ) THEN   
   $$$         CALL XERBLA( 'SSTEQR', -INFO )   
   $$$         RETURN   
   $$$      END IF   

      *** New starting with version 2.5 *** */

    icompz = 2;
/*    *************************************   

       quick return if possible */

    if (*n == 0) {
	return 0;
    }

    if (*n == 1) {
	if (icompz == 2) {
	    z__[1] = 1.;
	}
	return 0;
    }

/*     determine the unit roundoff and over/underflow thresholds. */

    eps = igraphdlamch_("e");
/* Computing 2nd power */
    d__1 = eps;
    eps2 = d__1 * d__1;
    safmin = igraphdlamch_("s");
    safmax = 1. / safmin;
    ssfmax = sqrt(safmax) / 3.;
    ssfmin = sqrt(safmin) / eps2;

/*     compute the eigenvalues and eigenvectors of the tridiagonal   
       matrix.   

   $$      if( icompz.eq.2 )   
   $$$     $   call dlaset( 'full', n, n, zero, one, z, ldz )   

       *** New starting with version 2.5 *** */

    if (icompz == 2) {
	i__1 = *n - 1;
	for (j = 1; j <= i__1; ++j) {
	    z__[j] = 0.;
/* L5: */
	}
	z__[*n] = 1.;
    }
/*     ************************************* */

    nmaxit = *n * 30;
    jtot = 0;

/*     determine where the matrix splits and choose ql or qr iteration   
       for each block, according to whether top or bottom diagonal   
       element is smaller. */

    l1 = 1;
    nm1 = *n - 1;

L10:
    if (l1 > *n) {
	goto L160;
    }
    if (l1 > 1) {
	e[l1 - 1] = 0.;
    }
    if (l1 <= nm1) {
	i__1 = nm1;
	for (m = l1; m <= i__1; ++m) {
	    tst = (d__1 = e[m], abs(d__1));
	    if (tst == 0.) {
		goto L30;
	    }
	    if (tst <= sqrt((d__1 = d__[m], abs(d__1))) * sqrt((d__2 = d__[m 
		    + 1], abs(d__2))) * eps) {
		e[m] = 0.;
		goto L30;
	    }
/* L20: */
	}
    }
    m = *n;

L30:
    l = l1;
    lsv = l;
    lend = m;
    lendsv = lend;
    l1 = m + 1;
    if (lend == l) {
	goto L10;
    }

/*     scale submatrix in rows and columns l to lend */

    i__1 = lend - l + 1;
    anorm = igraphdlanst_("i", &i__1, &d__[l], &e[l]);
    iscale = 0;
    if (anorm == 0.) {
	goto L10;
    }
    if (anorm > ssfmax) {
	iscale = 1;
	i__1 = lend - l + 1;
	igraphdlascl_("g", &dgeqr2__c__0, &dgeqr2__c__0, &anorm, &ssfmax, &i__1, &dgeqr2__c__1, &d__[l], n, 
		info);
	i__1 = lend - l;
	igraphdlascl_("g", &dgeqr2__c__0, &dgeqr2__c__0, &anorm, &ssfmax, &i__1, &dgeqr2__c__1, &e[l], n, 
		info);
    } else if (anorm < ssfmin) {
	iscale = 2;
	i__1 = lend - l + 1;
	igraphdlascl_("g", &dgeqr2__c__0, &dgeqr2__c__0, &anorm, &ssfmin, &i__1, &dgeqr2__c__1, &d__[l], n, 
		info);
	i__1 = lend - l;
	igraphdlascl_("g", &dgeqr2__c__0, &dgeqr2__c__0, &anorm, &ssfmin, &i__1, &dgeqr2__c__1, &e[l], n, 
		info);
    }

/*     choose between ql and qr iteration */

    if ((d__1 = d__[lend], abs(d__1)) < (d__2 = d__[l], abs(d__2))) {
	lend = lsv;
	l = lendsv;
    }

    if (lend > l) {

/*        ql iteration   

          look for small subdiagonal element. */

L40:
	if (l != lend) {
	    lendm1 = lend - 1;
	    i__1 = lendm1;
	    for (m = l; m <= i__1; ++m) {
/* Computing 2nd power */
		d__2 = (d__1 = e[m], abs(d__1));
		tst = d__2 * d__2;
		if (tst <= eps2 * (d__1 = d__[m], abs(d__1)) * (d__2 = d__[m 
			+ 1], abs(d__2)) + safmin) {
		    goto L60;
		}
/* L50: */
	    }
	}

	m = lend;

L60:
	if (m < lend) {
	    e[m] = 0.;
	}
	p = d__[l];
	if (m == l) {
	    goto L80;
	}

/*        if remaining matrix is 2-by-2, use dlae2 or dlaev2   
          to compute its eigensystem. */

	if (m == l + 1) {
	    if (icompz > 0) {
		igraphdlaev2_(&d__[l], &e[l], &d__[l + 1], &rt1, &rt2, &c__, &s);
		work[l] = c__;
		work[*n - 1 + l] = s;
/* $$$               call dlasr( 'r', 'v', 'b', n, 2, work( l ),   
   $$$     $                     work( n-1+l ), z( 1, l ), ldz )   

                *** New starting with version 2.5 *** */

		tst = z__[l + 1];
		z__[l + 1] = c__ * tst - s * z__[l];
		z__[l] = s * tst + c__ * z__[l];
/*              ************************************* */
	    } else {
		igraphdlae2_(&d__[l], &e[l], &d__[l + 1], &rt1, &rt2);
	    }
	    d__[l] = rt1;
	    d__[l + 1] = rt2;
	    e[l] = 0.;
	    l += 2;
	    if (l <= lend) {
		goto L40;
	    }
	    goto L140;
	}

	if (jtot == nmaxit) {
	    goto L140;
	}
	++jtot;

/*        form shift. */

	g = (d__[l + 1] - p) / (e[l] * 2.);
	r__ = igraphdlapy2_(&g, &dgeqr2__c_b31);
	g = d__[m] - p + e[l] / (g + d_sign(&r__, &g));

	s = 1.;
	c__ = 1.;
	p = 0.;

/*        inner loop */

	mm1 = m - 1;
	i__1 = l;
	for (i__ = mm1; i__ >= i__1; --i__) {
	    f = s * e[i__];
	    b = c__ * e[i__];
	    igraphdlartg_(&g, &f, &c__, &s, &r__);
	    if (i__ != m - 1) {
		e[i__ + 1] = r__;
	    }
	    g = d__[i__ + 1] - p;
	    r__ = (d__[i__] - g) * s + c__ * 2. * b;
	    p = s * r__;
	    d__[i__ + 1] = g + p;
	    g = c__ * r__ - b;

/*           if eigenvectors are desired, then save rotations. */

	    if (icompz > 0) {
		work[i__] = c__;
		work[*n - 1 + i__] = -s;
	    }

/* L70: */
	}

/*        if eigenvectors are desired, then apply saved rotations. */

	if (icompz > 0) {
	    mm = m - l + 1;
/* $$$            call dlasr( 'r', 'v', 'b', n, mm, work( l ), work( n-1+l ),   
   $$$     $                  z( 1, l ), ldz )   

               *** New starting with version 2.5 *** */

	    igraphdlasr_("r", "v", "b", &dgeqr2__c__1, &mm, &work[l], &work[*n - 1 + l], &
		    z__[l], &dgeqr2__c__1);
/*             ************************************* */
	}

	d__[l] -= p;
	e[l] = g;
	goto L40;

/*        eigenvalue found. */

L80:
	d__[l] = p;

	++l;
	if (l <= lend) {
	    goto L40;
	}
	goto L140;

    } else {

/*        qr iteration   

          look for small superdiagonal element. */

L90:
	if (l != lend) {
	    lendp1 = lend + 1;
	    i__1 = lendp1;
	    for (m = l; m >= i__1; --m) {
/* Computing 2nd power */
		d__2 = (d__1 = e[m - 1], abs(d__1));
		tst = d__2 * d__2;
		if (tst <= eps2 * (d__1 = d__[m], abs(d__1)) * (d__2 = d__[m 
			- 1], abs(d__2)) + safmin) {
		    goto L110;
		}
/* L100: */
	    }
	}

	m = lend;

L110:
	if (m > lend) {
	    e[m - 1] = 0.;
	}
	p = d__[l];
	if (m == l) {
	    goto L130;
	}

/*        if remaining matrix is 2-by-2, use dlae2 or dlaev2   
          to compute its eigensystem. */

	if (m == l - 1) {
	    if (icompz > 0) {
		igraphdlaev2_(&d__[l - 1], &e[l - 1], &d__[l], &rt1, &rt2, &c__, &s)
			;
/* $$$               work( m ) = c   
   $$$               work( n-1+m ) = s   
   $$$               call dlasr( 'r', 'v', 'f', n, 2, work( m ),   
   $$$     $                     work( n-1+m ), z( 1, l-1 ), ldz )   

                 *** New starting with version 2.5 *** */

		tst = z__[l];
		z__[l] = c__ * tst - s * z__[l - 1];
		z__[l - 1] = s * tst + c__ * z__[l - 1];
/*               ************************************* */
	    } else {
		igraphdlae2_(&d__[l - 1], &e[l - 1], &d__[l], &rt1, &rt2);
	    }
	    d__[l - 1] = rt1;
	    d__[l] = rt2;
	    e[l - 1] = 0.;
	    l += -2;
	    if (l >= lend) {
		goto L90;
	    }
	    goto L140;
	}

	if (jtot == nmaxit) {
	    goto L140;
	}
	++jtot;

/*        form shift. */

	g = (d__[l - 1] - p) / (e[l - 1] * 2.);
	r__ = igraphdlapy2_(&g, &dgeqr2__c_b31);
	g = d__[m] - p + e[l - 1] / (g + d_sign(&r__, &g));

	s = 1.;
	c__ = 1.;
	p = 0.;

/*        inner loop */

	lm1 = l - 1;
	i__1 = lm1;
	for (i__ = m; i__ <= i__1; ++i__) {
	    f = s * e[i__];
	    b = c__ * e[i__];
	    igraphdlartg_(&g, &f, &c__, &s, &r__);
	    if (i__ != m) {
		e[i__ - 1] = r__;
	    }
	    g = d__[i__] - p;
	    r__ = (d__[i__ + 1] - g) * s + c__ * 2. * b;
	    p = s * r__;
	    d__[i__] = g + p;
	    g = c__ * r__ - b;

/*           if eigenvectors are desired, then save rotations. */

	    if (icompz > 0) {
		work[i__] = c__;
		work[*n - 1 + i__] = s;
	    }

/* L120: */
	}

/*        if eigenvectors are desired, then apply saved rotations. */

	if (icompz > 0) {
	    mm = l - m + 1;
/* $$$            call dlasr( 'r', 'v', 'f', n, mm, work( m ), work( n-1+m ),   
   $$$     $                  z( 1, m ), ldz )   

             *** New starting with version 2.5 *** */

	    igraphdlasr_("r", "v", "f", &dgeqr2__c__1, &mm, &work[m], &work[*n - 1 + m], &
		    z__[m], &dgeqr2__c__1);
/*           ************************************* */
	}

	d__[l] -= p;
	e[lm1] = g;
	goto L90;

/*        eigenvalue found. */

L130:
	d__[l] = p;

	--l;
	if (l >= lend) {
	    goto L90;
	}
	goto L140;

    }

/*     undo scaling if necessary */

L140:
    if (iscale == 1) {
	i__1 = lendsv - lsv + 1;
	igraphdlascl_("g", &dgeqr2__c__0, &dgeqr2__c__0, &ssfmax, &anorm, &i__1, &dgeqr2__c__1, &d__[lsv], 
		n, info);
	i__1 = lendsv - lsv;
	igraphdlascl_("g", &dgeqr2__c__0, &dgeqr2__c__0, &ssfmax, &anorm, &i__1, &dgeqr2__c__1, &e[lsv], n, 
		info);
    } else if (iscale == 2) {
	i__1 = lendsv - lsv + 1;
	igraphdlascl_("g", &dgeqr2__c__0, &dgeqr2__c__0, &ssfmin, &anorm, &i__1, &dgeqr2__c__1, &d__[lsv], 
		n, info);
	i__1 = lendsv - lsv;
	igraphdlascl_("g", &dgeqr2__c__0, &dgeqr2__c__0, &ssfmin, &anorm, &i__1, &dgeqr2__c__1, &e[lsv], n, 
		info);
    }

/*     check for no convergence to an eigenvalue after a total   
       of n*maxit iterations. */

    if (jtot < nmaxit) {
	goto L10;
    }
    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (e[i__] != 0.) {
	    ++(*info);
	}
/* L150: */
    }
    goto L190;

/*     order eigenvalues and eigenvectors. */

L160:
    if (icompz == 0) {

/*        use quick sort */

	igraphdlasrt_("i", n, &d__[1], info);

    } else {

/*        use selection sort to minimize swaps of eigenvectors */

	i__1 = *n;
	for (ii = 2; ii <= i__1; ++ii) {
	    i__ = ii - 1;
	    k = i__;
	    p = d__[i__];
	    i__2 = *n;
	    for (j = ii; j <= i__2; ++j) {
		if (d__[j] < p) {
		    k = j;
		    p = d__[j];
		}
/* L170: */
	    }
	    if (k != i__) {
		d__[k] = d__[i__];
		d__[i__] = p;
/* $$$               call dswap( n, z( 1, i ), 1, z( 1, k ), 1 )   
             *** New starting with version 2.5 *** */

		p = z__[k];
		z__[k] = z__[i__];
		z__[i__] = p;
/*           ************************************* */
	    }
/* L180: */
	}
    }

L190:
    return 0;

/*     %---------------%   
       | End of dstqrb |   
       %---------------% */

} /* igraphdstqrb_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer dger__c__1 = 1;
static integer dger__c__3 = 3;

/* -----------------------------------------------------------------------   
    Routine:    DMOUT   

    Purpose:    Real matrix output routine.   

    Usage:      CALL DMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)   

    Arguments   
       M      - Number of rows of A.  (Input)   
       N      - Number of columns of A.  (Input)   
       A      - Real M by N matrix to be printed.  (Input)   
       LDA    - Leading dimension of A exactly as specified in the   
                dimension statement of the calling program.  (Input)   
       IFMT   - Format to be used in printing matrix A.  (Input)   
       IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)   
                If IDIGIT .LT. 0, printing is done with 72 columns.   
                If IDIGIT .GT. 0, printing is done with 132 columns.   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdmout_(integer *lout, integer *m, integer *n, doublereal 
	*a, integer *lda, integer *idigit, char *ifmt, ftnlen ifmt_len)
{
    /* Initialized data */

    static char icol[1*3] = "C" "o" "l";

    /* Format strings */
    static char fmt_9999[] = "(/1x,a,/1x,a)";
    static char fmt_9998[] = "(10x,10(4x,3a1,i4,1x))";
    static char fmt_9994[] = "(1x,\002 Row\002,i4,\002:\002,1x,1p,10d12.3)";
    static char fmt_9997[] = "(10x,8(5x,3a1,i4,2x))";
    static char fmt_9993[] = "(1x,\002 Row\002,i4,\002:\002,1x,1p,8d14.5)";
    static char fmt_9996[] = "(10x,6(7x,3a1,i4,4x))";
    static char fmt_9992[] = "(1x,\002 Row\002,i4,\002:\002,1x,1p,6d18.9)";
    static char fmt_9995[] = "(10x,5(9x,3a1,i4,6x))";
    static char fmt_9991[] = "(1x,\002 Row\002,i4,\002:\002,1x,1p,5d22.13)";
    static char fmt_9990[] = "(1x,\002 \002)";

    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;

    /* Builtin functions */
    integer i_len(char *, ftnlen), s_wsfe(cilist *), do_fio(integer *, char *,
	     ftnlen), e_wsfe(void);

    /* Local variables */
    integer i__, j, k1, k2, lll;
    char line[80];
    integer ndigit;

    /* Fortran I/O blocks */
    static cilist io___5 = { 0, 0, 0, fmt_9999, 0 };
    static cilist io___9 = { 0, 0, 0, fmt_9998, 0 };
    static cilist io___10 = { 0, 0, 0, fmt_9994, 0 };
    static cilist io___12 = { 0, 0, 0, fmt_9997, 0 };
    static cilist io___13 = { 0, 0, 0, fmt_9993, 0 };
    static cilist io___14 = { 0, 0, 0, fmt_9996, 0 };
    static cilist io___15 = { 0, 0, 0, fmt_9992, 0 };
    static cilist io___16 = { 0, 0, 0, fmt_9995, 0 };
    static cilist io___17 = { 0, 0, 0, fmt_9991, 0 };
    static cilist io___18 = { 0, 0, 0, fmt_9998, 0 };
    static cilist io___19 = { 0, 0, 0, fmt_9994, 0 };
    static cilist io___20 = { 0, 0, 0, fmt_9997, 0 };
    static cilist io___21 = { 0, 0, 0, fmt_9993, 0 };
    static cilist io___22 = { 0, 0, 0, fmt_9996, 0 };
    static cilist io___23 = { 0, 0, 0, fmt_9992, 0 };
    static cilist io___24 = { 0, 0, 0, fmt_9995, 0 };
    static cilist io___25 = { 0, 0, 0, fmt_9991, 0 };
    static cilist io___26 = { 0, 0, 0, fmt_9990, 0 };


/*     ...   
       ... SPECIFICATIONS FOR ARGUMENTS   
       ...   
       ... SPECIFICATIONS FOR LOCAL VARIABLES   
       Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body   
       ...   
       ... FIRST EXECUTABLE STATEMENT   

   Computing MIN */
    i__1 = i_len(ifmt, ifmt_len);
    lll = min(i__1,80);
    i__1 = lll;
    for (i__ = 1; i__ <= i__1; ++i__) {
	*(unsigned char *)&line[i__ - 1] = '-';
/* L10: */
    }

    for (i__ = lll + 1; i__ <= 80; ++i__) {
	*(unsigned char *)&line[i__ - 1] = ' ';
/* L20: */
    }

    io___5.ciunit = *lout;
    s_wsfe(&io___5);
    do_fio(&dger__c__1, ifmt, ifmt_len);
    do_fio(&dger__c__1, line, lll);
    e_wsfe();

    if (*m <= 0 || *n <= 0 || *lda <= 0) {
	return 0;
    }
    ndigit = *idigit;
    if (*idigit == 0) {
	ndigit = 4;
    }

/* =======================================================================   
               CODE FOR OUTPUT USING 72 COLUMNS FORMAT   
   ======================================================================= */

    if (*idigit < 0) {
	ndigit = -(*idigit);
	if (ndigit <= 4) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 5) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 4;
		k2 = min(i__2,i__3);
		io___9.ciunit = *lout;
		s_wsfe(&io___9);
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dger__c__3, icol, (ftnlen)1);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		}
		e_wsfe();
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    io___10.ciunit = *lout;
		    s_wsfe(&io___10);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		    i__3 = k2;
		    for (j = k1; j <= i__3; ++j) {
			do_fio(&dger__c__1, (char *)&a[i__ + j * a_dim1], (ftnlen)
				sizeof(doublereal));
		    }
		    e_wsfe();
/* L30: */
		}
/* L40: */
	    }

	} else if (ndigit <= 6) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 4) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 3;
		k2 = min(i__2,i__3);
		io___12.ciunit = *lout;
		s_wsfe(&io___12);
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dger__c__3, icol, (ftnlen)1);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		}
		e_wsfe();
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    io___13.ciunit = *lout;
		    s_wsfe(&io___13);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		    i__3 = k2;
		    for (j = k1; j <= i__3; ++j) {
			do_fio(&dger__c__1, (char *)&a[i__ + j * a_dim1], (ftnlen)
				sizeof(doublereal));
		    }
		    e_wsfe();
/* L50: */
		}
/* L60: */
	    }

	} else if (ndigit <= 10) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 3) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 2;
		k2 = min(i__2,i__3);
		io___14.ciunit = *lout;
		s_wsfe(&io___14);
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dger__c__3, icol, (ftnlen)1);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		}
		e_wsfe();
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    io___15.ciunit = *lout;
		    s_wsfe(&io___15);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		    i__3 = k2;
		    for (j = k1; j <= i__3; ++j) {
			do_fio(&dger__c__1, (char *)&a[i__ + j * a_dim1], (ftnlen)
				sizeof(doublereal));
		    }
		    e_wsfe();
/* L70: */
		}
/* L80: */
	    }

	} else {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 2) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 1;
		k2 = min(i__2,i__3);
		io___16.ciunit = *lout;
		s_wsfe(&io___16);
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dger__c__3, icol, (ftnlen)1);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		}
		e_wsfe();
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    io___17.ciunit = *lout;
		    s_wsfe(&io___17);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		    i__3 = k2;
		    for (j = k1; j <= i__3; ++j) {
			do_fio(&dger__c__1, (char *)&a[i__ + j * a_dim1], (ftnlen)
				sizeof(doublereal));
		    }
		    e_wsfe();
/* L90: */
		}
/* L100: */
	    }
	}

/* =======================================================================   
               CODE FOR OUTPUT USING 132 COLUMNS FORMAT   
   ======================================================================= */

    } else {
	if (ndigit <= 4) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 10) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 9;
		k2 = min(i__2,i__3);
		io___18.ciunit = *lout;
		s_wsfe(&io___18);
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dger__c__3, icol, (ftnlen)1);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		}
		e_wsfe();
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    io___19.ciunit = *lout;
		    s_wsfe(&io___19);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		    i__3 = k2;
		    for (j = k1; j <= i__3; ++j) {
			do_fio(&dger__c__1, (char *)&a[i__ + j * a_dim1], (ftnlen)
				sizeof(doublereal));
		    }
		    e_wsfe();
/* L110: */
		}
/* L120: */
	    }

	} else if (ndigit <= 6) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 8) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 7;
		k2 = min(i__2,i__3);
		io___20.ciunit = *lout;
		s_wsfe(&io___20);
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dger__c__3, icol, (ftnlen)1);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		}
		e_wsfe();
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    io___21.ciunit = *lout;
		    s_wsfe(&io___21);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		    i__3 = k2;
		    for (j = k1; j <= i__3; ++j) {
			do_fio(&dger__c__1, (char *)&a[i__ + j * a_dim1], (ftnlen)
				sizeof(doublereal));
		    }
		    e_wsfe();
/* L130: */
		}
/* L140: */
	    }

	} else if (ndigit <= 10) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 6) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 5;
		k2 = min(i__2,i__3);
		io___22.ciunit = *lout;
		s_wsfe(&io___22);
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dger__c__3, icol, (ftnlen)1);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		}
		e_wsfe();
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    io___23.ciunit = *lout;
		    s_wsfe(&io___23);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		    i__3 = k2;
		    for (j = k1; j <= i__3; ++j) {
			do_fio(&dger__c__1, (char *)&a[i__ + j * a_dim1], (ftnlen)
				sizeof(doublereal));
		    }
		    e_wsfe();
/* L150: */
		}
/* L160: */
	    }

	} else {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 5) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 4;
		k2 = min(i__2,i__3);
		io___24.ciunit = *lout;
		s_wsfe(&io___24);
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dger__c__3, icol, (ftnlen)1);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		}
		e_wsfe();
		i__2 = *m;
		for (i__ = 1; i__ <= i__2; ++i__) {
		    io___25.ciunit = *lout;
		    s_wsfe(&io___25);
		    do_fio(&dger__c__1, (char *)&i__, (ftnlen)sizeof(integer));
		    i__3 = k2;
		    for (j = k1; j <= i__3; ++j) {
			do_fio(&dger__c__1, (char *)&a[i__ + j * a_dim1], (ftnlen)
				sizeof(doublereal));
		    }
		    e_wsfe();
/* L170: */
		}
/* L180: */
	    }
	}
    }
    io___26.ciunit = *lout;
    s_wsfe(&io___26);
    e_wsfe();


    return 0;
} /* igraphdmout_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer dgesv__c__1 = 1;

/* -----------------------------------------------------------------------   
    Routine:    IVOUT   

    Purpose:    Integer vector output routine.   

    Usage:      CALL IVOUT (LOUT, N, IX, IDIGIT, IFMT)   

    Arguments   
       N      - Length of array IX. (Input)   
       IX     - Integer array to be printed. (Input)   
       IFMT   - Format to be used in printing array IX. (Input)   
       IDIGIT - Print up to ABS(IDIGIT) decimal digits / number. (Input)   
                If IDIGIT .LT. 0, printing is done with 72 columns.   
                If IDIGIT .GT. 0, printing is done with 132 columns.   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphivout_(integer *lout, integer *n, integer *ix, integer *
	idigit, char *ifmt, ftnlen ifmt_len)
{
    /* Format strings */
    static char fmt_2000[] = "(/1x,a/1x,a)";
    static char fmt_1000[] = "(1x,i4,\002 - \002,i4,\002:\002,20(1x,i5))";
    static char fmt_1001[] = "(1x,i4,\002 - \002,i4,\002:\002,15(1x,i7))";
    static char fmt_1002[] = "(1x,i4,\002 - \002,i4,\002:\002,10(1x,i11))";
    static char fmt_1003[] = "(1x,i4,\002 - \002,i4,\002:\002,7(1x,i15))";
    static char fmt_1004[] = "(1x,\002 \002)";

    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Builtin functions */
    integer i_len(char *, ftnlen), s_wsfe(cilist *), do_fio(integer *, char *,
	     ftnlen), e_wsfe(void);

    /* Local variables */
    integer i__, k1, k2, lll;
    char line[80];
    integer ndigit;

    /* Fortran I/O blocks */
    static cilist io___4 = { 0, 0, 0, fmt_2000, 0 };
    static cilist io___8 = { 0, 0, 0, fmt_1000, 0 };
    static cilist io___9 = { 0, 0, 0, fmt_1001, 0 };
    static cilist io___10 = { 0, 0, 0, fmt_1002, 0 };
    static cilist io___11 = { 0, 0, 0, fmt_1003, 0 };
    static cilist io___12 = { 0, 0, 0, fmt_1000, 0 };
    static cilist io___13 = { 0, 0, 0, fmt_1001, 0 };
    static cilist io___14 = { 0, 0, 0, fmt_1002, 0 };
    static cilist io___15 = { 0, 0, 0, fmt_1003, 0 };
    static cilist io___16 = { 0, 0, 0, fmt_1004, 0 };


/*     ...   
       ... SPECIFICATIONS FOR ARGUMENTS   
       ...   
       ... SPECIFICATIONS FOR LOCAL VARIABLES   
       ...   
       ... SPECIFICATIONS INTRINSICS   


       Parameter adjustments */
    --ix;

    /* Function Body   
   Computing MIN */
    i__1 = i_len(ifmt, ifmt_len);
    lll = min(i__1,80);
    i__1 = lll;
    for (i__ = 1; i__ <= i__1; ++i__) {
	*(unsigned char *)&line[i__ - 1] = '-';
/* L1: */
    }

    for (i__ = lll + 1; i__ <= 80; ++i__) {
	*(unsigned char *)&line[i__ - 1] = ' ';
/* L2: */
    }

    io___4.ciunit = *lout;
    s_wsfe(&io___4);
    do_fio(&dgesv__c__1, ifmt, ifmt_len);
    do_fio(&dgesv__c__1, line, lll);
    e_wsfe();

    if (*n <= 0) {
	return 0;
    }
    ndigit = *idigit;
    if (*idigit == 0) {
	ndigit = 4;
    }

/* =======================================================================   
               CODE FOR OUTPUT USING 72 COLUMNS FORMAT   
   ======================================================================= */

    if (*idigit < 0) {

	ndigit = -(*idigit);
	if (ndigit <= 4) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 10) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 9;
		k2 = min(i__2,i__3);
		io___8.ciunit = *lout;
		s_wsfe(&io___8);
		do_fio(&dgesv__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgesv__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgesv__c__1, (char *)&ix[i__], (ftnlen)sizeof(integer));
		}
		e_wsfe();
/* L10: */
	    }

	} else if (ndigit <= 6) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 7) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 6;
		k2 = min(i__2,i__3);
		io___9.ciunit = *lout;
		s_wsfe(&io___9);
		do_fio(&dgesv__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgesv__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgesv__c__1, (char *)&ix[i__], (ftnlen)sizeof(integer));
		}
		e_wsfe();
/* L30: */
	    }

	} else if (ndigit <= 10) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 5) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 4;
		k2 = min(i__2,i__3);
		io___10.ciunit = *lout;
		s_wsfe(&io___10);
		do_fio(&dgesv__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgesv__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgesv__c__1, (char *)&ix[i__], (ftnlen)sizeof(integer));
		}
		e_wsfe();
/* L50: */
	    }

	} else {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 3) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 2;
		k2 = min(i__2,i__3);
		io___11.ciunit = *lout;
		s_wsfe(&io___11);
		do_fio(&dgesv__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgesv__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgesv__c__1, (char *)&ix[i__], (ftnlen)sizeof(integer));
		}
		e_wsfe();
/* L70: */
	    }
	}

/* =======================================================================   
               CODE FOR OUTPUT USING 132 COLUMNS FORMAT   
   ======================================================================= */

    } else {

	if (ndigit <= 4) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 20) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 19;
		k2 = min(i__2,i__3);
		io___12.ciunit = *lout;
		s_wsfe(&io___12);
		do_fio(&dgesv__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgesv__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgesv__c__1, (char *)&ix[i__], (ftnlen)sizeof(integer));
		}
		e_wsfe();
/* L90: */
	    }

	} else if (ndigit <= 6) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 15) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 14;
		k2 = min(i__2,i__3);
		io___13.ciunit = *lout;
		s_wsfe(&io___13);
		do_fio(&dgesv__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgesv__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgesv__c__1, (char *)&ix[i__], (ftnlen)sizeof(integer));
		}
		e_wsfe();
/* L110: */
	    }

	} else if (ndigit <= 10) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 10) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 9;
		k2 = min(i__2,i__3);
		io___14.ciunit = *lout;
		s_wsfe(&io___14);
		do_fio(&dgesv__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgesv__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgesv__c__1, (char *)&ix[i__], (ftnlen)sizeof(integer));
		}
		e_wsfe();
/* L130: */
	    }

	} else {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 7) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 6;
		k2 = min(i__2,i__3);
		io___15.ciunit = *lout;
		s_wsfe(&io___15);
		do_fio(&dgesv__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgesv__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgesv__c__1, (char *)&ix[i__], (ftnlen)sizeof(integer));
		}
		e_wsfe();
/* L150: */
	    }
	}
    }
    io___16.ciunit = *lout;
    s_wsfe(&io___16);
    e_wsfe();


    return 0;
} /* igraphivout_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Subroutine */ int igraphsecond_(real *t)
{
    real t1;
    extern doublereal etime_(real *);
    real tarray[2];



/*  -- LAPACK auxiliary routine (preliminary version) --   
       Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,   
       Courant Institute, Argonne National Lab, and Rice University   
       July 26, 1991   

    Purpose   
    =======   

    SECOND returns the user time for a process in seconds.   
    This version gets the time from the system function ETIME. */


    t1 = etime_(tarray);
    *t = tarray[0];
    return 0;

/*     End of SECOND */

} /* igraphsecond_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer dgetrf__c__1 = 1;

/* -----------------------------------------------------------------------   
    Routine:    DVOUT   

    Purpose:    Real vector output routine.   

    Usage:      CALL DVOUT (LOUT, N, SX, IDIGIT, IFMT)   

    Arguments   
       N      - Length of array SX.  (Input)   
       SX     - Real array to be printed.  (Input)   
       IFMT   - Format to be used in printing array SX.  (Input)   
       IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)   
                If IDIGIT .LT. 0, printing is done with 72 columns.   
                If IDIGIT .GT. 0, printing is done with 132 columns.   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdvout_(integer *lout, integer *n, doublereal *sx, 
	integer *idigit, char *ifmt, ftnlen ifmt_len)
{
    /* Format strings */
    static char fmt_9999[] = "(/1x,a,/1x,a)";
    static char fmt_9998[] = "(1x,i4,\002 - \002,i4,\002:\002,1p,10d12.3)";
    static char fmt_9997[] = "(1x,i4,\002 - \002,i4,\002:\002,1x,1p,8d14.5)";
    static char fmt_9996[] = "(1x,i4,\002 - \002,i4,\002:\002,1x,1p,6d18.9)";
    static char fmt_9995[] = "(1x,i4,\002 - \002,i4,\002:\002,1x,1p,5d24.13)";
    static char fmt_9994[] = "(1x,\002 \002)";

    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Builtin functions */
    integer i_len(char *, ftnlen), s_wsfe(cilist *), do_fio(integer *, char *,
	     ftnlen), e_wsfe(void);

    /* Local variables */
    integer i__, k1, k2, lll;
    char line[80];
    integer ndigit;

    /* Fortran I/O blocks */
    static cilist io___4 = { 0, 0, 0, fmt_9999, 0 };
    static cilist io___8 = { 0, 0, 0, fmt_9998, 0 };
    static cilist io___9 = { 0, 0, 0, fmt_9997, 0 };
    static cilist io___10 = { 0, 0, 0, fmt_9996, 0 };
    static cilist io___11 = { 0, 0, 0, fmt_9995, 0 };
    static cilist io___12 = { 0, 0, 0, fmt_9998, 0 };
    static cilist io___13 = { 0, 0, 0, fmt_9997, 0 };
    static cilist io___14 = { 0, 0, 0, fmt_9996, 0 };
    static cilist io___15 = { 0, 0, 0, fmt_9995, 0 };
    static cilist io___16 = { 0, 0, 0, fmt_9994, 0 };


/*     ...   
       ... SPECIFICATIONS FOR ARGUMENTS   
       ...   
       ... SPECIFICATIONS FOR LOCAL VARIABLES   
       ...   
       ... FIRST EXECUTABLE STATEMENT   


       Parameter adjustments */
    --sx;

    /* Function Body   
   Computing MIN */
    i__1 = i_len(ifmt, ifmt_len);
    lll = min(i__1,80);
    i__1 = lll;
    for (i__ = 1; i__ <= i__1; ++i__) {
	*(unsigned char *)&line[i__ - 1] = '-';
/* L10: */
    }

    for (i__ = lll + 1; i__ <= 80; ++i__) {
	*(unsigned char *)&line[i__ - 1] = ' ';
/* L20: */
    }

    io___4.ciunit = *lout;
    s_wsfe(&io___4);
    do_fio(&dgetrf__c__1, ifmt, ifmt_len);
    do_fio(&dgetrf__c__1, line, lll);
    e_wsfe();

    if (*n <= 0) {
	return 0;
    }
    ndigit = *idigit;
    if (*idigit == 0) {
	ndigit = 4;
    }

/* =======================================================================   
               CODE FOR OUTPUT USING 72 COLUMNS FORMAT   
   ======================================================================= */

    if (*idigit < 0) {
	ndigit = -(*idigit);
	if (ndigit <= 4) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 5) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 4;
		k2 = min(i__2,i__3);
		io___8.ciunit = *lout;
		s_wsfe(&io___8);
		do_fio(&dgetrf__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgetrf__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgetrf__c__1, (char *)&sx[i__], (ftnlen)sizeof(doublereal)
			    );
		}
		e_wsfe();
/* L30: */
	    }
	} else if (ndigit <= 6) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 4) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 3;
		k2 = min(i__2,i__3);
		io___9.ciunit = *lout;
		s_wsfe(&io___9);
		do_fio(&dgetrf__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgetrf__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgetrf__c__1, (char *)&sx[i__], (ftnlen)sizeof(doublereal)
			    );
		}
		e_wsfe();
/* L40: */
	    }
	} else if (ndigit <= 10) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 3) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 2;
		k2 = min(i__2,i__3);
		io___10.ciunit = *lout;
		s_wsfe(&io___10);
		do_fio(&dgetrf__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgetrf__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgetrf__c__1, (char *)&sx[i__], (ftnlen)sizeof(doublereal)
			    );
		}
		e_wsfe();
/* L50: */
	    }
	} else {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 2) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 1;
		k2 = min(i__2,i__3);
		io___11.ciunit = *lout;
		s_wsfe(&io___11);
		do_fio(&dgetrf__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgetrf__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgetrf__c__1, (char *)&sx[i__], (ftnlen)sizeof(doublereal)
			    );
		}
		e_wsfe();
/* L60: */
	    }
	}

/* =======================================================================   
               CODE FOR OUTPUT USING 132 COLUMNS FORMAT   
   ======================================================================= */

    } else {
	if (ndigit <= 4) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 10) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 9;
		k2 = min(i__2,i__3);
		io___12.ciunit = *lout;
		s_wsfe(&io___12);
		do_fio(&dgetrf__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgetrf__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgetrf__c__1, (char *)&sx[i__], (ftnlen)sizeof(doublereal)
			    );
		}
		e_wsfe();
/* L70: */
	    }
	} else if (ndigit <= 6) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 8) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 7;
		k2 = min(i__2,i__3);
		io___13.ciunit = *lout;
		s_wsfe(&io___13);
		do_fio(&dgetrf__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgetrf__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgetrf__c__1, (char *)&sx[i__], (ftnlen)sizeof(doublereal)
			    );
		}
		e_wsfe();
/* L80: */
	    }
	} else if (ndigit <= 10) {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 6) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 5;
		k2 = min(i__2,i__3);
		io___14.ciunit = *lout;
		s_wsfe(&io___14);
		do_fio(&dgetrf__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgetrf__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgetrf__c__1, (char *)&sx[i__], (ftnlen)sizeof(doublereal)
			    );
		}
		e_wsfe();
/* L90: */
	    }
	} else {
	    i__1 = *n;
	    for (k1 = 1; k1 <= i__1; k1 += 5) {
/* Computing MIN */
		i__2 = *n, i__3 = k1 + 4;
		k2 = min(i__2,i__3);
		io___15.ciunit = *lout;
		s_wsfe(&io___15);
		do_fio(&dgetrf__c__1, (char *)&k1, (ftnlen)sizeof(integer));
		do_fio(&dgetrf__c__1, (char *)&k2, (ftnlen)sizeof(integer));
		i__2 = k2;
		for (i__ = k1; i__ <= i__2; ++i__) {
		    do_fio(&dgetrf__c__1, (char *)&sx[i__], (ftnlen)sizeof(doublereal)
			    );
		}
		e_wsfe();
/* L100: */
	    }
	}
    }
    io___16.ciunit = *lout;
    s_wsfe(&io___16);
    e_wsfe();
    return 0;
} /* igraphdvout_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer dgetrs__c__1 = 1;
static logical dgetrs__c_false = FALSE_;
static doublereal dgetrs__c_b25 = 1.;
static doublereal dgetrs__c_b47 = 0.;
static doublereal dgetrs__c_b50 = -1.;
static integer dgetrs__c__2 = 2;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dnaitr   

   \Description:   
    Reverse communication interface for applying NP additional steps to   
    a K step nonsymmetric Arnoldi factorization.   

    Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T   

            with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.   

    Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T   

            with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.   

    where OP and B are as in dnaupd.  The B-norm of r_{k+p} is also   
    computed and returned.   

   \Usage:   
    call dnaitr   
       ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH,   
         IPNTR, WORKD, INFO )   

   \Arguments   
    IDO     Integer.  (INPUT/OUTPUT)   
            Reverse communication flag.   
            -------------------------------------------------------------   
            IDO =  0: first call to the reverse communication interface   
            IDO = -1: compute  Y = OP * X  where   
                      IPNTR(1) is the pointer into WORK for X,   
                      IPNTR(2) is the pointer into WORK for Y.   
                      This is for the restart phase to force the new   
                      starting vector into the range of OP.   
            IDO =  1: compute  Y = OP * X  where   
                      IPNTR(1) is the pointer into WORK for X,   
                      IPNTR(2) is the pointer into WORK for Y,   
                      IPNTR(3) is the pointer into WORK for B * X.   
            IDO =  2: compute  Y = B * X  where   
                      IPNTR(1) is the pointer into WORK for X,   
                      IPNTR(2) is the pointer into WORK for Y.   
            IDO = 99: done   
            -------------------------------------------------------------   
            When the routine is used in the "shift-and-invert" mode, the   
            vector B * Q is already available and do not need to be   
            recompute in forming OP * Q.   

    BMAT    Character*1.  (INPUT)   
            BMAT specifies the type of the matrix B that defines the   
            semi-inner product for the operator OP.  See dnaupd.   
            B = 'I' -> standard eigenvalue problem A*x = lambda*x   
            B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x   

    N       Integer.  (INPUT)   
            Dimension of the eigenproblem.   

    K       Integer.  (INPUT)   
            Current size of V and H.   

    NP      Integer.  (INPUT)   
            Number of additional Arnoldi steps to take.   

    NB      Integer.  (INPUT)   
            Blocksize to be used in the recurrence.   
            Only work for NB = 1 right now.  The goal is to have a   
            program that implement both the block and non-block method.   

    RESID   Double precision array of length N.  (INPUT/OUTPUT)   
            On INPUT:  RESID contains the residual vector r_{k}.   
            On OUTPUT: RESID contains the residual vector r_{k+p}.   

    RNORM   Double precision scalar.  (INPUT/OUTPUT)   
            B-norm of the starting residual on input.   
            B-norm of the updated residual r_{k+p} on output.   

    V       Double precision N by K+NP array.  (INPUT/OUTPUT)   
            On INPUT:  V contains the Arnoldi vectors in the first K   
            columns.   
            On OUTPUT: V contains the new NP Arnoldi vectors in the next   
            NP columns.  The first K columns are unchanged.   

    LDV     Integer.  (INPUT)   
            Leading dimension of V exactly as declared in the calling   
            program.   

    H       Double precision (K+NP) by (K+NP) array.  (INPUT/OUTPUT)   
            H is used to store the generated upper Hessenberg matrix.   

    LDH     Integer.  (INPUT)   
            Leading dimension of H exactly as declared in the calling   
            program.   

    IPNTR   Integer array of length 3.  (OUTPUT)   
            Pointer to mark the starting locations in the WORK for   
            vectors used by the Arnoldi iteration.   
            -------------------------------------------------------------   
            IPNTR(1): pointer to the current operand vector X.   
            IPNTR(2): pointer to the current result vector Y.   
            IPNTR(3): pointer to the vector B * X when used in the   
                      shift-and-invert mode.  X is the current operand.   
            -------------------------------------------------------------   

    WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)   
            Distributed array to be used in the basic Arnoldi iteration   
            for reverse communication.  The calling program should not   
            use WORKD as temporary workspace during the iteration !!!!!!   
            On input, WORKD(1:N) = B*RESID and is used to save some   
            computation at the first step.   

    INFO    Integer.  (OUTPUT)   
            = 0: Normal exit.   
            > 0: Size of the spanning invariant subspace of OP found.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \References:   
    1. D.C. Sorensen, "Implicit Application of Polynomial Filters in   
       a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),   
       pp 357-385.   
    2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly   
       Restarted Arnoldi Iteration", Rice University Technical Report   
       TR95-13, Department of Computational and Applied Mathematics.   

   \Routines called:   
       dgetv0  ARPACK routine to generate the initial vector.   
       ivout   ARPACK utility routine that prints integers.   
       second  ARPACK utility routine for timing.   
       dmout   ARPACK utility routine that prints matrices   
       dvout   ARPACK utility routine that prints vectors.   
       dlabad  LAPACK routine that computes machine constants.   
       dlamch  LAPACK routine that determines machine constants.   
       dlascl  LAPACK routine for careful scaling of a matrix.   
       dlanhs  LAPACK routine that computes various norms of a matrix.   
       dgemv   Level 2 BLAS routine for matrix vector multiplication.   
       daxpy   Level 1 BLAS that computes a vector triad.   
       dscal   Level 1 BLAS that scales a vector.   
       dcopy   Level 1 BLAS that copies one vector to another .   
       ddot    Level 1 BLAS that computes the scalar product of two vectors.   
       dnrm2   Level 1 BLAS that computes the norm of a vector.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       xx/xx/92: Version ' 2.4'   

   \SCCS Information: @(#)   
   FILE: naitr.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2   

   \Remarks   
    The algorithm implemented is:   

    restart = .false.   
    Given V_{k} = [v_{1}, ..., v_{k}], r_{k};   
    r_{k} contains the initial residual vector even for k = 0;   
    Also assume that rnorm = || B*r_{k} || and B*r_{k} are already   
    computed by the calling program.   

    betaj = rnorm ; p_{k+1} = B*r_{k} ;   
    For  j = k+1, ..., k+np  Do   
       1) if ( betaj < tol ) stop or restart depending on j.   
          ( At present tol is zero )   
          if ( restart ) generate a new starting vector.   
       2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];   
          p_{j} = p_{j}/betaj   
       3) r_{j} = OP*v_{j} where OP is defined as in dnaupd   
          For shift-invert mode p_{j} = B*v_{j} is already available.   
          wnorm = || OP*v_{j} ||   
       4) Compute the j-th step residual vector.   
          w_{j} =  V_{j}^T * B * OP * v_{j}   
          r_{j} =  OP*v_{j} - V_{j} * w_{j}   
          H(:,j) = w_{j};   
          H(j,j-1) = rnorm   
          rnorm = || r_(j) ||   
          If (rnorm > 0.717*wnorm) accept step and go back to 1)   
       5) Re-orthogonalization step:   
          s = V_{j}'*B*r_{j}   
          r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||   
          alphaj = alphaj + s_{j};   
       6) Iterative refinement step:   
          If (rnorm1 > 0.717*rnorm) then   
             rnorm = rnorm1   
             accept step and go back to 1)   
          Else   
             rnorm = rnorm1   
             If this is the first time in step 6), go to 5)   
             Else r_{j} lies in the span of V_{j} numerically.   
                Set r_{j} = 0 and rnorm = 0; go to 1)   
          EndIf   
    End Do   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdnaitr_(integer *ido, char *bmat, integer *n, integer *k,
	 integer *np, integer *nb, doublereal *resid, doublereal *rnorm, 
	doublereal *v, integer *ldv, doublereal *h__, integer *ldh, integer *
	ipntr, doublereal *workd, integer *info)
{
    /* Initialized data */

    IGRAPH_F77_SAVE logical first = TRUE_;

    /* System generated locals */
    integer h_dim1, h_offset, v_dim1, v_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    integer i__;
    IGRAPH_F77_SAVE integer j;
    real t0, t1, t2 = 0, t3, t4, t5;
    integer jj;
    IGRAPH_F77_SAVE integer ipj, irj;
    integer nbx = 0;
    IGRAPH_F77_SAVE integer ivj;
    IGRAPH_F77_SAVE doublereal ulp;
    doublereal tst1;
    extern doublereal igraphddot_(integer *, doublereal *, integer *, doublereal *, 
	    integer *);
    IGRAPH_F77_SAVE integer ierr, iter;
    IGRAPH_F77_SAVE doublereal unfl, ovfl;
    integer nopx = 0;
    IGRAPH_F77_SAVE integer itry;
    extern doublereal igraphdnrm2_(integer *, doublereal *, integer *);
    doublereal temp1;
    IGRAPH_F77_SAVE logical orth1, orth2, step3, step4;
    IGRAPH_F77_SAVE doublereal betaj;
    extern /* Subroutine */ int igraphdscal_(integer *, doublereal *, doublereal *, 
	    integer *), igraphdgemv_(char *, integer *, integer *, doublereal *, 
	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
	    doublereal *, integer *);
    integer infol;
    extern /* Subroutine */ int igraphdcopy_(integer *, doublereal *, integer *, 
	    doublereal *, integer *), igraphdmout_(integer 
	    *, integer *, integer *, doublereal *, integer *, integer *, char 
	    *, ftnlen);
    doublereal xtemp[2];
    real tmvbx = 0;
    extern /* Subroutine */ int igraphdvout_(integer *, integer *, doublereal *, 
	    integer *, char *, ftnlen);
    IGRAPH_F77_SAVE doublereal wnorm;
    extern /* Subroutine */ int igraphivout_(integer *, integer *, integer *, 
	    integer *, char *, ftnlen), igraphdgetv0_(integer *, char *, integer *, 
	    logical *, integer *, integer *, doublereal *, integer *, 
	    doublereal *, doublereal *, integer *, doublereal *, integer *), igraphdlabad_(doublereal *, doublereal *);
    IGRAPH_F77_SAVE doublereal rnorm1;
    extern doublereal igraphdlamch_(char *);
    extern /* Subroutine */ int igraphdlascl_(char *, integer *, integer *, 
	    doublereal *, doublereal *, integer *, integer *, doublereal *, 
	    integer *, integer *);
    extern doublereal igraphdlanhs_(char *, integer *, doublereal *, integer *, 
	    doublereal *);
    extern /* Subroutine */ int igraphsecond_(real *);
    integer logfil, ndigit, nitref = 0, mnaitr = 0;
    real titref = 0, tnaitr = 0;
    IGRAPH_F77_SAVE integer msglvl;
    IGRAPH_F77_SAVE doublereal smlnum;
    integer nrorth = 0;
    IGRAPH_F77_SAVE logical rstart;
    integer nrstrt = 0;
    real tmvopx = 0;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %-----------------------%   
       | Local Array Arguments |   
       %-----------------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %---------------------%   
       | Intrinsic Functions |   
       %---------------------%   


       %-----------------%   
       | Data statements |   
       %-----------------%   

       Parameter adjustments */
    --workd;
    --resid;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --ipntr;

    /* Function Body   

       %-----------------------%   
       | Executable Statements |   
       %-----------------------% */

    if (first) {

/*        %-----------------------------------------%   
          | Set machine-dependent constants for the |   
          | the splitting and deflation criterion.  |   
          | If norm(H) <= sqrt(OVFL),               |   
          | overflow should not occur.              |   
          | REFERENCE: LAPACK subroutine dlahqr     |   
          %-----------------------------------------% */

	unfl = igraphdlamch_("safe minimum");
	ovfl = 1. / unfl;
	igraphdlabad_(&unfl, &ovfl);
	ulp = igraphdlamch_("precision");
	smlnum = unfl * (*n / ulp);
	first = FALSE_;
    }

    if (*ido == 0) {

/*        %-------------------------------%   
          | Initialize timing statistics  |   
          | & message level for debugging |   
          %-------------------------------% */

	igraphsecond_(&t0);
	msglvl = mnaitr;

/*        %------------------------------%   
          | Initial call to this routine |   
          %------------------------------% */

	*info = 0;
	step3 = FALSE_;
	step4 = FALSE_;
	rstart = FALSE_;
	orth1 = FALSE_;
	orth2 = FALSE_;
	j = *k + 1;
	ipj = 1;
	irj = ipj + *n;
	ivj = irj + *n;
    }

/*     %-------------------------------------------------%   
       | When in reverse communication mode one of:      |   
       | STEP3, STEP4, ORTH1, ORTH2, RSTART              |   
       | will be .true. when ....                        |   
       | STEP3: return from computing OP*v_{j}.          |   
       | STEP4: return from computing B-norm of OP*v_{j} |   
       | ORTH1: return from computing B-norm of r_{j+1}  |   
       | ORTH2: return from computing B-norm of          |   
       |        correction to the residual vector.       |   
       | RSTART: return from OP computations needed by   |   
       |         dgetv0.                                 |   
       %-------------------------------------------------% */

    if (step3) {
	goto L50;
    }
    if (step4) {
	goto L60;
    }
    if (orth1) {
	goto L70;
    }
    if (orth2) {
	goto L90;
    }
    if (rstart) {
	goto L30;
    }

/*     %-----------------------------%   
       | Else this is the first step |   
       %-----------------------------%   

       %--------------------------------------------------------------%   
       |                                                              |   
       |        A R N O L D I     I T E R A T I O N     L O O P       |   
       |                                                              |   
       | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |   
       %--------------------------------------------------------------% */
L1000:

    if (msglvl > 1) {
	igraphivout_(&logfil, &dgetrs__c__1, &j, &ndigit, "_naitr: generating Arnoldi vect"
		"or number", (ftnlen)40);
	igraphdvout_(&logfil, &dgetrs__c__1, rnorm, &ndigit, "_naitr: B-norm of the curren"
		"t residual is", (ftnlen)41);
    }

/*        %---------------------------------------------------%   
          | STEP 1: Check if the B norm of j-th residual      |   
          | vector is zero. Equivalent to determing whether   |   
          | an exact j-step Arnoldi factorization is present. |   
          %---------------------------------------------------% */

    betaj = *rnorm;
    if (*rnorm > 0.) {
	goto L40;
    }

/*           %---------------------------------------------------%   
             | Invariant subspace found, generate a new starting |   
             | vector which is orthogonal to the current Arnoldi |   
             | basis and continue the iteration.                 |   
             %---------------------------------------------------% */

    if (msglvl > 0) {
	igraphivout_(&logfil, &dgetrs__c__1, &j, &ndigit, "_naitr: ****** RESTART AT STEP "
		"******", (ftnlen)37);
    }

/*           %---------------------------------------------%   
             | ITRY is the loop variable that controls the |   
             | maximum amount of times that a restart is   |   
             | attempted. NRSTRT is used by stat.h         |   
             %---------------------------------------------% */

    betaj = 0.;
    ++nrstrt;
    itry = 1;
L20:
    rstart = TRUE_;
    *ido = 0;
L30:

/*           %--------------------------------------%   
             | If in reverse communication mode and |   
             | RSTART = .true. flow returns here.   |   
             %--------------------------------------% */

    igraphdgetv0_(ido, bmat, &itry, &dgetrs__c_false, n, &j, &v[v_offset], ldv, &resid[1], 
	    rnorm, &ipntr[1], &workd[1], &ierr);
    if (*ido != 99) {
	goto L9000;
    }
    if (ierr < 0) {
	++itry;
	if (itry <= 3) {
	    goto L20;
	}

/*              %------------------------------------------------%   
                | Give up after several restart attempts.        |   
                | Set INFO to the size of the invariant subspace |   
                | which spans OP and exit.                       |   
                %------------------------------------------------% */

	*info = j - 1;
	igraphsecond_(&t1);
	tnaitr += t1 - t0;
	*ido = 99;
	goto L9000;
    }

L40:

/*        %---------------------------------------------------------%   
          | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |   
          | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |   
          | when reciprocating a small RNORM, test against lower    |   
          | machine bound.                                          |   
          %---------------------------------------------------------% */

    igraphdcopy_(n, &resid[1], &dgetrs__c__1, &v[j * v_dim1 + 1], &dgetrs__c__1);
    if (*rnorm >= unfl) {
	temp1 = 1. / *rnorm;
	igraphdscal_(n, &temp1, &v[j * v_dim1 + 1], &dgetrs__c__1);
	igraphdscal_(n, &temp1, &workd[ipj], &dgetrs__c__1);
    } else {

/*            %-----------------------------------------%   
              | To scale both v_{j} and p_{j} carefully |   
              | use LAPACK routine SLASCL               |   
              %-----------------------------------------% */

	igraphdlascl_("General", &i__, &i__, rnorm, &dgetrs__c_b25, n, &dgetrs__c__1, &v[j * v_dim1 
		+ 1], n, &infol);
	igraphdlascl_("General", &i__, &i__, rnorm, &dgetrs__c_b25, n, &dgetrs__c__1, &workd[ipj], 
		n, &infol);
    }

/*        %------------------------------------------------------%   
          | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |   
          | Note that this is not quite yet r_{j}. See STEP 4    |   
          %------------------------------------------------------% */

    step3 = TRUE_;
    ++nopx;
    igraphsecond_(&t2);
    igraphdcopy_(n, &v[j * v_dim1 + 1], &dgetrs__c__1, &workd[ivj], &dgetrs__c__1);
    ipntr[1] = ivj;
    ipntr[2] = irj;
    ipntr[3] = ipj;
    *ido = 1;

/*        %-----------------------------------%   
          | Exit in order to compute OP*v_{j} |   
          %-----------------------------------% */

    goto L9000;
L50:

/*        %----------------------------------%   
          | Back from reverse communication; |   
          | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |   
          | if step3 = .true.                |   
          %----------------------------------% */

    igraphsecond_(&t3);
    tmvopx += t3 - t2;
    step3 = FALSE_;

/*        %------------------------------------------%   
          | Put another copy of OP*v_{j} into RESID. |   
          %------------------------------------------% */

    igraphdcopy_(n, &workd[irj], &dgetrs__c__1, &resid[1], &dgetrs__c__1);

/*        %---------------------------------------%   
          | STEP 4:  Finish extending the Arnoldi |   
          |          factorization to length j.   |   
          %---------------------------------------% */

    igraphsecond_(&t2);
    if (*(unsigned char *)bmat == 'G') {
	++nbx;
	step4 = TRUE_;
	ipntr[1] = irj;
	ipntr[2] = ipj;
	*ido = 2;

/*           %-------------------------------------%   
             | Exit in order to compute B*OP*v_{j} |   
             %-------------------------------------% */

	goto L9000;
    } else if (*(unsigned char *)bmat == 'I') {
	igraphdcopy_(n, &resid[1], &dgetrs__c__1, &workd[ipj], &dgetrs__c__1);
    }
L60:

/*        %----------------------------------%   
          | Back from reverse communication; |   
          | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |   
          | if step4 = .true.                |   
          %----------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvbx += t3 - t2;
    }

    step4 = FALSE_;

/*        %-------------------------------------%   
          | The following is needed for STEP 5. |   
          | Compute the B-norm of OP*v_{j}.     |   
          %-------------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	wnorm = igraphddot_(n, &resid[1], &dgetrs__c__1, &workd[ipj], &dgetrs__c__1);
	wnorm = sqrt((abs(wnorm)));
    } else if (*(unsigned char *)bmat == 'I') {
	wnorm = igraphdnrm2_(n, &resid[1], &dgetrs__c__1);
    }

/*        %-----------------------------------------%   
          | Compute the j-th residual corresponding |   
          | to the j step factorization.            |   
          | Use Classical Gram Schmidt and compute: |   
          | w_{j} <-  V_{j}^T * B * OP * v_{j}      |   
          | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |   
          %-----------------------------------------%   


          %------------------------------------------%   
          | Compute the j Fourier coefficients w_{j} |   
          | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |   
          %------------------------------------------% */

    igraphdgemv_("T", n, &j, &dgetrs__c_b25, &v[v_offset], ldv, &workd[ipj], &dgetrs__c__1, &dgetrs__c_b47, 
	    &h__[j * h_dim1 + 1], &dgetrs__c__1);

/*        %--------------------------------------%   
          | Orthogonalize r_{j} against V_{j}.   |   
          | RESID contains OP*v_{j}. See STEP 3. |   
          %--------------------------------------% */

    igraphdgemv_("N", n, &j, &dgetrs__c_b50, &v[v_offset], ldv, &h__[j * h_dim1 + 1], &dgetrs__c__1,
	     &dgetrs__c_b25, &resid[1], &dgetrs__c__1);

    if (j > 1) {
	h__[j + (j - 1) * h_dim1] = betaj;
    }

    igraphsecond_(&t4);

    orth1 = TRUE_;

    igraphsecond_(&t2);
    if (*(unsigned char *)bmat == 'G') {
	++nbx;
	igraphdcopy_(n, &resid[1], &dgetrs__c__1, &workd[irj], &dgetrs__c__1);
	ipntr[1] = irj;
	ipntr[2] = ipj;
	*ido = 2;

/*           %----------------------------------%   
             | Exit in order to compute B*r_{j} |   
             %----------------------------------% */

	goto L9000;
    } else if (*(unsigned char *)bmat == 'I') {
	igraphdcopy_(n, &resid[1], &dgetrs__c__1, &workd[ipj], &dgetrs__c__1);
    }
L70:

/*        %---------------------------------------------------%   
          | Back from reverse communication if ORTH1 = .true. |   
          | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |   
          %---------------------------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvbx += t3 - t2;
    }

    orth1 = FALSE_;

/*        %------------------------------%   
          | Compute the B-norm of r_{j}. |   
          %------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	*rnorm = igraphddot_(n, &resid[1], &dgetrs__c__1, &workd[ipj], &dgetrs__c__1);
	*rnorm = sqrt((abs(*rnorm)));
    } else if (*(unsigned char *)bmat == 'I') {
	*rnorm = igraphdnrm2_(n, &resid[1], &dgetrs__c__1);
    }

/*        %-----------------------------------------------------------%   
          | STEP 5: Re-orthogonalization / Iterative refinement phase |   
          | Maximum NITER_ITREF tries.                                |   
          |                                                           |   
          |          s      = V_{j}^T * B * r_{j}                     |   
          |          r_{j}  = r_{j} - V_{j}*s                         |   
          |          alphaj = alphaj + s_{j}                          |   
          |                                                           |   
          | The stopping criteria used for iterative refinement is    |   
          | discussed in Parlett's book SEP, page 107 and in Gragg &  |   
          | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |   
          | Determine if we need to correct the residual. The goal is |   
          | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |   
          | The following test determines whether the sine of the     |   
          | angle between  OP*x and the computed residual is less     |   
          | than or equal to 0.717.                                   |   
          %-----------------------------------------------------------% */

    if (*rnorm > wnorm * .717f) {
	goto L100;
    }
    iter = 0;
    ++nrorth;

/*        %---------------------------------------------------%   
          | Enter the Iterative refinement phase. If further  |   
          | refinement is necessary, loop back here. The loop |   
          | variable is ITER. Perform a step of Classical     |   
          | Gram-Schmidt using all the Arnoldi vectors V_{j}  |   
          %---------------------------------------------------% */

L80:

    if (msglvl > 2) {
	xtemp[0] = wnorm;
	xtemp[1] = *rnorm;
	igraphdvout_(&logfil, &dgetrs__c__2, xtemp, &ndigit, "_naitr: re-orthonalization; "
		"wnorm and rnorm are", (ftnlen)47);
	igraphdvout_(&logfil, &j, &h__[j * h_dim1 + 1], &ndigit, "_naitr: j-th col"
		"umn of H", (ftnlen)24);
    }

/*        %----------------------------------------------------%   
          | Compute V_{j}^T * B * r_{j}.                       |   
          | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |   
          %----------------------------------------------------% */

    igraphdgemv_("T", n, &j, &dgetrs__c_b25, &v[v_offset], ldv, &workd[ipj], &dgetrs__c__1, &dgetrs__c_b47, 
	    &workd[irj], &dgetrs__c__1);

/*        %---------------------------------------------%   
          | Compute the correction to the residual:     |   
          | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |   
          | The correction to H is v(:,1:J)*H(1:J,1:J)  |   
          | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |   
          %---------------------------------------------% */

    igraphdgemv_("N", n, &j, &dgetrs__c_b50, &v[v_offset], ldv, &workd[irj], &dgetrs__c__1, &dgetrs__c_b25, 
	    &resid[1], &dgetrs__c__1);
    //igraphdaxpy_(&j, &dgetrs__c_b25, &workd[irj], &dgetrs__c__1, &h__[j * h_dim1 + 1], &dgetrs__c__1);
    cblas_daxpy(&j, dgetrs__c_b25, &workd[irj], 1, &h__[j * h_dim1 + 1], 1);

    orth2 = TRUE_;
    igraphsecond_(&t2);
    if (*(unsigned char *)bmat == 'G') {
	++nbx;
	igraphdcopy_(n, &resid[1], &dgetrs__c__1, &workd[irj], &dgetrs__c__1);
	ipntr[1] = irj;
	ipntr[2] = ipj;
	*ido = 2;

/*           %-----------------------------------%   
             | Exit in order to compute B*r_{j}. |   
             | r_{j} is the corrected residual.  |   
             %-----------------------------------% */

	goto L9000;
    } else if (*(unsigned char *)bmat == 'I') {
	igraphdcopy_(n, &resid[1], &dgetrs__c__1, &workd[ipj], &dgetrs__c__1);
    }
L90:

/*        %---------------------------------------------------%   
          | Back from reverse communication if ORTH2 = .true. |   
          %---------------------------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvbx += t3 - t2;
    }

/*        %-----------------------------------------------------%   
          | Compute the B-norm of the corrected residual r_{j}. |   
          %-----------------------------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	rnorm1 = igraphddot_(n, &resid[1], &dgetrs__c__1, &workd[ipj], &dgetrs__c__1);
	rnorm1 = sqrt((abs(rnorm1)));
    } else if (*(unsigned char *)bmat == 'I') {
	rnorm1 = igraphdnrm2_(n, &resid[1], &dgetrs__c__1);
    }

    if (msglvl > 0 && iter > 0) {
	igraphivout_(&logfil, &dgetrs__c__1, &j, &ndigit, "_naitr: Iterative refinement fo"
		"r Arnoldi residual", (ftnlen)49);
	if (msglvl > 2) {
	    xtemp[0] = *rnorm;
	    xtemp[1] = rnorm1;
	    igraphdvout_(&logfil, &dgetrs__c__2, xtemp, &ndigit, "_naitr: iterative refine"
		    "ment ; rnorm and rnorm1 are", (ftnlen)51);
	}
    }

/*        %-----------------------------------------%   
          | Determine if we need to perform another |   
          | step of re-orthogonalization.           |   
          %-----------------------------------------% */

    if (rnorm1 > *rnorm * .717f) {

/*           %---------------------------------------%   
             | No need for further refinement.       |   
             | The cosine of the angle between the   |   
             | corrected residual vector and the old |   
             | residual vector is greater than 0.717 |   
             | In other words the corrected residual |   
             | and the old residual vector share an  |   
             | angle of less than arcCOS(0.717)      |   
             %---------------------------------------% */

	*rnorm = rnorm1;

    } else {

/*           %-------------------------------------------%   
             | Another step of iterative refinement step |   
             | is required. NITREF is used by stat.h     |   
             %-------------------------------------------% */

	++nitref;
	*rnorm = rnorm1;
	++iter;
	if (iter <= 1) {
	    goto L80;
	}

/*           %-------------------------------------------------%   
             | Otherwise RESID is numerically in the span of V |   
             %-------------------------------------------------% */

	i__1 = *n;
	for (jj = 1; jj <= i__1; ++jj) {
	    resid[jj] = 0.;
/* L95: */
	}
	*rnorm = 0.;
    }

/*        %----------------------------------------------%   
          | Branch here directly if iterative refinement |   
          | wasn't necessary or after at most NITER_REF  |   
          | steps of iterative refinement.               |   
          %----------------------------------------------% */

L100:

    rstart = FALSE_;
    orth2 = FALSE_;

    igraphsecond_(&t5);
    titref += t5 - t4;

/*        %------------------------------------%   
          | STEP 6: Update  j = j+1;  Continue |   
          %------------------------------------% */

    ++j;
    if (j > *k + *np) {
	igraphsecond_(&t1);
	tnaitr += t1 - t0;
	*ido = 99;
	i__1 = *k + *np - 1;
	for (i__ = max(1,*k); i__ <= i__1; ++i__) {

/*              %--------------------------------------------%   
                | Check for splitting and deflation.         |   
                | Use a standard test as in the QR algorithm |   
                | REFERENCE: LAPACK subroutine dlahqr        |   
                %--------------------------------------------% */

	    tst1 = (d__1 = h__[i__ + i__ * h_dim1], abs(d__1)) + (d__2 = h__[
		    i__ + 1 + (i__ + 1) * h_dim1], abs(d__2));
	    if (tst1 == 0.) {
		i__2 = *k + *np;
		tst1 = igraphdlanhs_("1", &i__2, &h__[h_offset], ldh, &workd[*n + 1]
			);
	    }
/* Computing MAX */
	    d__2 = ulp * tst1;
	    if ((d__1 = h__[i__ + 1 + i__ * h_dim1], abs(d__1)) <= max(d__2,
		    smlnum)) {
		h__[i__ + 1 + i__ * h_dim1] = 0.;
	    }
/* L110: */
	}

	if (msglvl > 2) {
	    i__1 = *k + *np;
	    i__2 = *k + *np;
	    igraphdmout_(&logfil, &i__1, &i__2, &h__[h_offset], ldh, &ndigit, "_na"
		    "itr: Final upper Hessenberg matrix H of order K+NP", (
		    ftnlen)53);
	}

	goto L9000;
    }

/*        %--------------------------------------------------------%   
          | Loop back to extend the factorization by another step. |   
          %--------------------------------------------------------% */

    goto L1000;

/*     %---------------------------------------------------------------%   
       |                                                               |   
       |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |   
       |                                                               |   
       %---------------------------------------------------------------% */

L9000:
    return 0;

/*     %---------------%   
       | End of dnaitr |   
       %---------------% */

} /* igraphdnaitr_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static doublereal dgetv0__c_b5 = 0.;
static doublereal dgetv0__c_b6 = 1.;
static integer dgetv0__c__1 = 1;
static doublereal dgetv0__c_b43 = -1.;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dnapps   

   \Description:   
    Given the Arnoldi factorization   

       A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,   

    apply NP implicit shifts resulting in   

       A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q   

    where Q is an orthogonal matrix which is the product of rotations   
    and reflections resulting from the NP bulge chage sweeps.   
    The updated Arnoldi factorization becomes:   

       A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.   

   \Usage:   
    call dnapps   
       ( N, KEV, NP, SHIFTR, SHIFTI, V, LDV, H, LDH, RESID, Q, LDQ,   
         WORKL, WORKD )   

   \Arguments   
    N       Integer.  (INPUT)   
            Problem size, i.e. size of matrix A.   

    KEV     Integer.  (INPUT/OUTPUT)   
            KEV+NP is the size of the input matrix H.   
            KEV is the size of the updated matrix HNEW.  KEV is only   
            updated on ouput when fewer than NP shifts are applied in   
            order to keep the conjugate pair together.   

    NP      Integer.  (INPUT)   
            Number of implicit shifts to be applied.   

    SHIFTR, Double precision array of length NP.  (INPUT)   
    SHIFTI  Real and imaginary part of the shifts to be applied.   
            Upon, entry to dnapps, the shifts must be sorted so that the   
            conjugate pairs are in consecutive locations.   

    V       Double precision N by (KEV+NP) array.  (INPUT/OUTPUT)   
            On INPUT, V contains the current KEV+NP Arnoldi vectors.   
            On OUTPUT, V contains the updated KEV Arnoldi vectors   
            in the first KEV columns of V.   

    LDV     Integer.  (INPUT)   
            Leading dimension of V exactly as declared in the calling   
            program.   

    H       Double precision (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)   
            On INPUT, H contains the current KEV+NP by KEV+NP upper   
            Hessenber matrix of the Arnoldi factorization.   
            On OUTPUT, H contains the updated KEV by KEV upper Hessenberg   
            matrix in the KEV leading submatrix.   

    LDH     Integer.  (INPUT)   
            Leading dimension of H exactly as declared in the calling   
            program.   

    RESID   Double precision array of length N.  (INPUT/OUTPUT)   
            On INPUT, RESID contains the the residual vector r_{k+p}.   
            On OUTPUT, RESID is the update residual vector rnew_{k}   
            in the first KEV locations.   

    Q       Double precision KEV+NP by KEV+NP work array.  (WORKSPACE)   
            Work array used to accumulate the rotations and reflections   
            during the bulge chase sweep.   

    LDQ     Integer.  (INPUT)   
            Leading dimension of Q exactly as declared in the calling   
            program.   

    WORKL   Double precision work array of length (KEV+NP).  (WORKSPACE)   
            Private (replicated) array on each PE or array allocated on   
            the front end.   

    WORKD   Double precision work array of length 2*N.  (WORKSPACE)   
            Distributed array used in the application of the accumulated   
            orthogonal matrix Q.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \References:   
    1. D.C. Sorensen, "Implicit Application of Polynomial Filters in   
       a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),   
       pp 357-385.   

   \Routines called:   
       ivout   ARPACK utility routine that prints integers.   
       second  ARPACK utility routine for timing.   
       dmout   ARPACK utility routine that prints matrices.   
       dvout   ARPACK utility routine that prints vectors.   
       dlabad  LAPACK routine that computes machine constants.   
       dlacpy  LAPACK matrix copy routine.   
       dlamch  LAPACK routine that determines machine constants.   
       dlanhs  LAPACK routine that computes various norms of a matrix.   
       dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.   
       dlarf   LAPACK routine that applies Householder reflection to   
               a matrix.   
       dlarfg  LAPACK Householder reflection construction routine.   
       dlartg  LAPACK Givens rotation construction routine.   
       dlaset  LAPACK matrix initialization routine.   
       dgemv   Level 2 BLAS routine for matrix vector multiplication.   
       daxpy   Level 1 BLAS that computes a vector triad.   
       dcopy   Level 1 BLAS that copies one vector to another .   
       dscal   Level 1 BLAS that scales a vector.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       xx/xx/92: Version ' 2.1'   

   \SCCS Information: @(#)   
   FILE: napps.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2   

   \Remarks   
    1. In this version, each shift is applied to all the sublocks of   
       the Hessenberg matrix H and not just to the submatrix that it   
       comes from. Deflation as in LAPACK routine dlahqr (QR algorithm   
       for upper Hessenberg matrices ) is used.   
       The subdiagonals of H are enforced to be non-negative.   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdnapps_(integer *n, integer *kev, integer *np, 
	doublereal *shiftr, doublereal *shifti, doublereal *v, integer *ldv, 
	doublereal *h__, integer *ldh, doublereal *resid, doublereal *q, 
	integer *ldq, doublereal *workl, doublereal *workd)
{
    /* Initialized data */

    IGRAPH_F77_SAVE logical first = TRUE_;

    /* System generated locals */
    integer h_dim1, h_offset, v_dim1, v_offset, q_dim1, q_offset, i__1, i__2, 
	    i__3, i__4;
    doublereal d__1, d__2;

    /* Local variables */
    doublereal c__, f, g;
    integer i__, j;
    doublereal r__, s, t, u[3];
    real t0, t1;
    doublereal h11, h12, h21, h22, h32;
    integer jj, ir, nr;
    doublereal tau;
    IGRAPH_F77_SAVE doublereal ulp;
    doublereal tst1;
    integer iend;
    IGRAPH_F77_SAVE doublereal unfl, ovfl;
    extern /* Subroutine */ int igraphdscal_(integer *, doublereal *, doublereal *, 
	    integer *), igraphdlarf_(char *, integer *, integer *, doublereal *, 
	    integer *, doublereal *, doublereal *, integer *, doublereal *);
    logical cconj;
    extern /* Subroutine */ int igraphdgemv_(char *, integer *, integer *, 
	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
	    doublereal *, doublereal *, integer *), igraphdcopy_(integer *, 
	    doublereal *, integer *, doublereal *, integer *), igraphdmout_(integer *, integer *, integer *, doublereal *, integer *,
	     integer *, char *, ftnlen), igraphdvout_(integer *, integer *, 
	    doublereal *, integer *, char *, ftnlen), igraphivout_(integer *, 
	    integer *, integer *, integer *, char *, ftnlen);
    extern doublereal igraphdlapy2_(doublereal *, doublereal *);
    extern /* Subroutine */ int igraphdlabad_(doublereal *, doublereal *);
    extern doublereal igraphdlamch_(char *);
    extern /* Subroutine */ int igraphdlarfg_(integer *, doublereal *, doublereal *,
	     integer *, doublereal *);
    doublereal sigmai;
    extern doublereal igraphdlanhs_(char *, integer *, doublereal *, integer *, 
	    doublereal *);
    extern /* Subroutine */ int igraphsecond_(real *), igraphdlacpy_(char *, integer *, 
	    integer *, doublereal *, integer *, doublereal *, integer *), igraphdlaset_(char *, integer *, integer *, doublereal *, 
	    doublereal *, doublereal *, integer *), igraphdlartg_(
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *);
    integer logfil, ndigit;
    doublereal sigmar;
    integer mnapps = 0, msglvl;
    real tnapps = 0.;
    integer istart;
    IGRAPH_F77_SAVE doublereal smlnum;
    integer kplusp;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %------------------------%   
       | Local Scalars & Arrays |   
       %------------------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %----------------------%   
       | Intrinsics Functions |   
       %----------------------%   


       %----------------%   
       | Data statments |   
       %----------------%   

       Parameter adjustments */
    --workd;
    --resid;
    --workl;
    --shifti;
    --shiftr;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;

    /* Function Body   

       %-----------------------%   
       | Executable Statements |   
       %-----------------------% */

    if (first) {

/*        %-----------------------------------------------%   
          | Set machine-dependent constants for the       |   
          | stopping criterion. If norm(H) <= sqrt(OVFL), |   
          | overflow should not occur.                    |   
          | REFERENCE: LAPACK subroutine dlahqr           |   
          %-----------------------------------------------% */

	unfl = igraphdlamch_("safe minimum");
	ovfl = 1. / unfl;
	igraphdlabad_(&unfl, &ovfl);
	ulp = igraphdlamch_("precision");
	smlnum = unfl * (*n / ulp);
	first = FALSE_;
    }

/*     %-------------------------------%   
       | Initialize timing statistics  |   
       | & message level for debugging |   
       %-------------------------------% */

    igraphsecond_(&t0);
    msglvl = mnapps;
    kplusp = *kev + *np;

/*     %--------------------------------------------%   
       | Initialize Q to the identity to accumulate |   
       | the rotations and reflections              |   
       %--------------------------------------------% */

    igraphdlaset_("All", &kplusp, &kplusp, &dgetv0__c_b5, &dgetv0__c_b6, &q[q_offset], ldq);

/*     %----------------------------------------------%   
       | Quick return if there are no shifts to apply |   
       %----------------------------------------------% */

    if (*np == 0) {
	goto L9000;
    }

/*     %----------------------------------------------%   
       | Chase the bulge with the application of each |   
       | implicit shift. Each shift is applied to the |   
       | whole matrix including each block.           |   
       %----------------------------------------------% */

    cconj = FALSE_;
    i__1 = *np;
    for (jj = 1; jj <= i__1; ++jj) {
	sigmar = shiftr[jj];
	sigmai = shifti[jj];

	if (msglvl > 2) {
	    igraphivout_(&logfil, &dgetv0__c__1, &jj, &ndigit, "_napps: shift number.", (
		    ftnlen)21);
	    igraphdvout_(&logfil, &dgetv0__c__1, &sigmar, &ndigit, "_napps: The real part "
		    "of the shift ", (ftnlen)35);
	    igraphdvout_(&logfil, &dgetv0__c__1, &sigmai, &ndigit, "_napps: The imaginary "
		    "part of the shift ", (ftnlen)40);
	}

/*        %-------------------------------------------------%   
          | The following set of conditionals is necessary  |   
          | in order that complex conjugate pairs of shifts |   
          | are applied together or not at all.             |   
          %-------------------------------------------------% */

	if (cconj) {

/*           %-----------------------------------------%   
             | cconj = .true. means the previous shift |   
             | had non-zero imaginary part.            |   
             %-----------------------------------------% */

	    cconj = FALSE_;
	    goto L110;
	} else if (jj < *np && abs(sigmai) > 0.) {

/*           %------------------------------------%   
             | Start of a complex conjugate pair. |   
             %------------------------------------% */

	    cconj = TRUE_;
	} else if (jj == *np && abs(sigmai) > 0.) {

/*           %----------------------------------------------%   
             | The last shift has a nonzero imaginary part. |   
             | Don't apply it; thus the order of the        |   
             | compressed H is order KEV+1 since only np-1  |   
             | were applied.                                |   
             %----------------------------------------------% */

	    ++(*kev);
	    goto L110;
	}
	istart = 1;
L20:

/*        %--------------------------------------------------%   
          | if sigmai = 0 then                               |   
          |    Apply the jj-th shift ...                     |   
          | else                                             |   
          |    Apply the jj-th and (jj+1)-th together ...    |   
          |    (Note that jj < np at this point in the code) |   
          | end                                              |   
          | to the current block of H. The next do loop      |   
          | determines the current block ;                   |   
          %--------------------------------------------------% */

	i__2 = kplusp - 1;
	for (i__ = istart; i__ <= i__2; ++i__) {

/*           %----------------------------------------%   
             | Check for splitting and deflation. Use |   
             | a standard test as in the QR algorithm |   
             | REFERENCE: LAPACK subroutine dlahqr    |   
             %----------------------------------------% */

	    tst1 = (d__1 = h__[i__ + i__ * h_dim1], abs(d__1)) + (d__2 = h__[
		    i__ + 1 + (i__ + 1) * h_dim1], abs(d__2));
	    if (tst1 == 0.) {
		i__3 = kplusp - jj + 1;
		tst1 = igraphdlanhs_("1", &i__3, &h__[h_offset], ldh, &workl[1]);
	    }
/* Computing MAX */
	    d__2 = ulp * tst1;
	    if ((d__1 = h__[i__ + 1 + i__ * h_dim1], abs(d__1)) <= max(d__2,
		    smlnum)) {
		if (msglvl > 0) {
		    igraphivout_(&logfil, &dgetv0__c__1, &i__, &ndigit, "_napps: matrix sp"
			    "litting at row/column no.", (ftnlen)42);
		    igraphivout_(&logfil, &dgetv0__c__1, &jj, &ndigit, "_napps: matrix spl"
			    "itting with shift number.", (ftnlen)43);
		    igraphdvout_(&logfil, &dgetv0__c__1, &h__[i__ + 1 + i__ * h_dim1], &
			    ndigit, "_napps: off diagonal element.", (ftnlen)
			    29);
		}
		iend = i__;
		h__[i__ + 1 + i__ * h_dim1] = 0.;
		goto L40;
	    }
/* L30: */
	}
	iend = kplusp;
L40:

	if (msglvl > 2) {
	    igraphivout_(&logfil, &dgetv0__c__1, &istart, &ndigit, "_napps: Start of curre"
		    "nt block ", (ftnlen)31);
	    igraphivout_(&logfil, &dgetv0__c__1, &iend, &ndigit, "_napps: End of current b"
		    "lock ", (ftnlen)29);
	}

/*        %------------------------------------------------%   
          | No reason to apply a shift to block of order 1 |   
          %------------------------------------------------% */

	if (istart == iend) {
	    goto L100;
	}

/*        %------------------------------------------------------%   
          | If istart + 1 = iend then no reason to apply a       |   
          | complex conjugate pair of shifts on a 2 by 2 matrix. |   
          %------------------------------------------------------% */

	if (istart + 1 == iend && abs(sigmai) > 0.) {
	    goto L100;
	}

	h11 = h__[istart + istart * h_dim1];
	h21 = h__[istart + 1 + istart * h_dim1];
	if (abs(sigmai) <= 0.) {

/*           %---------------------------------------------%   
             | Real-valued shift ==> apply single shift QR |   
             %---------------------------------------------% */

	    f = h11 - sigmar;
	    g = h21;

	    i__2 = iend - 1;
	    for (i__ = istart; i__ <= i__2; ++i__) {

/*              %-----------------------------------------------------%   
                | Contruct the plane rotation G to zero out the bulge |   
                %-----------------------------------------------------% */

		igraphdlartg_(&f, &g, &c__, &s, &r__);
		if (i__ > istart) {

/*                 %-------------------------------------------%   
                   | The following ensures that h(1:iend-1,1), |   
                   | the first iend-2 off diagonal of elements |   
                   | H, remain non negative.                   |   
                   %-------------------------------------------% */

		    if (r__ < 0.) {
			r__ = -r__;
			c__ = -c__;
			s = -s;
		    }
		    h__[i__ + (i__ - 1) * h_dim1] = r__;
		    h__[i__ + 1 + (i__ - 1) * h_dim1] = 0.;
		}

/*              %---------------------------------------------%   
                | Apply rotation to the left of H;  H <- G'*H |   
                %---------------------------------------------% */

		i__3 = kplusp;
		for (j = i__; j <= i__3; ++j) {
		    t = c__ * h__[i__ + j * h_dim1] + s * h__[i__ + 1 + j * 
			    h_dim1];
		    h__[i__ + 1 + j * h_dim1] = -s * h__[i__ + j * h_dim1] + 
			    c__ * h__[i__ + 1 + j * h_dim1];
		    h__[i__ + j * h_dim1] = t;
/* L50: */
		}

/*              %---------------------------------------------%   
                | Apply rotation to the right of H;  H <- H*G |   
                %---------------------------------------------%   

   Computing MIN */
		i__4 = i__ + 2;
		i__3 = min(i__4,iend);
		for (j = 1; j <= i__3; ++j) {
		    t = c__ * h__[j + i__ * h_dim1] + s * h__[j + (i__ + 1) * 
			    h_dim1];
		    h__[j + (i__ + 1) * h_dim1] = -s * h__[j + i__ * h_dim1] 
			    + c__ * h__[j + (i__ + 1) * h_dim1];
		    h__[j + i__ * h_dim1] = t;
/* L60: */
		}

/*              %----------------------------------------------------%   
                | Accumulate the rotation in the matrix Q;  Q <- Q*G |   
                %----------------------------------------------------%   

   Computing MIN */
		i__4 = j + jj;
		i__3 = min(i__4,kplusp);
		for (j = 1; j <= i__3; ++j) {
		    t = c__ * q[j + i__ * q_dim1] + s * q[j + (i__ + 1) * 
			    q_dim1];
		    q[j + (i__ + 1) * q_dim1] = -s * q[j + i__ * q_dim1] + 
			    c__ * q[j + (i__ + 1) * q_dim1];
		    q[j + i__ * q_dim1] = t;
/* L70: */
		}

/*              %---------------------------%   
                | Prepare for next rotation |   
                %---------------------------% */

		if (i__ < iend - 1) {
		    f = h__[i__ + 1 + i__ * h_dim1];
		    g = h__[i__ + 2 + i__ * h_dim1];
		}
/* L80: */
	    }

/*           %-----------------------------------%   
             | Finished applying the real shift. |   
             %-----------------------------------% */

	} else {

/*           %----------------------------------------------------%   
             | Complex conjugate shifts ==> apply double shift QR |   
             %----------------------------------------------------% */

	    h12 = h__[istart + (istart + 1) * h_dim1];
	    h22 = h__[istart + 1 + (istart + 1) * h_dim1];
	    h32 = h__[istart + 2 + (istart + 1) * h_dim1];

/*           %---------------------------------------------------------%   
             | Compute 1st column of (H - shift*I)*(H - conj(shift)*I) |   
             %---------------------------------------------------------% */

	    s = sigmar * 2.f;
	    t = igraphdlapy2_(&sigmar, &sigmai);
	    u[0] = (h11 * (h11 - s) + t * t) / h21 + h12;
	    u[1] = h11 + h22 - s;
	    u[2] = h32;

	    i__2 = iend - 1;
	    for (i__ = istart; i__ <= i__2; ++i__) {

/* Computing MIN */
		i__3 = 3, i__4 = iend - i__ + 1;
		nr = min(i__3,i__4);

/*              %-----------------------------------------------------%   
                | Construct Householder reflector G to zero out u(1). |   
                | G is of the form I - tau*( 1 u )' * ( 1 u' ).       |   
                %-----------------------------------------------------% */

		igraphdlarfg_(&nr, u, &u[1], &dgetv0__c__1, &tau);

		if (i__ > istart) {
		    h__[i__ + (i__ - 1) * h_dim1] = u[0];
		    h__[i__ + 1 + (i__ - 1) * h_dim1] = 0.;
		    if (i__ < iend - 1) {
			h__[i__ + 2 + (i__ - 1) * h_dim1] = 0.;
		    }
		}
		u[0] = 1.;

/*              %--------------------------------------%   
                | Apply the reflector to the left of H |   
                %--------------------------------------% */

		i__3 = kplusp - i__ + 1;
		igraphdlarf_("Left", &nr, &i__3, u, &dgetv0__c__1, &tau, &h__[i__ + i__ * 
			h_dim1], ldh, &workl[1]);

/*              %---------------------------------------%   
                | Apply the reflector to the right of H |   
                %---------------------------------------%   

   Computing MIN */
		i__3 = i__ + 3;
		ir = min(i__3,iend);
		igraphdlarf_("Right", &ir, &nr, u, &dgetv0__c__1, &tau, &h__[i__ * h_dim1 + 
			1], ldh, &workl[1]);

/*              %-----------------------------------------------------%   
                | Accumulate the reflector in the matrix Q;  Q <- Q*G |   
                %-----------------------------------------------------% */

		igraphdlarf_("Right", &kplusp, &nr, u, &dgetv0__c__1, &tau, &q[i__ * q_dim1 
			+ 1], ldq, &workl[1]);

/*              %----------------------------%   
                | Prepare for next reflector |   
                %----------------------------% */

		if (i__ < iend - 1) {
		    u[0] = h__[i__ + 1 + i__ * h_dim1];
		    u[1] = h__[i__ + 2 + i__ * h_dim1];
		    if (i__ < iend - 2) {
			u[2] = h__[i__ + 3 + i__ * h_dim1];
		    }
		}

/* L90: */
	    }

/*           %--------------------------------------------%   
             | Finished applying a complex pair of shifts |   
             | to the current block                       |   
             %--------------------------------------------% */

	}

L100:

/*        %---------------------------------------------------------%   
          | Apply the same shift to the next block if there is any. |   
          %---------------------------------------------------------% */

	istart = iend + 1;
	if (iend < kplusp) {
	    goto L20;
	}

/*        %---------------------------------------------%   
          | Loop back to the top to get the next shift. |   
          %---------------------------------------------% */

L110:
	;
    }

/*     %--------------------------------------------------%   
       | Perform a similarity transformation that makes   |   
       | sure that H will have non negative sub diagonals |   
       %--------------------------------------------------% */

    i__1 = *kev;
    for (j = 1; j <= i__1; ++j) {
	if (h__[j + 1 + j * h_dim1] < 0.) {
	    i__2 = kplusp - j + 1;
	    igraphdscal_(&i__2, &dgetv0__c_b43, &h__[j + 1 + j * h_dim1], ldh);
/* Computing MIN */
	    i__3 = j + 2;
	    i__2 = min(i__3,kplusp);
	    igraphdscal_(&i__2, &dgetv0__c_b43, &h__[(j + 1) * h_dim1 + 1], &dgetv0__c__1);
/* Computing MIN */
	    i__3 = j + *np + 1;
	    i__2 = min(i__3,kplusp);
	    igraphdscal_(&i__2, &dgetv0__c_b43, &q[(j + 1) * q_dim1 + 1], &dgetv0__c__1);
	}
/* L120: */
    }

    i__1 = *kev;
    for (i__ = 1; i__ <= i__1; ++i__) {

/*        %--------------------------------------------%   
          | Final check for splitting and deflation.   |   
          | Use a standard test as in the QR algorithm |   
          | REFERENCE: LAPACK subroutine dlahqr        |   
          %--------------------------------------------% */

	tst1 = (d__1 = h__[i__ + i__ * h_dim1], abs(d__1)) + (d__2 = h__[i__ 
		+ 1 + (i__ + 1) * h_dim1], abs(d__2));
	if (tst1 == 0.) {
	    tst1 = igraphdlanhs_("1", kev, &h__[h_offset], ldh, &workl[1]);
	}
/* Computing MAX */
	d__1 = ulp * tst1;
	if (h__[i__ + 1 + i__ * h_dim1] <= max(d__1,smlnum)) {
	    h__[i__ + 1 + i__ * h_dim1] = 0.;
	}
/* L130: */
    }

/*     %-------------------------------------------------%   
       | Compute the (kev+1)-st column of (V*Q) and      |   
       | temporarily store the result in WORKD(N+1:2*N). |   
       | This is needed in the residual update since we  |   
       | cannot GUARANTEE that the corresponding entry   |   
       | of H would be zero as in exact arithmetic.      |   
       %-------------------------------------------------% */

    if (h__[*kev + 1 + *kev * h_dim1] > 0.) {
	igraphdgemv_("N", n, &kplusp, &dgetv0__c_b6, &v[v_offset], ldv, &q[(*kev + 1) * 
		q_dim1 + 1], &dgetv0__c__1, &dgetv0__c_b5, &workd[*n + 1], &dgetv0__c__1);
    }

/*     %----------------------------------------------------------%   
       | Compute column 1 to kev of (V*Q) in backward order       |   
       | taking advantage of the upper Hessenberg structure of Q. |   
       %----------------------------------------------------------% */

    i__1 = *kev;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = kplusp - i__ + 1;
	igraphdgemv_("N", n, &i__2, &dgetv0__c_b6, &v[v_offset], ldv, &q[(*kev - i__ + 1) * 
		q_dim1 + 1], &dgetv0__c__1, &dgetv0__c_b5, &workd[1], &dgetv0__c__1);
	igraphdcopy_(n, &workd[1], &dgetv0__c__1, &v[(kplusp - i__ + 1) * v_dim1 + 1], &
		dgetv0__c__1);
/* L140: */
    }

/*     %-------------------------------------------------%   
       |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |   
       %-------------------------------------------------% */

    igraphdlacpy_("A", n, kev, &v[(kplusp - *kev + 1) * v_dim1 + 1], ldv, &v[
	    v_offset], ldv);

/*     %--------------------------------------------------------------%   
       | Copy the (kev+1)-st column of (V*Q) in the appropriate place |   
       %--------------------------------------------------------------% */

    if (h__[*kev + 1 + *kev * h_dim1] > 0.) {
	igraphdcopy_(n, &workd[*n + 1], &dgetv0__c__1, &v[(*kev + 1) * v_dim1 + 1], &dgetv0__c__1);
    }

/*     %-------------------------------------%   
       | Update the residual vector:         |   
       |    r <- sigmak*r + betak*v(:,kev+1) |   
       | where                               |   
       |    sigmak = (e_{kplusp}'*Q)*e_{kev} |   
       |    betak = e_{kev+1}'*H*e_{kev}     |   
       %-------------------------------------% */

    igraphdscal_(n, &q[kplusp + *kev * q_dim1], &resid[1], &dgetv0__c__1);
    if (h__[*kev + 1 + *kev * h_dim1] > 0.) {
		// igraphdaxpy_(n, &h__[*kev + 1 + *kev * h_dim1], &v[(*kev + 1) * v_dim1 + 1], &dgetv0__c__1, &resid[1], &dgetv0__c__1);		
		cblas_daxpy(n, h__[*kev + 1 + *kev * h_dim1], &v[(*kev + 1) * v_dim1 + 1], 1, &resid[1], 1);		
    }

    if (msglvl > 1) {
	igraphdvout_(&logfil, &dgetv0__c__1, &q[kplusp + *kev * q_dim1], &ndigit, "_napps:"
		" sigmak = (e_{kev+p}^T*Q)*e_{kev}", (ftnlen)40);
	igraphdvout_(&logfil, &dgetv0__c__1, &h__[*kev + 1 + *kev * h_dim1], &ndigit, "_na"
		"pps: betak = e_{kev+1}^T*H*e_{kev}", (ftnlen)37);
	igraphivout_(&logfil, &dgetv0__c__1, kev, &ndigit, "_napps: Order of the final Hes"
		"senberg matrix ", (ftnlen)45);
	if (msglvl > 2) {
	    igraphdmout_(&logfil, kev, kev, &h__[h_offset], ldh, &ndigit, "_napps:"
		    " updated Hessenberg matrix H for next iteration", (ftnlen)
		    54);
	}

    }

L9000:
    igraphsecond_(&t1);
    tnapps += t1 - t0;

    return 0;

/*     %---------------%   
       | End of dnapps |   
       %---------------% */

} /* igraphdnapps_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static doublereal dhseqr__c_b3 = .66666666666666663;
static integer dhseqr__c__1 = 1;
static integer dhseqr__c__0 = 0;
static integer dhseqr__c__4 = 4;
static logical dhseqr__c_true = TRUE_;
static integer dhseqr__c__2 = 2;

/* \BeginDoc   

   \Name: dnaup2   

   \Description:   
    Intermediate level interface called by dnaupd.   

   \Usage:   
    call dnaup2   
       ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,   
         ISHIFT, MXITER, V, LDV, H, LDH, RITZR, RITZI, BOUNDS,   
         Q, LDQ, WORKL, IPNTR, WORKD, INFO )   

   \Arguments   

    IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in dnaupd.   
    MODE, ISHIFT, MXITER: see the definition of IPARAM in dnaupd.   

    NP      Integer.  (INPUT/OUTPUT)   
            Contains the number of implicit shifts to apply during   
            each Arnoldi iteration.   
            If ISHIFT=1, NP is adjusted dynamically at each iteration   
            to accelerate convergence and prevent stagnation.   
            This is also roughly equal to the number of matrix-vector   
            products (involving the operator OP) per Arnoldi iteration.   
            The logic for adjusting is contained within the current   
            subroutine.   
            If ISHIFT=0, NP is the number of shifts the user needs   
            to provide via reverse comunication. 0 < NP < NCV-NEV.   
            NP may be less than NCV-NEV for two reasons. The first, is   
            to keep complex conjugate pairs of "wanted" Ritz values   
            together. The second, is that a leading block of the current   
            upper Hessenberg matrix has split off and contains "unwanted"   
            Ritz values.   
            Upon termination of the IRA iteration, NP contains the number   
            of "converged" wanted Ritz values.   

    IUPD    Integer.  (INPUT)   
            IUPD .EQ. 0: use explicit restart instead implicit update.   
            IUPD .NE. 0: use implicit update.   

    V       Double precision N by (NEV+NP) array.  (INPUT/OUTPUT)   
            The Arnoldi basis vectors are returned in the first NEV   
            columns of V.   

    LDV     Integer.  (INPUT)   
            Leading dimension of V exactly as declared in the calling   
            program.   

    H       Double precision (NEV+NP) by (NEV+NP) array.  (OUTPUT)   
            H is used to store the generated upper Hessenberg matrix   

    LDH     Integer.  (INPUT)   
            Leading dimension of H exactly as declared in the calling   
            program.   

    RITZR,  Double precision arrays of length NEV+NP.  (OUTPUT)   
    RITZI   RITZR(1:NEV) (resp. RITZI(1:NEV)) contains the real (resp.   
            imaginary) part of the computed Ritz values of OP.   

    BOUNDS  Double precision array of length NEV+NP.  (OUTPUT)   
            BOUNDS(1:NEV) contain the error bounds corresponding to   
            the computed Ritz values.   

    Q       Double precision (NEV+NP) by (NEV+NP) array.  (WORKSPACE)   
            Private (replicated) work array used to accumulate the   
            rotation in the shift application step.   

    LDQ     Integer.  (INPUT)   
            Leading dimension of Q exactly as declared in the calling   
            program.   

    WORKL   Double precision work array of length at least   
            (NEV+NP)**2 + 3*(NEV+NP).  (INPUT/WORKSPACE)   
            Private (replicated) array on each PE or array allocated on   
            the front end.  It is used in shifts calculation, shifts   
            application and convergence checking.   

            On exit, the last 3*(NEV+NP) locations of WORKL contain   
            the Ritz values (real,imaginary) and associated Ritz   
            estimates of the current Hessenberg matrix.  They are   
            listed in the same order as returned from dneigh.   

            If ISHIFT .EQ. O and IDO .EQ. 3, the first 2*NP locations   
            of WORKL are used in reverse communication to hold the user   
            supplied shifts.   

    IPNTR   Integer array of length 3.  (OUTPUT)   
            Pointer to mark the starting locations in the WORKD for   
            vectors used by the Arnoldi iteration.   
            -------------------------------------------------------------   
            IPNTR(1): pointer to the current operand vector X.   
            IPNTR(2): pointer to the current result vector Y.   
            IPNTR(3): pointer to the vector B * X when used in the   
                      shift-and-invert mode.  X is the current operand.   
            -------------------------------------------------------------   

    WORKD   Double precision work array of length 3*N.  (WORKSPACE)   
            Distributed array to be used in the basic Arnoldi iteration   
            for reverse communication.  The user should not use WORKD   
            as temporary workspace during the iteration !!!!!!!!!!   
            See Data Distribution Note in DNAUPD.   

    INFO    Integer.  (INPUT/OUTPUT)   
            If INFO .EQ. 0, a randomly initial residual vector is used.   
            If INFO .NE. 0, RESID contains the initial residual vector,   
                            possibly from a previous run.   
            Error flag on output.   
            =     0: Normal return.   
            =     1: Maximum number of iterations taken.   
                     All possible eigenvalues of OP has been found.   
                     NP returns the number of converged Ritz values.   
            =     2: No shifts could be applied.   
            =    -8: Error return from LAPACK eigenvalue calculation;   
                     This should never happen.   
            =    -9: Starting vector is zero.   
            = -9999: Could not build an Arnoldi factorization.   
                     Size that was built in returned in NP.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \References:   
    1. D.C. Sorensen, "Implicit Application of Polynomial Filters in   
       a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),   
       pp 357-385.   
    2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly   
       Restarted Arnoldi Iteration", Rice University Technical Report   
       TR95-13, Department of Computational and Applied Mathematics.   

   \Routines called:   
       dgetv0  ARPACK initial vector generation routine.   
       dnaitr  ARPACK Arnoldi factorization routine.   
       dnapps  ARPACK application of implicit shifts routine.   
       dnconv  ARPACK convergence of Ritz values routine.   
       dneigh  ARPACK compute Ritz values and error bounds routine.   
       dngets  ARPACK reorder Ritz values and error bounds routine.   
       dsortc  ARPACK sorting routine.   
       ivout   ARPACK utility routine that prints integers.   
       second  ARPACK utility routine for timing.   
       dmout   ARPACK utility routine that prints matrices   
       dvout   ARPACK utility routine that prints vectors.   
       dlamch  LAPACK routine that determines machine constants.   
       dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.   
       dcopy   Level 1 BLAS that copies one vector to another .   
       ddot    Level 1 BLAS that computes the scalar product of two vectors.   
       dnrm2   Level 1 BLAS that computes the norm of a vector.   
       dswap   Level 1 BLAS that swaps two vectors.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \SCCS Information: @(#)   
   FILE: naup2.F   SID: 2.4   DATE OF SID: 7/30/96   RELEASE: 2   

   \Remarks   
       1. None   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdnaup2_(integer *ido, char *bmat, integer *n, char *
	which, integer *nev, integer *np, doublereal *tol, doublereal *resid, 
	integer *mode, integer *iupd, integer *ishift, integer *mxiter, 
	doublereal *v, integer *ldv, doublereal *h__, integer *ldh, 
	doublereal *ritzr, doublereal *ritzi, doublereal *bounds, doublereal *
	q, integer *ldq, doublereal *workl, integer *ipntr, doublereal *workd,
	 integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, q_dim1, q_offset, v_dim1, v_offset, i__1, i__2;
    doublereal d__1, d__2;

    /* Builtin functions */
    double pow_dd(doublereal *, doublereal *);
    integer s_cmp(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    double sqrt(doublereal);

    /* Local variables */
    IGRAPH_F77_SAVE integer j;
    IGRAPH_F77_SAVE real t0, t1, t2, t3;
    IGRAPH_F77_SAVE integer kp[4], np0, nbx, nev0;
    extern doublereal igraphddot_(integer *, doublereal *, integer *, doublereal *, 
	    integer *);
    IGRAPH_F77_SAVE doublereal eps23;
    IGRAPH_F77_SAVE integer ierr, iter;
    IGRAPH_F77_SAVE doublereal temp;
    extern doublereal igraphdnrm2_(integer *, doublereal *, integer *);
    IGRAPH_F77_SAVE logical getv0, cnorm;
    extern /* Subroutine */ int igraphdcopy_(integer *, doublereal *, integer *, 
	    doublereal *, integer *);
    IGRAPH_F77_SAVE integer nconv;
    extern /* Subroutine */ int igraphdmout_(integer *, integer *, integer *, 
	    doublereal *, integer *, integer *, char *, ftnlen);
    IGRAPH_F77_SAVE logical initv;
    IGRAPH_F77_SAVE doublereal rnorm;
    IGRAPH_F77_SAVE real tmvbx;
    extern /* Subroutine */ int igraphdvout_(integer *, integer *, doublereal *, 
	    integer *, char *, ftnlen), igraphivout_(integer *, integer *, integer *
	    , integer *, char *, ftnlen), igraphdgetv0_(integer *, char *, integer *
	    , logical *, integer *, integer *, doublereal *, integer *, 
	    doublereal *, doublereal *, integer *, doublereal *, integer *);
    extern doublereal igraphdlapy2_(doublereal *, doublereal *);
    IGRAPH_F77_SAVE integer mnaup2;
    IGRAPH_F77_SAVE real tnaup2;
    extern doublereal igraphdlamch_(char *);
    extern /* Subroutine */ int igraphdneigh_(doublereal *, integer *, doublereal *,
	     integer *, doublereal *, doublereal *, doublereal *, doublereal *
	    , integer *, doublereal *, integer *);
    IGRAPH_F77_SAVE integer nevbef;
    extern /* Subroutine */ int igraphsecond_(real *);
    IGRAPH_F77_SAVE integer logfil, ndigit;
    extern /* Subroutine */ int igraphdnaitr_(integer *, char *, integer *, integer 
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, doublereal *, integer *, integer *, doublereal *, 
	    integer *);
    IGRAPH_F77_SAVE logical update;
    extern /* Subroutine */ int igraphdngets_(integer *, char *, integer *, integer 
	    *, doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *), igraphdnapps_(integer *, integer *, integer *, 
	    doublereal *, doublereal *, doublereal *, integer *, doublereal *,
	     integer *, doublereal *, doublereal *, integer *, doublereal *, 
	    doublereal *), igraphdnconv_(integer *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, integer *), igraphdsortc_(char *, logical *,
	     integer *, doublereal *, doublereal *, doublereal *);
    IGRAPH_F77_SAVE logical ushift;
    IGRAPH_F77_SAVE char wprime[2];
    IGRAPH_F77_SAVE integer msglvl, nptemp, numcnv, kplusp;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %-----------------------%   
       | Local array arguments |   
       %-----------------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %---------------------%   
       | Intrinsic Functions |   
       %---------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       Parameter adjustments */
    --workd;
    --resid;
    --workl;
    --bounds;
    --ritzi;
    --ritzr;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;
    --ipntr;

    /* Function Body */
    if (*ido == 0) {

	igraphsecond_(&t0);

	msglvl = mnaup2;

/*        %-------------------------------------%   
          | Get the machine dependent constant. |   
          %-------------------------------------% */

	eps23 = igraphdlamch_("Epsilon-Machine");
	eps23 = pow_dd(&eps23, &dhseqr__c_b3);

	nev0 = *nev;
	np0 = *np;

/*        %-------------------------------------%   
          | kplusp is the bound on the largest  |   
          |        Lanczos factorization built. |   
          | nconv is the current number of      |   
          |        "converged" eigenvlues.      |   
          | iter is the counter on the current  |   
          |      iteration step.                |   
          %-------------------------------------% */

	kplusp = *nev + *np;
	nconv = 0;
	iter = 0;

/*        %---------------------------------------%   
          | Set flags for computing the first NEV |   
          | steps of the Arnoldi factorization.   |   
          %---------------------------------------% */

	getv0 = TRUE_;
	update = FALSE_;
	ushift = FALSE_;
	cnorm = FALSE_;

	if (*info != 0) {

/*           %--------------------------------------------%   
             | User provides the initial residual vector. |   
             %--------------------------------------------% */

	    initv = TRUE_;
	    *info = 0;
	} else {
	    initv = FALSE_;
	}
    }

/*     %---------------------------------------------%   
       | Get a possibly random starting vector and   |   
       | force it into the range of the operator OP. |   
       %---------------------------------------------%   

   L10: */

    if (getv0) {
	igraphdgetv0_(ido, bmat, &dhseqr__c__1, &initv, n, &dhseqr__c__1, &v[v_offset], ldv, &resid[
		1], &rnorm, &ipntr[1], &workd[1], info);

	if (*ido != 99) {
	    goto L9000;
	}

	if (rnorm == 0.) {

/*           %-----------------------------------------%   
             | The initial vector is zero. Error exit. |   
             %-----------------------------------------% */

	    *info = -9;
	    goto L1100;
	}
	getv0 = FALSE_;
	*ido = 0;
    }

/*     %-----------------------------------%   
       | Back from reverse communication : |   
       | continue with update step         |   
       %-----------------------------------% */

    if (update) {
	goto L20;
    }

/*     %-------------------------------------------%   
       | Back from computing user specified shifts |   
       %-------------------------------------------% */

    if (ushift) {
	goto L50;
    }

/*     %-------------------------------------%   
       | Back from computing residual norm   |   
       | at the end of the current iteration |   
       %-------------------------------------% */

    if (cnorm) {
	goto L100;
    }

/*     %----------------------------------------------------------%   
       | Compute the first NEV steps of the Arnoldi factorization |   
       %----------------------------------------------------------% */

    igraphdnaitr_(ido, bmat, n, &dhseqr__c__0, nev, mode, &resid[1], &rnorm, &v[v_offset], 
	    ldv, &h__[h_offset], ldh, &ipntr[1], &workd[1], info);

/*     %---------------------------------------------------%   
       | ido .ne. 99 implies use of reverse communication  |   
       | to compute operations involving OP and possibly B |   
       %---------------------------------------------------% */

    if (*ido != 99) {
	goto L9000;
    }

    if (*info > 0) {
	*np = *info;
	*mxiter = iter;
	*info = -9999;
	goto L1200;
    }

/*     %--------------------------------------------------------------%   
       |                                                              |   
       |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |   
       |           Each iteration implicitly restarts the Arnoldi     |   
       |           factorization in place.                            |   
       |                                                              |   
       %--------------------------------------------------------------% */

L1000:

    ++iter;

    if (msglvl > 0) {
	igraphivout_(&logfil, &dhseqr__c__1, &iter, &ndigit, "_naup2: **** Start of major "
		"iteration number ****", (ftnlen)49);
    }

/*        %-----------------------------------------------------------%   
          | Compute NP additional steps of the Arnoldi factorization. |   
          | Adjust NP since NEV might have been updated by last call  |   
          | to the shift application routine dnapps.                  |   
          %-----------------------------------------------------------% */

    *np = kplusp - *nev;

    if (msglvl > 1) {
	igraphivout_(&logfil, &dhseqr__c__1, nev, &ndigit, "_naup2: The length of the curr"
		"ent Arnoldi factorization", (ftnlen)55);
	igraphivout_(&logfil, &dhseqr__c__1, np, &ndigit, "_naup2: Extend the Arnoldi fact"
		"orization by", (ftnlen)43);
    }

/*        %-----------------------------------------------------------%   
          | Compute NP additional steps of the Arnoldi factorization. |   
          %-----------------------------------------------------------% */

    *ido = 0;
L20:
    update = TRUE_;

    igraphdnaitr_(ido, bmat, n, nev, np, mode, &resid[1], &rnorm, &v[v_offset], ldv,
	     &h__[h_offset], ldh, &ipntr[1], &workd[1], info);

/*        %---------------------------------------------------%   
          | ido .ne. 99 implies use of reverse communication  |   
          | to compute operations involving OP and possibly B |   
          %---------------------------------------------------% */

    if (*ido != 99) {
	goto L9000;
    }

    if (*info > 0) {
	*np = *info;
	*mxiter = iter;
	*info = -9999;
	goto L1200;
    }
    update = FALSE_;

    if (msglvl > 1) {
	igraphdvout_(&logfil, &dhseqr__c__1, &rnorm, &ndigit, "_naup2: Corresponding B-nor"
		"m of the residual", (ftnlen)44);
    }

/*        %--------------------------------------------------------%   
          | Compute the eigenvalues and corresponding error bounds |   
          | of the current upper Hessenberg matrix.                |   
          %--------------------------------------------------------% */

    igraphdneigh_(&rnorm, &kplusp, &h__[h_offset], ldh, &ritzr[1], &ritzi[1], &
	    bounds[1], &q[q_offset], ldq, &workl[1], &ierr);

    if (ierr != 0) {
	*info = -8;
	goto L1200;
    }

/*        %----------------------------------------------------%   
          | Make a copy of eigenvalues and corresponding error |   
          | bounds obtained from dneigh.                       |   
          %----------------------------------------------------%   

   Computing 2nd power */
    i__1 = kplusp;
    igraphdcopy_(&kplusp, &ritzr[1], &dhseqr__c__1, &workl[i__1 * i__1 + 1], &dhseqr__c__1);
/* Computing 2nd power */
    i__1 = kplusp;
    igraphdcopy_(&kplusp, &ritzi[1], &dhseqr__c__1, &workl[i__1 * i__1 + kplusp + 1], &dhseqr__c__1)
	    ;
/* Computing 2nd power */
    i__1 = kplusp;
    igraphdcopy_(&kplusp, &bounds[1], &dhseqr__c__1, &workl[i__1 * i__1 + (kplusp << 1) + 1]
	    , &dhseqr__c__1);

/*        %---------------------------------------------------%   
          | Select the wanted Ritz values and their bounds    |   
          | to be used in the convergence test.               |   
          | The wanted part of the spectrum and corresponding |   
          | error bounds are in the last NEV loc. of RITZR,   |   
          | RITZI and BOUNDS respectively. The variables NEV  |   
          | and NP may be updated if the NEV-th wanted Ritz   |   
          | value has a non zero imaginary part. In this case |   
          | NEV is increased by one and NP decreased by one.  |   
          | NOTE: The last two arguments of dngets are no     |   
          | longer used as of version 2.1.                    |   
          %---------------------------------------------------% */

    *nev = nev0;
    *np = np0;
    numcnv = *nev;
    igraphdngets_(ishift, which, nev, np, &ritzr[1], &ritzi[1], &bounds[1], &workl[
	    1], &workl[*np + 1]);
    if (*nev == nev0 + 1) {
	numcnv = nev0 + 1;
    }

/*        %-------------------%   
          | Convergence test. |   
          %-------------------% */

    igraphdcopy_(nev, &bounds[*np + 1], &dhseqr__c__1, &workl[(*np << 1) + 1], &dhseqr__c__1);
    igraphdnconv_(nev, &ritzr[*np + 1], &ritzi[*np + 1], &workl[(*np << 1) + 1], 
	    tol, &nconv);

    if (msglvl > 2) {
	kp[0] = *nev;
	kp[1] = *np;
	kp[2] = numcnv;
	kp[3] = nconv;
	igraphivout_(&logfil, &dhseqr__c__4, kp, &ndigit, "_naup2: NEV, NP, NUMCNV, NCONV "
		"are", (ftnlen)34);
	igraphdvout_(&logfil, &kplusp, &ritzr[1], &ndigit, "_naup2: Real part of t"
		"he eigenvalues of H", (ftnlen)41);
	igraphdvout_(&logfil, &kplusp, &ritzi[1], &ndigit, "_naup2: Imaginary part"
		" of the eigenvalues of H", (ftnlen)46);
	igraphdvout_(&logfil, &kplusp, &bounds[1], &ndigit, "_naup2: Ritz estimate"
		"s of the current NCV Ritz values", (ftnlen)53);
    }

/*        %---------------------------------------------------------%   
          | Count the number of unwanted Ritz values that have zero |   
          | Ritz estimates. If any Ritz estimates are equal to zero |   
          | then a leading block of H of order equal to at least    |   
          | the number of Ritz values with zero Ritz estimates has  |   
          | split off. None of these Ritz values may be removed by  |   
          | shifting. Decrease NP the number of shifts to apply. If |   
          | no shifts may be applied, then prepare to exit          |   
          %---------------------------------------------------------% */

    nptemp = *np;
    i__1 = nptemp;
    for (j = 1; j <= i__1; ++j) {
	if (bounds[j] == 0.) {
	    --(*np);
	    ++(*nev);
	}
/* L30: */
    }

    if (nconv >= numcnv || iter > *mxiter || *np == 0) {

	if (msglvl > 4) {
/* Computing 2nd power */
	    i__1 = kplusp;
	    igraphdvout_(&logfil, &kplusp, &workl[i__1 * i__1 + 1], &ndigit, "_nau"
		    "p2: Real part of the eig computed by _neigh:", (ftnlen)48)
		    ;
/* Computing 2nd power */
	    i__1 = kplusp;
	    igraphdvout_(&logfil, &kplusp, &workl[i__1 * i__1 + kplusp + 1], &
		    ndigit, "_naup2: Imag part of the eig computed by _neigh:"
		    , (ftnlen)48);
/* Computing 2nd power */
	    i__1 = kplusp;
	    igraphdvout_(&logfil, &kplusp, &workl[i__1 * i__1 + (kplusp << 1) + 1], 
		    &ndigit, "_naup2: Ritz eistmates computed by _neigh:", (
		    ftnlen)42);
	}

/*           %------------------------------------------------%   
             | Prepare to exit. Put the converged Ritz values |   
             | and corresponding bounds in RITZ(1:NCONV) and  |   
             | BOUNDS(1:NCONV) respectively. Then sort. Be    |   
             | careful when NCONV > NP                        |   
             %------------------------------------------------%   

             %------------------------------------------%   
             |  Use h( 3,1 ) as storage to communicate  |   
             |  rnorm to _neupd if needed               |   
             %------------------------------------------% */
	h__[h_dim1 + 3] = rnorm;

/*           %----------------------------------------------%   
             | To be consistent with dngets, we first do a  |   
             | pre-processing sort in order to keep complex |   
             | conjugate pairs together.  This is similar   |   
             | to the pre-processing sort used in dngets    |   
             | except that the sort is done in the opposite |   
             | order.                                       |   
             %----------------------------------------------% */

	if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "SR", (ftnlen)2, (ftnlen)2);
	}
	if (s_cmp(which, "SM", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "LR", (ftnlen)2, (ftnlen)2);
	}
	if (s_cmp(which, "LR", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "SM", (ftnlen)2, (ftnlen)2);
	}
	if (s_cmp(which, "SR", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "LM", (ftnlen)2, (ftnlen)2);
	}
	if (s_cmp(which, "LI", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "SM", (ftnlen)2, (ftnlen)2);
	}
	if (s_cmp(which, "SI", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "LM", (ftnlen)2, (ftnlen)2);
	}

	igraphdsortc_(wprime, &dhseqr__c_true, &kplusp, &ritzr[1], &ritzi[1], &bounds[1]);

/*           %----------------------------------------------%   
             | Now sort Ritz values so that converged Ritz  |   
             | values appear within the first NEV locations |   
             | of ritzr, ritzi and bounds, and the most     |   
             | desired one appears at the front.            |   
             %----------------------------------------------% */

	if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "SM", (ftnlen)2, (ftnlen)2);
	}
	if (s_cmp(which, "SM", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "LM", (ftnlen)2, (ftnlen)2);
	}
	if (s_cmp(which, "LR", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "SR", (ftnlen)2, (ftnlen)2);
	}
	if (s_cmp(which, "SR", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "LR", (ftnlen)2, (ftnlen)2);
	}
	if (s_cmp(which, "LI", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "SI", (ftnlen)2, (ftnlen)2);
	}
	if (s_cmp(which, "SI", (ftnlen)2, (ftnlen)2) == 0) {
	    s_copy(wprime, "LI", (ftnlen)2, (ftnlen)2);
	}

	igraphdsortc_(wprime, &dhseqr__c_true, &kplusp, &ritzr[1], &ritzi[1], &bounds[1]);

/*           %--------------------------------------------------%   
             | Scale the Ritz estimate of each Ritz value       |   
             | by 1 / max(eps23,magnitude of the Ritz value).   |   
             %--------------------------------------------------% */

	i__1 = nev0;
	for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
	    d__1 = eps23, d__2 = igraphdlapy2_(&ritzr[j], &ritzi[j]);
	    temp = max(d__1,d__2);
	    bounds[j] /= temp;
/* L35: */
	}

/*           %----------------------------------------------------%   
             | Sort the Ritz values according to the scaled Ritz  |   
             | esitmates.  This will push all the converged ones  |   
             | towards the front of ritzr, ritzi, bounds          |   
             | (in the case when NCONV < NEV.)                    |   
             %----------------------------------------------------% */

	s_copy(wprime, "LR", (ftnlen)2, (ftnlen)2);
	igraphdsortc_(wprime, &dhseqr__c_true, &nev0, &bounds[1], &ritzr[1], &ritzi[1]);

/*           %----------------------------------------------%   
             | Scale the Ritz estimate back to its original |   
             | value.                                       |   
             %----------------------------------------------% */

	i__1 = nev0;
	for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
	    d__1 = eps23, d__2 = igraphdlapy2_(&ritzr[j], &ritzi[j]);
	    temp = max(d__1,d__2);
	    bounds[j] *= temp;
/* L40: */
	}

/*           %------------------------------------------------%   
             | Sort the converged Ritz values again so that   |   
             | the "threshold" value appears at the front of  |   
             | ritzr, ritzi and bound.                        |   
             %------------------------------------------------% */

	igraphdsortc_(which, &dhseqr__c_true, &nconv, &ritzr[1], &ritzi[1], &bounds[1]);

	if (msglvl > 1) {
	    igraphdvout_(&logfil, &kplusp, &ritzr[1], &ndigit, "_naup2: Sorted rea"
		    "l part of the eigenvalues", (ftnlen)43);
	    igraphdvout_(&logfil, &kplusp, &ritzi[1], &ndigit, "_naup2: Sorted ima"
		    "ginary part of the eigenvalues", (ftnlen)48);
	    igraphdvout_(&logfil, &kplusp, &bounds[1], &ndigit, "_naup2: Sorted ri"
		    "tz estimates.", (ftnlen)30);
	}

/*           %------------------------------------%   
             | Max iterations have been exceeded. |   
             %------------------------------------% */

	if (iter > *mxiter && nconv < numcnv) {
	    *info = 1;
	}

/*           %---------------------%   
             | No shifts to apply. |   
             %---------------------% */

	if (*np == 0 && nconv < numcnv) {
	    *info = 2;
	}

	*np = nconv;
	goto L1100;

    } else if (nconv < numcnv && *ishift == 1) {

/*           %-------------------------------------------------%   
             | Do not have all the requested eigenvalues yet.  |   
             | To prevent possible stagnation, adjust the size |   
             | of NEV.                                         |   
             %-------------------------------------------------% */

	nevbef = *nev;
/* Computing MIN */
	i__1 = nconv, i__2 = *np / 2;
	*nev += min(i__1,i__2);
	if (*nev == 1 && kplusp >= 6) {
	    *nev = kplusp / 2;
	} else if (*nev == 1 && kplusp > 3) {
	    *nev = 2;
	}
	*np = kplusp - *nev;

/*           %---------------------------------------%   
             | If the size of NEV was just increased |   
             | resort the eigenvalues.               |   
             %---------------------------------------% */

	if (nevbef < *nev) {
	    igraphdngets_(ishift, which, nev, np, &ritzr[1], &ritzi[1], &bounds[1], 
		    &workl[1], &workl[*np + 1]);
	}

    }

    if (msglvl > 0) {
	igraphivout_(&logfil, &dhseqr__c__1, &nconv, &ndigit, "_naup2: no. of \"converge"
		"d\" Ritz values at this iter.", (ftnlen)52);
	if (msglvl > 1) {
	    kp[0] = *nev;
	    kp[1] = *np;
	    igraphivout_(&logfil, &dhseqr__c__2, kp, &ndigit, "_naup2: NEV and NP are", (
		    ftnlen)22);
	    igraphdvout_(&logfil, nev, &ritzr[*np + 1], &ndigit, "_naup2: \"wante"
		    "d\" Ritz values -- real part", (ftnlen)41);
	    igraphdvout_(&logfil, nev, &ritzi[*np + 1], &ndigit, "_naup2: \"wante"
		    "d\" Ritz values -- imag part", (ftnlen)41);
	    igraphdvout_(&logfil, nev, &bounds[*np + 1], &ndigit, "_naup2: Ritz es"
		    "timates of the \"wanted\" values ", (ftnlen)46);
	}
    }

    if (*ishift == 0) {

/*           %-------------------------------------------------------%   
             | User specified shifts: reverse comminucation to       |   
             | compute the shifts. They are returned in the first    |   
             | 2*NP locations of WORKL.                              |   
             %-------------------------------------------------------% */

	ushift = TRUE_;
	*ido = 3;
	goto L9000;
    }

L50:

/*        %------------------------------------%   
          | Back from reverse communication;   |   
          | User specified shifts are returned |   
          | in WORKL(1:2*NP)                   |   
          %------------------------------------% */

    ushift = FALSE_;

    if (*ishift == 0) {

/*            %----------------------------------%   
              | Move the NP shifts from WORKL to |   
              | RITZR, RITZI to free up WORKL    |   
              | for non-exact shift case.        |   
              %----------------------------------% */

	igraphdcopy_(np, &workl[1], &dhseqr__c__1, &ritzr[1], &dhseqr__c__1);
	igraphdcopy_(np, &workl[*np + 1], &dhseqr__c__1, &ritzi[1], &dhseqr__c__1);
    }

    if (msglvl > 2) {
	igraphivout_(&logfil, &dhseqr__c__1, np, &ndigit, "_naup2: The number of shifts to"
		" apply ", (ftnlen)38);
	igraphdvout_(&logfil, np, &ritzr[1], &ndigit, "_naup2: Real part of the sh"
		"ifts", (ftnlen)31);
	igraphdvout_(&logfil, np, &ritzi[1], &ndigit, "_naup2: Imaginary part of t"
		"he shifts", (ftnlen)36);
	if (*ishift == 1) {
	    igraphdvout_(&logfil, np, &bounds[1], &ndigit, "_naup2: Ritz estimates"
		    " of the shifts", (ftnlen)36);
	}
    }

/*        %---------------------------------------------------------%   
          | Apply the NP implicit shifts by QR bulge chasing.       |   
          | Each shift is applied to the whole upper Hessenberg     |   
          | matrix H.                                               |   
          | The first 2*N locations of WORKD are used as workspace. |   
          %---------------------------------------------------------% */

    igraphdnapps_(n, nev, np, &ritzr[1], &ritzi[1], &v[v_offset], ldv, &h__[
	    h_offset], ldh, &resid[1], &q[q_offset], ldq, &workl[1], &workd[1]
	    );

/*        %---------------------------------------------%   
          | Compute the B-norm of the updated residual. |   
          | Keep B*RESID in WORKD(1:N) to be used in    |   
          | the first step of the next call to dnaitr.  |   
          %---------------------------------------------% */

    cnorm = TRUE_;
    igraphsecond_(&t2);
    if (*(unsigned char *)bmat == 'G') {
	++nbx;
	igraphdcopy_(n, &resid[1], &dhseqr__c__1, &workd[*n + 1], &dhseqr__c__1);
	ipntr[1] = *n + 1;
	ipntr[2] = 1;
	*ido = 2;

/*           %----------------------------------%   
             | Exit in order to compute B*RESID |   
             %----------------------------------% */

	goto L9000;
    } else if (*(unsigned char *)bmat == 'I') {
	igraphdcopy_(n, &resid[1], &dhseqr__c__1, &workd[1], &dhseqr__c__1);
    }

L100:

/*        %----------------------------------%   
          | Back from reverse communication; |   
          | WORKD(1:N) := B*RESID            |   
          %----------------------------------% */

    if (*(unsigned char *)bmat == 'G') {
	igraphsecond_(&t3);
	tmvbx += t3 - t2;
    }

    if (*(unsigned char *)bmat == 'G') {
	rnorm = igraphddot_(n, &resid[1], &dhseqr__c__1, &workd[1], &dhseqr__c__1);
	rnorm = sqrt((abs(rnorm)));
    } else if (*(unsigned char *)bmat == 'I') {
	rnorm = igraphdnrm2_(n, &resid[1], &dhseqr__c__1);
    }
    cnorm = FALSE_;

    if (msglvl > 2) {
	igraphdvout_(&logfil, &dhseqr__c__1, &rnorm, &ndigit, "_naup2: B-norm of residual "
		"for compressed factorization", (ftnlen)55);
	igraphdmout_(&logfil, nev, nev, &h__[h_offset], ldh, &ndigit, "_naup2: Com"
		"pressed upper Hessenberg matrix H", (ftnlen)44);
    }

    goto L1000;

/*     %---------------------------------------------------------------%   
       |                                                               |   
       |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |   
       |                                                               |   
       %---------------------------------------------------------------% */

L1100:

    *mxiter = iter;
    *nev = numcnv;

L1200:
    *ido = 99;

/*     %------------%   
       | Error Exit |   
       %------------% */

    igraphsecond_(&t1);
    tnaup2 = t1 - t0;

L9000:

/*     %---------------%   
       | End of dnaup2 |   
       %---------------% */

    return 0;
} /* igraphdnaup2_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer disnan__c__1 = 1;

/* \BeginDoc   

   \Name: dnaupd   

   \Description:   
    Reverse communication interface for the Implicitly Restarted Arnoldi   
    iteration. This subroutine computes approximations to a few eigenpairs   
    of a linear operator "OP" with respect to a semi-inner product defined by   
    a symmetric positive semi-definite real matrix B. B may be the identity   
    matrix. NOTE: If the linear operator "OP" is real and symmetric   
    with respect to the real positive semi-definite symmetric matrix B,   
    i.e. B*OP = (OP')*B, then subroutine ssaupd should be used instead.   

    The computed approximate eigenvalues are called Ritz values and   
    the corresponding approximate eigenvectors are called Ritz vectors.   

    dnaupd is usually called iteratively to solve one of the   
    following problems:   

    Mode 1:  A*x = lambda*x.   
             ===> OP = A  and  B = I.   

    Mode 2:  A*x = lambda*M*x, M symmetric positive definite   
             ===> OP = inv[M]*A  and  B = M.   
             ===> (If M can be factored see remark 3 below)   

    Mode 3:  A*x = lambda*M*x, M symmetric semi-definite   
             ===> OP = Real_Part{ inv[A - sigma*M]*M }  and  B = M.   
             ===> shift-and-invert mode (in real arithmetic)   
             If OP*x = amu*x, then   
             amu = 1/2 * [ 1/(lambda-sigma) + 1/(lambda-conjg(sigma)) ].   
             Note: If sigma is real, i.e. imaginary part of sigma is zero;   
                   Real_Part{ inv[A - sigma*M]*M } == inv[A - sigma*M]*M   
                   amu == 1/(lambda-sigma).   

    Mode 4:  A*x = lambda*M*x, M symmetric semi-definite   
             ===> OP = Imaginary_Part{ inv[A - sigma*M]*M }  and  B = M.   
             ===> shift-and-invert mode (in real arithmetic)   
             If OP*x = amu*x, then   
             amu = 1/2i * [ 1/(lambda-sigma) - 1/(lambda-conjg(sigma)) ].   

    Both mode 3 and 4 give the same enhancement to eigenvalues close to   
    the (complex) shift sigma.  However, as lambda goes to infinity,   
    the operator OP in mode 4 dampens the eigenvalues more strongly than   
    does OP defined in mode 3.   

    NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v   
          should be accomplished either by a direct method   
          using a sparse matrix factorization and solving   

             [A - sigma*M]*w = v  or M*w = v,   

          or through an iterative method for solving these   
          systems.  If an iterative method is used, the   
          convergence test must be more stringent than   
          the accuracy requirements for the eigenvalue   
          approximations.   

   \Usage:   
    call dnaupd   
       ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,   
         IPNTR, WORKD, WORKL, LWORKL, INFO )   

   \Arguments   
    IDO     Integer.  (INPUT/OUTPUT)   
            Reverse communication flag.  IDO must be zero on the first   
            call to dnaupd.  IDO will be set internally to   
            indicate the type of operation to be performed.  Control is   
            then given back to the calling routine which has the   
            responsibility to carry out the requested operation and call   
            dnaupd with the result.  The operand is given in   
            WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).   
            -------------------------------------------------------------   
            IDO =  0: first call to the reverse communication interface   
            IDO = -1: compute  Y = OP * X  where   
                      IPNTR(1) is the pointer into WORKD for X,   
                      IPNTR(2) is the pointer into WORKD for Y.   
                      This is for the initialization phase to force the   
                      starting vector into the range of OP.   
            IDO =  1: compute  Y = OP * X  where   
                      IPNTR(1) is the pointer into WORKD for X,   
                      IPNTR(2) is the pointer into WORKD for Y.   
                      In mode 3 and 4, the vector B * X is already   
                      available in WORKD(ipntr(3)).  It does not   
                      need to be recomputed in forming OP * X.   
            IDO =  2: compute  Y = B * X  where   
                      IPNTR(1) is the pointer into WORKD for X,   
                      IPNTR(2) is the pointer into WORKD for Y.   
            IDO =  3: compute the IPARAM(8) real and imaginary parts   
                      of the shifts where INPTR(14) is the pointer   
                      into WORKL for placing the shifts. See Remark   
                      5 below.   
            IDO = 99: done   
            -------------------------------------------------------------   

    BMAT    Character*1.  (INPUT)   
            BMAT specifies the type of the matrix B that defines the   
            semi-inner product for the operator OP.   
            BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x   
            BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*B*x   

    N       Integer.  (INPUT)   
            Dimension of the eigenproblem.   

    WHICH   Character*2.  (INPUT)   
            'LM' -> want the NEV eigenvalues of largest magnitude.   
            'SM' -> want the NEV eigenvalues of smallest magnitude.   
            'LR' -> want the NEV eigenvalues of largest real part.   
            'SR' -> want the NEV eigenvalues of smallest real part.   
            'LI' -> want the NEV eigenvalues of largest imaginary part.   
            'SI' -> want the NEV eigenvalues of smallest imaginary part.   

    NEV     Integer.  (INPUT)   
            Number of eigenvalues of OP to be computed. 0 < NEV < N-1.   

    TOL     Double precision scalar.  (INPUT)   
            Stopping criterion: the relative accuracy of the Ritz value   
            is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))   
            where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.   
            DEFAULT = DLAMCH('EPS')  (machine precision as computed   
                      by the LAPACK auxiliary subroutine DLAMCH).   

    RESID   Double precision array of length N.  (INPUT/OUTPUT)   
            On INPUT:   
            If INFO .EQ. 0, a random initial residual vector is used.   
            If INFO .NE. 0, RESID contains the initial residual vector,   
                            possibly from a previous run.   
            On OUTPUT:   
            RESID contains the final residual vector.   

    NCV     Integer.  (INPUT)   
            Number of columns of the matrix V. NCV must satisfy the two   
            inequalities 2 <= NCV-NEV and NCV <= N.   
            This will indicate how many Arnoldi vectors are generated   
            at each iteration.  After the startup phase in which NEV   
            Arnoldi vectors are generated, the algorithm generates   
            approximately NCV-NEV Arnoldi vectors at each subsequent update   
            iteration. Most of the cost in generating each Arnoldi vector is   
            in the matrix-vector operation OP*x.   
            NOTE: 2 <= NCV-NEV in order that complex conjugate pairs of Ritz   
            values are kept together. (See remark 4 below)   

    V       Double precision array N by NCV.  (OUTPUT)   
            Contains the final set of Arnoldi basis vectors.   

    LDV     Integer.  (INPUT)   
            Leading dimension of V exactly as declared in the calling program.   

    IPARAM  Integer array of length 11.  (INPUT/OUTPUT)   
            IPARAM(1) = ISHIFT: method for selecting the implicit shifts.   
            The shifts selected at each iteration are used to restart   
            the Arnoldi iteration in an implicit fashion.   
            -------------------------------------------------------------   
            ISHIFT = 0: the shifts are provided by the user via   
                        reverse communication.  The real and imaginary   
                        parts of the NCV eigenvalues of the Hessenberg   
                        matrix H are returned in the part of the WORKL   
                        array corresponding to RITZR and RITZI. See remark   
                        5 below.   
            ISHIFT = 1: exact shifts with respect to the current   
                        Hessenberg matrix H.  This is equivalent to   
                        restarting the iteration with a starting vector   
                        that is a linear combination of approximate Schur   
                        vectors associated with the "wanted" Ritz values.   
            -------------------------------------------------------------   

            IPARAM(2) = No longer referenced.   

            IPARAM(3) = MXITER   
            On INPUT:  maximum number of Arnoldi update iterations allowed.   
            On OUTPUT: actual number of Arnoldi update iterations taken.   

            IPARAM(4) = NB: blocksize to be used in the recurrence.   
            The code currently works only for NB = 1.   

            IPARAM(5) = NCONV: number of "converged" Ritz values.   
            This represents the number of Ritz values that satisfy   
            the convergence criterion.   

            IPARAM(6) = IUPD   
            No longer referenced. Implicit restarting is ALWAYS used.   

            IPARAM(7) = MODE   
            On INPUT determines what type of eigenproblem is being solved.   
            Must be 1,2,3,4; See under \Description of dnaupd for the   
            four modes available.   

            IPARAM(8) = NP   
            When ido = 3 and the user provides shifts through reverse   
            communication (IPARAM(1)=0), dnaupd returns NP, the number   
            of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark   
            5 below.   

            IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,   
            OUTPUT: NUMOP  = total number of OP*x operations,   
                    NUMOPB = total number of B*x operations if BMAT='G',   
                    NUMREO = total number of steps of re-orthogonalization.   

    IPNTR   Integer array of length 14.  (OUTPUT)   
            Pointer to mark the starting locations in the WORKD and WORKL   
            arrays for matrices/vectors used by the Arnoldi iteration.   
            -------------------------------------------------------------   
            IPNTR(1): pointer to the current operand vector X in WORKD.   
            IPNTR(2): pointer to the current result vector Y in WORKD.   
            IPNTR(3): pointer to the vector B * X in WORKD when used in   
                      the shift-and-invert mode.   
            IPNTR(4): pointer to the next available location in WORKL   
                      that is untouched by the program.   
            IPNTR(5): pointer to the NCV by NCV upper Hessenberg matrix   
                      H in WORKL.   
            IPNTR(6): pointer to the real part of the ritz value array   
                      RITZR in WORKL.   
            IPNTR(7): pointer to the imaginary part of the ritz value array   
                      RITZI in WORKL.   
            IPNTR(8): pointer to the Ritz estimates in array WORKL associated   
                      with the Ritz values located in RITZR and RITZI in WORKL.   

            IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.   

            Note: IPNTR(9:13) is only referenced by dneupd. See Remark 2 below.   

            IPNTR(9):  pointer to the real part of the NCV RITZ values of the   
                       original system.   
            IPNTR(10): pointer to the imaginary part of the NCV RITZ values of   
                       the original system.   
            IPNTR(11): pointer to the NCV corresponding error bounds.   
            IPNTR(12): pointer to the NCV by NCV upper quasi-triangular   
                       Schur matrix for H.   
            IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors   
                       of the upper Hessenberg matrix H. Only referenced by   
                       dneupd if RVEC = .TRUE. See Remark 2 below.   
            -------------------------------------------------------------   

    WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)   
            Distributed array to be used in the basic Arnoldi iteration   
            for reverse communication.  The user should not use WORKD   
            as temporary workspace during the iteration. Upon termination   
            WORKD(1:N) contains B*RESID(1:N). If an invariant subspace   
            associated with the converged Ritz values is desired, see remark   
            2 below, subroutine dneupd uses this output.   
            See Data Distribution Note below.   

    WORKL   Double precision work array of length LWORKL.  (OUTPUT/WORKSPACE)   
            Private (replicated) array on each PE or array allocated on   
            the front end.  See Data Distribution Note below.   

    LWORKL  Integer.  (INPUT)   
            LWORKL must be at least 3*NCV**2 + 6*NCV.   

    INFO    Integer.  (INPUT/OUTPUT)   
            If INFO .EQ. 0, a randomly initial residual vector is used.   
            If INFO .NE. 0, RESID contains the initial residual vector,   
                            possibly from a previous run.   
            Error flag on output.   
            =  0: Normal exit.   
            =  1: Maximum number of iterations taken.   
                  All possible eigenvalues of OP has been found. IPARAM(5)   
                  returns the number of wanted converged Ritz values.   
            =  2: No longer an informational error. Deprecated starting   
                  with release 2 of ARPACK.   
            =  3: No shifts could be applied during a cycle of the   
                  Implicitly restarted Arnoldi iteration. One possibility   
                  is to increase the size of NCV relative to NEV.   
                  See remark 4 below.   
            = -1: N must be positive.   
            = -2: NEV must be positive.   
            = -3: NCV-NEV >= 2 and less than or equal to N.   
            = -4: The maximum number of Arnoldi update iteration   
                  must be greater than zero.   
            = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'   
            = -6: BMAT must be one of 'I' or 'G'.   
            = -7: Length of private work array is not sufficient.   
            = -8: Error return from LAPACK eigenvalue calculation;   
            = -9: Starting vector is zero.   
            = -10: IPARAM(7) must be 1,2,3,4.   
            = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatable.   
            = -12: IPARAM(1) must be equal to 0 or 1.   
            = -9999: Could not build an Arnoldi factorization.   
                     IPARAM(5) returns the size of the current Arnoldi   
                     factorization.   

   \Remarks   
    1. The computed Ritz values are approximate eigenvalues of OP. The   
       selection of WHICH should be made with this in mind when   
       Mode = 3 and 4.  After convergence, approximate eigenvalues of the   
       original problem may be obtained with the ARPACK subroutine dneupd.   

    2. If a basis for the invariant subspace corresponding to the converged Ritz   
       values is needed, the user must call dneupd immediately following   
       completion of dnaupd. This is new starting with release 2 of ARPACK.   

    3. If M can be factored into a Cholesky factorization M = LL'   
       then Mode = 2 should not be selected.  Instead one should use   
       Mode = 1 with  OP = inv(L)*A*inv(L').  Appropriate triangular   
       linear systems should be solved with L and L' rather   
       than computing inverses.  After convergence, an approximate   
       eigenvector z of the original problem is recovered by solving   
       L'z = x  where x is a Ritz vector of OP.   

    4. At present there is no a-priori analysis to guide the selection   
       of NCV relative to NEV.  The only formal requrement is that NCV > NEV + 2.   
       However, it is recommended that NCV .ge. 2*NEV+1.  If many problems of   
       the same type are to be solved, one should experiment with increasing   
       NCV while keeping NEV fixed for a given test problem.  This will   
       usually decrease the required number of OP*x operations but it   
       also increases the work and storage required to maintain the orthogonal   
       basis vectors.  The optimal "cross-over" with respect to CPU time   
       is problem dependent and must be determined empirically.   
       See Chapter 8 of Reference 2 for further information.   

    5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the   
       NP = IPARAM(8) real and imaginary parts of the shifts in locations   
           real part                  imaginary part   
           -----------------------    --------------   
       1   WORKL(IPNTR(14))           WORKL(IPNTR(14)+NP)   
       2   WORKL(IPNTR(14)+1)         WORKL(IPNTR(14)+NP+1)   
                          .                          .   
                          .                          .   
                          .                          .   
       NP  WORKL(IPNTR(14)+NP-1)      WORKL(IPNTR(14)+2*NP-1).   

       Only complex conjugate pairs of shifts may be applied and the pairs   
       must be placed in consecutive locations. The real part of the   
       eigenvalues of the current upper Hessenberg matrix are located in   
       WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1) and the imaginary part   
       in WORKL(IPNTR(7)) through WORKL(IPNTR(7)+NCV-1). They are ordered   
       according to the order defined by WHICH. The complex conjugate   
       pairs are kept together and the associated Ritz estimates are located in   
       WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).   

   -----------------------------------------------------------------------   

   \Data Distribution Note:   

    Fortran-D syntax:   
    ================   
    Double precision resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)   
    decompose  d1(n), d2(n,ncv)   
    align      resid(i) with d1(i)   
    align      v(i,j)   with d2(i,j)   
    align      workd(i) with d1(i)     range (1:n)   
    align      workd(i) with d1(i-n)   range (n+1:2*n)   
    align      workd(i) with d1(i-2*n) range (2*n+1:3*n)   
    distribute d1(block), d2(block,:)   
    replicated workl(lworkl)   

    Cray MPP syntax:   
    ===============   
    Double precision  resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)   
    shared     resid(block), v(block,:), workd(block,:)   
    replicated workl(lworkl)   

    CM2/CM5 syntax:   
    ==============   

   -----------------------------------------------------------------------   

       include   'ex-nonsym.doc'   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \References:   
    1. D.C. Sorensen, "Implicit Application of Polynomial Filters in   
       a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),   
       pp 357-385.   
    2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly   
       Restarted Arnoldi Iteration", Rice University Technical Report   
       TR95-13, Department of Computational and Applied Mathematics.   
    3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for   
       Real Matrices", Linear Algebra and its Applications, vol 88/89,   
       pp 575-595, (1987).   

   \Routines called:   
       dnaup2  ARPACK routine that implements the Implicitly Restarted   
               Arnoldi Iteration.   
       ivout   ARPACK utility routine that prints integers.   
       second  ARPACK utility routine for timing.   
       dvout   ARPACK utility routine that prints vectors.   
       dlamch  LAPACK routine that determines machine constants.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       12/16/93: Version '1.1'   

   \SCCS Information: @(#)   
   FILE: naupd.F   SID: 2.5   DATE OF SID: 8/27/96   RELEASE: 2   

   \Remarks   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdnaupd_(integer *ido, char *bmat, integer *n, char *
	which, integer *nev, doublereal *tol, doublereal *resid, integer *ncv,
	 doublereal *v, integer *ldv, integer *iparam, integer *ipntr, 
	doublereal *workd, doublereal *workl, integer *lworkl, integer *info)
{
    /* Format strings */
    static char fmt_1000[] = "(//,5x,\002==================================="
	    "==========\002,/5x,\002= Nonsymmetric implicit Arnoldi update co"
	    "de =\002,/5x,\002= Version Number: \002,\002 2.4\002,21x,\002 "
	    "=\002,/5x,\002= Version Date:   \002,\002 07/31/96\002,16x,\002 ="
	    "\002,/5x,\002=============================================\002,/"
	    "5x,\002= Summary of timing statistics              =\002,/5x,"
	    "\002=============================================\002,//)";
    static char fmt_1100[] = "(5x,\002Total number update iterations        "
	    "     = \002,i5,/5x,\002Total number of OP*x operations          "
	    "  = \002,i5,/5x,\002Total number of B*x operations             = "
	    "\002,i5,/5x,\002Total number of reorthogonalization steps  = "
	    "\002,i5,/5x,\002Total number of iterative refinement steps = "
	    "\002,i5,/5x,\002Total number of restart steps              = "
	    "\002,i5,/5x,\002Total time in user OP*x operation          = "
	    "\002,f12.6,/5x,\002Total time in user B*x operation           ="
	    " \002,f12.6,/5x,\002Total time in Arnoldi update routine       = "
	    "\002,f12.6,/5x,\002Total time in naup2 routine                ="
	    " \002,f12.6,/5x,\002Total time in basic Arnoldi iteration loop = "
	    "\002,f12.6,/5x,\002Total time in reorthogonalization phase    ="
	    " \002,f12.6,/5x,\002Total time in (re)start vector generation  = "
	    "\002,f12.6,/5x,\002Total time in Hessenberg eig. subproblem   ="
	    " \002,f12.6,/5x,\002Total time in getting the shifts           = "
	    "\002,f12.6,/5x,\002Total time in applying the shifts          ="
	    " \002,f12.6,/5x,\002Total time in convergence testing          = "
	    "\002,f12.6,/5x,\002Total time in computing final Ritz vectors ="
	    " \002,f12.6/)";

    /* System generated locals */
    integer v_dim1, v_offset, i__1, i__2;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *), e_wsfe(
	    void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    integer j;
    real t0, t1;
    IGRAPH_F77_SAVE integer nb, ih, iq, np, iw, ldh, ldq;
    integer nbx = 0;
    IGRAPH_F77_SAVE integer nev0, mode;
    integer ierr;
    IGRAPH_F77_SAVE integer iupd, next;
    integer nopx = 0;
    IGRAPH_F77_SAVE integer levec;
    real trvec, tmvbx;
    IGRAPH_F77_SAVE integer ritzi;
    extern /* Subroutine */ int igraphdvout_(integer *, integer *, doublereal *, 
	    integer *, char *, ftnlen), igraphivout_(integer *, integer *, integer *
	    , integer *, char *, ftnlen);
    IGRAPH_F77_SAVE integer ritzr;
    extern /* Subroutine */ int igraphdnaup2_(integer *, char *, integer *, char *, 
	    integer *, integer *, doublereal *, doublereal *, integer *, 
	    integer *, integer *, integer *, doublereal *, integer *, 
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     doublereal *, integer *, doublereal *, integer *, doublereal *, 
	    integer *);
    real tnaup2, tgetv0;
    extern doublereal igraphdlamch_(char *);
    extern /* Subroutine */ int igraphsecond_(real *);
    integer logfil, ndigit;
    real tneigh;
    integer mnaupd = 0;
    IGRAPH_F77_SAVE integer ishift;
    integer nitref;
    IGRAPH_F77_SAVE integer bounds;
    real tnaupd;
    extern /* Subroutine */ int igraphdstatn_(void);
    real titref, tnaitr;
    IGRAPH_F77_SAVE integer msglvl;
    real tngets, tnapps, tnconv;
    IGRAPH_F77_SAVE integer mxiter;
    integer nrorth = 0, nrstrt = 0;
    real tmvopx;

    /* Fortran I/O blocks */
    static cilist io___30 = { 0, 6, 0, fmt_1000, 0 };
    static cilist io___31 = { 0, 6, 0, fmt_1100, 0 };



/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       Parameter adjustments */
    --workd;
    --resid;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    --iparam;
    --ipntr;
    --workl;

    /* Function Body */
    if (*ido == 0) {

/*        %-------------------------------%   
          | Initialize timing statistics  |   
          | & message level for debugging |   
          %-------------------------------% */

	igraphdstatn_();
	igraphsecond_(&t0);
	msglvl = mnaupd;

/*        %----------------%   
          | Error checking |   
          %----------------% */

	ierr = 0;
	ishift = iparam[1];
	levec = iparam[2];
	mxiter = iparam[3];
	nb = iparam[4];

/*        %--------------------------------------------%   
          | Revision 2 performs only implicit restart. |   
          %--------------------------------------------% */

	iupd = 1;
	mode = iparam[7];

	if (*n <= 0) {
	    ierr = -1;
	} else if (*nev <= 0) {
	    ierr = -2;
	} else if (*ncv <= *nev + 1 || *ncv > *n) {
	    ierr = -3;
	} else if (mxiter <= 0) {
	    ierr = -4;
	} else if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) != 0 && s_cmp(
		which, "SM", (ftnlen)2, (ftnlen)2) != 0 && s_cmp(which, "LR", 
		(ftnlen)2, (ftnlen)2) != 0 && s_cmp(which, "SR", (ftnlen)2, (
		ftnlen)2) != 0 && s_cmp(which, "LI", (ftnlen)2, (ftnlen)2) != 
		0 && s_cmp(which, "SI", (ftnlen)2, (ftnlen)2) != 0) {
	    ierr = -5;
	} else if (*(unsigned char *)bmat != 'I' && *(unsigned char *)bmat != 
		'G') {
	    ierr = -6;
	} else /* if(complicated condition) */ {
/* Computing 2nd power */
	    i__1 = *ncv;
	    if (*lworkl < i__1 * i__1 * 3 + *ncv * 6) {
		ierr = -7;
	    } else if (mode < 1 || mode > 5) {
		ierr = -10;
	    } else if (mode == 1 && *(unsigned char *)bmat == 'G') {
		ierr = -11;
	    } else if (ishift < 0 || ishift > 1) {
		ierr = -12;
	    }
	}

/*        %------------%   
          | Error Exit |   
          %------------% */

	if (ierr != 0) {
	    *info = ierr;
	    *ido = 99;
	    goto L9000;
	}

/*        %------------------------%   
          | Set default parameters |   
          %------------------------% */

	if (nb <= 0) {
	    nb = 1;
	}
	if (*tol <= 0.) {
	    *tol = igraphdlamch_("EpsMach");
	}

/*        %----------------------------------------------%   
          | NP is the number of additional steps to      |   
          | extend the length NEV Lanczos factorization. |   
          | NEV0 is the local variable designating the   |   
          | size of the invariant subspace desired.      |   
          %----------------------------------------------% */

	np = *ncv - *nev;
	nev0 = *nev;

/*        %-----------------------------%   
          | Zero out internal workspace |   
          %-----------------------------%   

   Computing 2nd power */
	i__2 = *ncv;
	i__1 = i__2 * i__2 * 3 + *ncv * 6;
	for (j = 1; j <= i__1; ++j) {
	    workl[j] = 0.;
/* L10: */
	}

/*        %-------------------------------------------------------------%   
          | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |   
          | etc... and the remaining workspace.                         |   
          | Also update pointer to be used on output.                   |   
          | Memory is laid out as follows:                              |   
          | workl(1:ncv*ncv) := generated Hessenberg matrix             |   
          | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary        |   
          |                                   parts of ritz values      |   
          | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds        |   
          | workl(ncv*ncv+3*ncv+1:2*ncv*ncv+3*ncv) := rotation matrix Q |   
          | workl(2*ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) := workspace       |   
          | The final workspace is needed by subroutine dneigh called   |   
          | by dnaup2. Subroutine dneigh calls LAPACK routines for      |   
          | calculating eigenvalues and the last row of the eigenvector |   
          | matrix.                                                     |   
          %-------------------------------------------------------------% */

	ldh = *ncv;
	ldq = *ncv;
	ih = 1;
	ritzr = ih + ldh * *ncv;
	ritzi = ritzr + *ncv;
	bounds = ritzi + *ncv;
	iq = bounds + *ncv;
	iw = iq + ldq * *ncv;
/* Computing 2nd power */
	i__1 = *ncv;
	next = iw + i__1 * i__1 + *ncv * 3;

	ipntr[4] = next;
	ipntr[5] = ih;
	ipntr[6] = ritzr;
	ipntr[7] = ritzi;
	ipntr[8] = bounds;
	ipntr[14] = iw;

    }

/*     %-------------------------------------------------------%   
       | Carry out the Implicitly restarted Arnoldi Iteration. |   
       %-------------------------------------------------------% */

    igraphdnaup2_(ido, bmat, n, which, &nev0, &np, tol, &resid[1], &mode, &iupd, &
	    ishift, &mxiter, &v[v_offset], ldv, &workl[ih], &ldh, &workl[
	    ritzr], &workl[ritzi], &workl[bounds], &workl[iq], &ldq, &workl[
	    iw], &ipntr[1], &workd[1], info);

/*     %--------------------------------------------------%   
       | ido .ne. 99 implies use of reverse communication |   
       | to compute operations involving OP or shifts.    |   
       %--------------------------------------------------% */

    if (*ido == 3) {
	iparam[8] = np;
    }
    if (*ido != 99) {
	goto L9000;
    }

    iparam[3] = mxiter;
    iparam[5] = np;
    iparam[9] = nopx;
    iparam[10] = nbx;
    iparam[11] = nrorth;

/*     %------------------------------------%   
       | Exit if there was an informational |   
       | error within dnaup2.               |   
       %------------------------------------% */

    if (*info < 0) {
	goto L9000;
    }
    if (*info == 2) {
	*info = 3;
    }

    if (msglvl > 0) {
	igraphivout_(&logfil, &disnan__c__1, &mxiter, &ndigit, "_naupd: Number of update i"
		"terations taken", (ftnlen)41);
	igraphivout_(&logfil, &disnan__c__1, &np, &ndigit, "_naupd: Number of wanted \"con"
		"verged\" Ritz values", (ftnlen)48);
	igraphdvout_(&logfil, &np, &workl[ritzr], &ndigit, "_naupd: Real part of t"
		"he final Ritz values", (ftnlen)42);
	igraphdvout_(&logfil, &np, &workl[ritzi], &ndigit, "_naupd: Imaginary part"
		" of the final Ritz values", (ftnlen)47);
	igraphdvout_(&logfil, &np, &workl[bounds], &ndigit, "_naupd: Associated Ri"
		"tz estimates", (ftnlen)33);
    }

    igraphsecond_(&t1);
    tnaupd = t1 - t0;

    if (msglvl > 0) {

/*        %--------------------------------------------------------%   
          | Version Number & Version Date are defined in version.h |   
          %--------------------------------------------------------% */

	s_wsfe(&io___30);
	e_wsfe();
	s_wsfe(&io___31);
	do_fio(&disnan__c__1, (char *)&mxiter, (ftnlen)sizeof(integer));
	do_fio(&disnan__c__1, (char *)&nopx, (ftnlen)sizeof(integer));
	do_fio(&disnan__c__1, (char *)&nbx, (ftnlen)sizeof(integer));
	do_fio(&disnan__c__1, (char *)&nrorth, (ftnlen)sizeof(integer));
	do_fio(&disnan__c__1, (char *)&nitref, (ftnlen)sizeof(integer));
	do_fio(&disnan__c__1, (char *)&nrstrt, (ftnlen)sizeof(integer));
	do_fio(&disnan__c__1, (char *)&tmvopx, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&tmvbx, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&tnaupd, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&tnaup2, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&tnaitr, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&titref, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&tgetv0, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&tneigh, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&tngets, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&tnapps, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&tnconv, (ftnlen)sizeof(real));
	do_fio(&disnan__c__1, (char *)&trvec, (ftnlen)sizeof(real));
	e_wsfe();
    }

L9000:

    return 0;

/*     %---------------%   
       | End of dnaupd |   
       %---------------% */

} /* igraphdnaupd_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static doublereal dlabad__c_b3 = .66666666666666663;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dnconv   

   \Description:   
    Convergence testing for the nonsymmetric Arnoldi eigenvalue routine.   

   \Usage:   
    call dnconv   
       ( N, RITZR, RITZI, BOUNDS, TOL, NCONV )   

   \Arguments   
    N       Integer.  (INPUT)   
            Number of Ritz values to check for convergence.   

    RITZR,  Double precision arrays of length N.  (INPUT)   
    RITZI   Real and imaginary parts of the Ritz values to be checked   
            for convergence.   
    BOUNDS  Double precision array of length N.  (INPUT)   
            Ritz estimates for the Ritz values in RITZR and RITZI.   

    TOL     Double precision scalar.  (INPUT)   
            Desired backward error for a Ritz value to be considered   
            "converged".   

    NCONV   Integer scalar.  (OUTPUT)   
            Number of "converged" Ritz values.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \Routines called:   
       second  ARPACK utility routine for timing.   
       dlamch  LAPACK routine that determines machine constants.   
       dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       xx/xx/92: Version ' 2.1'   

   \SCCS Information: @(#)   
   FILE: nconv.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2   

   \Remarks   
       1. xxxx   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdnconv_(integer *n, doublereal *ritzr, doublereal *ritzi,
	 doublereal *bounds, doublereal *tol, integer *nconv)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Builtin functions */
    double pow_dd(doublereal *, doublereal *);

    /* Local variables */
    integer i__;
    real t0, t1;
    doublereal eps23, temp;
    extern doublereal igraphdlapy2_(doublereal *, doublereal *), igraphdlamch_(char *);
    extern /* Subroutine */ int igraphsecond_(real *);
    real tnconv = 0.;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   

       %---------------%   
       | Local Scalars |   
       %---------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   

       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       %-------------------------------------------------------------%   
       | Convergence test: unlike in the symmetric code, I am not    |   
       | using things like refined error bounds and gap condition    |   
       | because I don't know the exact equivalent concept.          |   
       |                                                             |   
       | Instead the i-th Ritz value is considered "converged" when: |   
       |                                                             |   
       |     bounds(i) .le. ( TOL * | ritz | )                       |   
       |                                                             |   
       | for some appropriate choice of norm.                        |   
       %-------------------------------------------------------------%   

       Parameter adjustments */
    --bounds;
    --ritzi;
    --ritzr;

    /* Function Body */
    igraphsecond_(&t0);

/*     %---------------------------------%   
       | Get machine dependent constant. |   
       %---------------------------------% */

    eps23 = igraphdlamch_("Epsilon-Machine");
    eps23 = pow_dd(&eps23, &dlabad__c_b3);

    *nconv = 0;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MAX */
	d__1 = eps23, d__2 = igraphdlapy2_(&ritzr[i__], &ritzi[i__]);
	temp = max(d__1,d__2);
	if (bounds[i__] <= *tol * temp) {
	    ++(*nconv);
	}
/* L20: */
    }

    igraphsecond_(&t1);
    tnconv += t1 - t0;

    return 0;

/*     %---------------%   
       | End of dnconv |   
       %---------------% */

} /* igraphdnconv_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* > \brief \b DLABAD   

    =========== DOCUMENTATION ===========   

   Online html documentation available at   
              http://www.netlib.org/lapack/explore-html/   

   > \htmlonly   
   > Download DLABAD + dependencies   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlabad.
f">   
   > [TGZ]</a>   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlabad.
f">   
   > [ZIP]</a>   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlabad.
f">   
   > [TXT]</a>   
   > \endhtmlonly   

    Definition:   
    ===========   

         SUBROUTINE DLABAD( SMALL, LARGE )   

         DOUBLE PRECISION   LARGE, SMALL   


   > \par Purpose:   
    =============   
   >   
   > \verbatim   
   >   
   > DLABAD takes as input the values computed by DLAMCH for underflow and   
   > overflow, and returns the square root of each of these values if the   
   > log of LARGE is sufficiently large.  This subroutine is intended to   
   > identify machines with a large exponent range, such as the Crays, and   
   > redefine the underflow and overflow limits to be the square roots of   
   > the values computed by DLAMCH.  This subroutine is needed because   
   > DLAMCH does not compensate for poor arithmetic in the upper half of   
   > the exponent range, as is found on a Cray.   
   > \endverbatim   

    Arguments:   
    ==========   

   > \param[in,out] SMALL   
   > \verbatim   
   >          SMALL is DOUBLE PRECISION   
   >          On entry, the underflow threshold as computed by DLAMCH.   
   >          On exit, if LOG10(LARGE) is sufficiently large, the square   
   >          root of SMALL, otherwise unchanged.   
   > \endverbatim   
   >   
   > \param[in,out] LARGE   
   > \verbatim   
   >          LARGE is DOUBLE PRECISION   
   >          On entry, the overflow threshold as computed by DLAMCH.   
   >          On exit, if LOG10(LARGE) is sufficiently large, the square   
   >          root of LARGE, otherwise unchanged.   
   > \endverbatim   

    Authors:   
    ========   

   > \author Univ. of Tennessee   
   > \author Univ. of California Berkeley   
   > \author Univ. of Colorado Denver   
   > \author NAG Ltd.   

   > \date November 2011   

   > \ingroup auxOTHERauxiliary   

    =====================================================================   
   Subroutine */ int igraphdlabad_(doublereal *small, doublereal *large)
{
    /* Builtin functions */
    double d_lg10(doublereal *), sqrt(doublereal);


/*  -- LAPACK auxiliary routine (version 3.4.0) --   
    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
       November 2011   


    =====================================================================   


       If it looks like we're on a Cray, take the square root of   
       SMALL and LARGE to avoid overflow and underflow problems. */

    if (d_lg10(large) > 2e3) {
	*small = sqrt(*small);
	*large = sqrt(*large);
    }

    return 0;

/*     End of DLABAD */

} /* igraphdlabad_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer dlacpy__c__1 = 1;

/* > \brief \b DLANHS returns the value of the 1-norm, Frobenius norm, infinity-norm, or the largest absolute 
value of any element of an upper Hessenberg matrix.   

    =========== DOCUMENTATION ===========   

   Online html documentation available at   
              http://www.netlib.org/lapack/explore-html/   

   > \htmlonly   
   > Download DLANHS + dependencies   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/dlanhs.
f">   
   > [TGZ]</a>   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/dlanhs.
f">   
   > [ZIP]</a>   
   > <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/dlanhs.
f">   
   > [TXT]</a>   
   > \endhtmlonly   

    Definition:   
    ===========   

         DOUBLE PRECISION FUNCTION DLANHS( NORM, N, A, LDA, WORK )   

         CHARACTER          NORM   
         INTEGER            LDA, N   
         DOUBLE PRECISION   A( LDA, * ), WORK( * )   


   > \par Purpose:   
    =============   
   >   
   > \verbatim   
   >   
   > DLANHS  returns the value of the one norm,  or the Frobenius norm, or   
   > the  infinity norm,  or the  element of  largest absolute value  of a   
   > Hessenberg matrix A.   
   > \endverbatim   
   >   
   > \return DLANHS   
   > \verbatim   
   >   
   >    DLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'   
   >             (   
   >             ( norm1(A),         NORM = '1', 'O' or 'o'   
   >             (   
   >             ( normI(A),         NORM = 'I' or 'i'   
   >             (   
   >             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'   
   >   
   > where  norm1  denotes the  one norm of a matrix (maximum column sum),   
   > normI  denotes the  infinity norm  of a matrix  (maximum row sum) and   
   > normF  denotes the  Frobenius norm of a matrix (square root of sum of   
   > squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.   
   > \endverbatim   

    Arguments:   
    ==========   

   > \param[in] NORM   
   > \verbatim   
   >          NORM is CHARACTER*1   
   >          Specifies the value to be returned in DLANHS as described   
   >          above.   
   > \endverbatim   
   >   
   > \param[in] N   
   > \verbatim   
   >          N is INTEGER   
   >          The order of the matrix A.  N >= 0.  When N = 0, DLANHS is   
   >          set to zero.   
   > \endverbatim   
   >   
   > \param[in] A   
   > \verbatim   
   >          A is DOUBLE PRECISION array, dimension (LDA,N)   
   >          The n by n upper Hessenberg matrix A; the part of A below the   
   >          first sub-diagonal is not referenced.   
   > \endverbatim   
   >   
   > \param[in] LDA   
   > \verbatim   
   >          LDA is INTEGER   
   >          The leading dimension of the array A.  LDA >= max(N,1).   
   > \endverbatim   
   >   
   > \param[out] WORK   
   > \verbatim   
   >          WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),   
   >          where LWORK >= N when NORM = 'I'; otherwise, WORK is not   
   >          referenced.   
   > \endverbatim   

    Authors:   
    ========   

   > \author Univ. of Tennessee   
   > \author Univ. of California Berkeley   
   > \author Univ. of Colorado Denver   
   > \author NAG Ltd.   

   > \date September 2012   

   > \ingroup doubleOTHERauxiliary   

    ===================================================================== */
doublereal igraphdlanhs_(char *norm, integer *n, doublereal *a, integer *lda, 
	doublereal *work)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3, i__4;
    doublereal ret_val, d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    integer i__, j;
    doublereal sum, scale;
    extern logical igraphlsame_(char *, char *);
    doublereal value = 0.;
    extern logical igraphdisnan_(doublereal *);
    extern /* Subroutine */ int igraphdlassq_(integer *, doublereal *, integer *, 
	    doublereal *, doublereal *);


/*  -- LAPACK auxiliary routine (version 3.4.2) --   
    -- LAPACK is a software package provided by Univ. of Tennessee,    --   
    -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--   
       September 2012   


   =====================================================================   


       Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --work;

    /* Function Body */
    if (*n == 0) {
	value = 0.;
    } else if (igraphlsame_(norm, "M")) {

/*        Find max(abs(A(i,j))). */

	value = 0.;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
	    i__3 = *n, i__4 = j + 1;
	    i__2 = min(i__3,i__4);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		sum = (d__1 = a[i__ + j * a_dim1], abs(d__1));
		if (value < sum || igraphdisnan_(&sum)) {
		    value = sum;
		}
/* L10: */
	    }
/* L20: */
	}
    } else if (igraphlsame_(norm, "O") || *(unsigned char *)
	    norm == '1') {

/*        Find norm1(A). */

	value = 0.;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
	    sum = 0.;
/* Computing MIN */
	    i__3 = *n, i__4 = j + 1;
	    i__2 = min(i__3,i__4);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		sum += (d__1 = a[i__ + j * a_dim1], abs(d__1));
/* L30: */
	    }
	    if (value < sum || igraphdisnan_(&sum)) {
		value = sum;
	    }
/* L40: */
	}
    } else if (igraphlsame_(norm, "I")) {

/*        Find normI(A). */

	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    work[i__] = 0.;
/* L50: */
	}
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
	    i__3 = *n, i__4 = j + 1;
	    i__2 = min(i__3,i__4);
	    for (i__ = 1; i__ <= i__2; ++i__) {
		work[i__] += (d__1 = a[i__ + j * a_dim1], abs(d__1));
/* L60: */
	    }
/* L70: */
	}
	value = 0.;
	i__1 = *n;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    sum = work[i__];
	    if (value < sum || igraphdisnan_(&sum)) {
		value = sum;
	    }
/* L80: */
	}
    } else if (igraphlsame_(norm, "F") || igraphlsame_(norm, "E")) {

/*        Find normF(A). */

	scale = 0.;
	sum = 1.;
	i__1 = *n;
	for (j = 1; j <= i__1; ++j) {
/* Computing MIN */
	    i__3 = *n, i__4 = j + 1;
	    i__2 = min(i__3,i__4);
	    igraphdlassq_(&i__2, &a[j * a_dim1 + 1], &dlacpy__c__1, &scale, &sum);
/* L90: */
	}
	value = scale * sqrt(sum);
    }

    ret_val = value;
    return ret_val;

/*     End of DLANHS */

} /* igraphdlanhs_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static logical dladiv__c_true = TRUE_;
static integer dladiv__c__1 = 1;
static doublereal dladiv__c_b18 = 1.;
static doublereal dladiv__c_b20 = 0.;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dneigh   

   \Description:   
    Compute the eigenvalues of the current upper Hessenberg matrix   
    and the corresponding Ritz estimates given the current residual norm.   

   \Usage:   
    call dneigh   
       ( RNORM, N, H, LDH, RITZR, RITZI, BOUNDS, Q, LDQ, WORKL, IERR )   

   \Arguments   
    RNORM   Double precision scalar.  (INPUT)   
            Residual norm corresponding to the current upper Hessenberg   
            matrix H.   

    N       Integer.  (INPUT)   
            Size of the matrix H.   

    H       Double precision N by N array.  (INPUT)   
            H contains the current upper Hessenberg matrix.   

    LDH     Integer.  (INPUT)   
            Leading dimension of H exactly as declared in the calling   
            program.   

    RITZR,  Double precision arrays of length N.  (OUTPUT)   
    RITZI   On output, RITZR(1:N) (resp. RITZI(1:N)) contains the real   
            (respectively imaginary) parts of the eigenvalues of H.   

    BOUNDS  Double precision array of length N.  (OUTPUT)   
            On output, BOUNDS contains the Ritz estimates associated with   
            the eigenvalues RITZR and RITZI.  This is equal to RNORM   
            times the last components of the eigenvectors corresponding   
            to the eigenvalues in RITZR and RITZI.   

    Q       Double precision N by N array.  (WORKSPACE)   
            Workspace needed to store the eigenvectors of H.   

    LDQ     Integer.  (INPUT)   
            Leading dimension of Q exactly as declared in the calling   
            program.   

    WORKL   Double precision work array of length N**2 + 3*N.  (WORKSPACE)   
            Private (replicated) array on each PE or array allocated on   
            the front end.  This is needed to keep the full Schur form   
            of H and also in the calculation of the eigenvectors of H.   

    IERR    Integer.  (OUTPUT)   
            Error exit flag from dlaqrb or dtrevc.   

   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \Routines called:   
       dlaqrb  ARPACK routine to compute the real Schur form of an   
               upper Hessenberg matrix and last row of the Schur vectors.   
       second  ARPACK utility routine for timing.   
       dmout   ARPACK utility routine that prints matrices   
       dvout   ARPACK utility routine that prints vectors.   
       dlacpy  LAPACK matrix copy routine.   
       dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.   
       dtrevc  LAPACK routine to compute the eigenvectors of a matrix   
               in upper quasi-triangular form   
       dgemv   Level 2 BLAS routine for matrix vector multiplication.   
       dcopy   Level 1 BLAS that copies one vector to another .   
       dnrm2   Level 1 BLAS that computes the norm of a vector.   
       dscal   Level 1 BLAS that scales a vector.   


   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       xx/xx/92: Version ' 2.1'   

   \SCCS Information: @(#)   
   FILE: neigh.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2   

   \Remarks   
       None   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdneigh_(doublereal *rnorm, integer *n, doublereal *h__, 
	integer *ldh, doublereal *ritzr, doublereal *ritzi, doublereal *
	bounds, doublereal *q, integer *ldq, doublereal *workl, integer *ierr)
{
    /* System generated locals */
    integer h_dim1, h_offset, q_dim1, q_offset, i__1;
    doublereal d__1, d__2;

    /* Local variables */
    integer i__;
    real t0, t1;
    doublereal vl[1], temp;
    extern doublereal igraphdnrm2_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int igraphdscal_(integer *, doublereal *, doublereal *, 
	    integer *);
    integer iconj;
    extern /* Subroutine */ int igraphdgemv_(char *, integer *, integer *, 
	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
	    doublereal *, doublereal *, integer *), igraphdmout_(integer *, 
	    integer *, integer *, doublereal *, integer *, integer *, char *, 
	    ftnlen), igraphdvout_(integer *, integer *, doublereal *, integer *, 
	    char *, ftnlen);
    extern doublereal igraphdlapy2_(doublereal *, doublereal *);
    extern /* Subroutine */ int igraphdlaqrb_(logical *, integer *, integer *, 
	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
	    doublereal *, integer *);
    integer mneigh = 0;
    extern /* Subroutine */ int igraphsecond_(real *), igraphdlacpy_(char *, integer *, 
	    integer *, doublereal *, integer *, doublereal *, integer *);
    integer logfil, ndigit;
    logical select[1];
    real tneigh = 0.;
    extern /* Subroutine */ int igraphdtrevc_(char *, char *, logical *, integer *, 
	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
	    integer *, integer *, integer *, doublereal *, integer *);
    integer msglvl;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %------------------------%   
       | Local Scalars & Arrays |   
       %------------------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %---------------------%   
       | Intrinsic Functions |   
       %---------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   


       %-------------------------------%   
       | Initialize timing statistics  |   
       | & message level for debugging |   
       %-------------------------------%   

       Parameter adjustments */
    --workl;
    --bounds;
    --ritzi;
    --ritzr;
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    q_dim1 = *ldq;
    q_offset = 1 + q_dim1;
    q -= q_offset;

    /* Function Body */
    igraphsecond_(&t0);
    msglvl = mneigh;

    if (msglvl > 2) {
	igraphdmout_(&logfil, n, n, &h__[h_offset], ldh, &ndigit, "_neigh: Enterin"
		"g upper Hessenberg matrix H ", (ftnlen)43);
    }

/*     %-----------------------------------------------------------%   
       | 1. Compute the eigenvalues, the last components of the    |   
       |    corresponding Schur vectors and the full Schur form T  |   
       |    of the current upper Hessenberg matrix H.              |   
       | dlaqrb returns the full Schur form of H in WORKL(1:N**2)  |   
       | and the last components of the Schur vectors in BOUNDS.   |   
       %-----------------------------------------------------------% */

    igraphdlacpy_("All", n, n, &h__[h_offset], ldh, &workl[1], n);
    igraphdlaqrb_(&dladiv__c_true, n, &dladiv__c__1, n, &workl[1], n, &ritzr[1], &ritzi[1], &bounds[
	    1], ierr);
    if (*ierr != 0) {
	goto L9000;
    }

    if (msglvl > 1) {
	igraphdvout_(&logfil, n, &bounds[1], &ndigit, "_neigh: last row of the Sch"
		"ur matrix for H", (ftnlen)42);
    }

/*     %-----------------------------------------------------------%   
       | 2. Compute the eigenvectors of the full Schur form T and  |   
       |    apply the last components of the Schur vectors to get  |   
       |    the last components of the corresponding eigenvectors. |   
       | Remember that if the i-th and (i+1)-st eigenvalues are    |   
       | complex conjugate pairs, then the real & imaginary part   |   
       | of the eigenvector components are split across adjacent   |   
       | columns of Q.                                             |   
       %-----------------------------------------------------------% */

    igraphdtrevc_("R", "A", select, n, &workl[1], n, vl, n, &q[q_offset], ldq, n, n,
	     &workl[*n * *n + 1], ierr);

    if (*ierr != 0) {
	goto L9000;
    }

/*     %------------------------------------------------%   
       | Scale the returning eigenvectors so that their |   
       | euclidean norms are all one. LAPACK subroutine |   
       | dtrevc returns each eigenvector normalized so  |   
       | that the element of largest magnitude has      |   
       | magnitude 1; here the magnitude of a complex   |   
       | number (x,y) is taken to be |x| + |y|.         |   
       %------------------------------------------------% */

    iconj = 0;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if ((d__1 = ritzi[i__], abs(d__1)) <= 0.) {

/*           %----------------------%   
             | Real eigenvalue case |   
             %----------------------% */

	    temp = igraphdnrm2_(n, &q[i__ * q_dim1 + 1], &dladiv__c__1);
	    d__1 = 1. / temp;
	    igraphdscal_(n, &d__1, &q[i__ * q_dim1 + 1], &dladiv__c__1);
	} else {

/*           %-------------------------------------------%   
             | Complex conjugate pair case. Note that    |   
             | since the real and imaginary part of      |   
             | the eigenvector are stored in consecutive |   
             | columns, we further normalize by the      |   
             | square root of two.                       |   
             %-------------------------------------------% */

	    if (iconj == 0) {
		d__1 = igraphdnrm2_(n, &q[i__ * q_dim1 + 1], &dladiv__c__1);
		d__2 = igraphdnrm2_(n, &q[(i__ + 1) * q_dim1 + 1], &dladiv__c__1);
		temp = igraphdlapy2_(&d__1, &d__2);
		d__1 = 1. / temp;
		igraphdscal_(n, &d__1, &q[i__ * q_dim1 + 1], &dladiv__c__1);
		d__1 = 1. / temp;
		igraphdscal_(n, &d__1, &q[(i__ + 1) * q_dim1 + 1], &dladiv__c__1);
		iconj = 1;
	    } else {
		iconj = 0;
	    }
	}
/* L10: */
    }

    igraphdgemv_("T", n, n, &dladiv__c_b18, &q[q_offset], ldq, &bounds[1], &dladiv__c__1, &dladiv__c_b20, &
	    workl[1], &dladiv__c__1);

    if (msglvl > 1) {
	igraphdvout_(&logfil, n, &workl[1], &ndigit, "_neigh: Last row of the eige"
		"nvector matrix for H", (ftnlen)48);
    }

/*     %----------------------------%   
       | Compute the Ritz estimates |   
       %----------------------------% */

    iconj = 0;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if ((d__1 = ritzi[i__], abs(d__1)) <= 0.) {

/*           %----------------------%   
             | Real eigenvalue case |   
             %----------------------% */

	    bounds[i__] = *rnorm * (d__1 = workl[i__], abs(d__1));
	} else {

/*           %-------------------------------------------%   
             | Complex conjugate pair case. Note that    |   
             | since the real and imaginary part of      |   
             | the eigenvector are stored in consecutive |   
             | columns, we need to take the magnitude    |   
             | of the last components of the two vectors |   
             %-------------------------------------------% */

	    if (iconj == 0) {
		bounds[i__] = *rnorm * igraphdlapy2_(&workl[i__], &workl[i__ + 1]);
		bounds[i__ + 1] = bounds[i__];
		iconj = 1;
	    } else {
		iconj = 0;
	    }
	}
/* L20: */
    }

    if (msglvl > 2) {
	igraphdvout_(&logfil, n, &ritzr[1], &ndigit, "_neigh: Real part of the eig"
		"envalues of H", (ftnlen)41);
	igraphdvout_(&logfil, n, &ritzi[1], &ndigit, "_neigh: Imaginary part of th"
		"e eigenvalues of H", (ftnlen)46);
	igraphdvout_(&logfil, n, &bounds[1], &ndigit, "_neigh: Ritz estimates for "
		"the eigenvalues of H", (ftnlen)47);
    }

    igraphsecond_(&t1);
    tneigh += t1 - t0;

L9000:
    return 0;

/*     %---------------%   
       | End of dneigh |   
       %---------------% */

} /* igraphdneigh_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static logical dlae2__c_true = TRUE_;
static integer dlae2__c__1 = 1;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dngets   

   \Description:   
    Given the eigenvalues of the upper Hessenberg matrix H,   
    computes the NP shifts AMU that are zeros of the polynomial of   
    degree NP which filters out components of the unwanted eigenvectors   
    corresponding to the AMU's based on some given criteria.   

    NOTE: call this even in the case of user specified shifts in order   
    to sort the eigenvalues, and error bounds of H for later use.   

   \Usage:   
    call dngets   
       ( ISHIFT, WHICH, KEV, NP, RITZR, RITZI, BOUNDS, SHIFTR, SHIFTI )   

   \Arguments   
    ISHIFT  Integer.  (INPUT)   
            Method for selecting the implicit shifts at each iteration.   
            ISHIFT = 0: user specified shifts   
            ISHIFT = 1: exact shift with respect to the matrix H.   

    WHICH   Character*2.  (INPUT)   
            Shift selection criteria.   
            'LM' -> want the KEV eigenvalues of largest magnitude.   
            'SM' -> want the KEV eigenvalues of smallest magnitude.   
            'LR' -> want the KEV eigenvalues of largest real part.   
            'SR' -> want the KEV eigenvalues of smallest real part.   
            'LI' -> want the KEV eigenvalues of largest imaginary part.   
            'SI' -> want the KEV eigenvalues of smallest imaginary part.   

    KEV      Integer.  (INPUT/OUTPUT)   
             INPUT: KEV+NP is the size of the matrix H.   
             OUTPUT: Possibly increases KEV by one to keep complex conjugate   
             pairs together.   

    NP       Integer.  (INPUT/OUTPUT)   
             Number of implicit shifts to be computed.   
             OUTPUT: Possibly decreases NP by one to keep complex conjugate   
             pairs together.   

    RITZR,  Double precision array of length KEV+NP.  (INPUT/OUTPUT)   
    RITZI   On INPUT, RITZR and RITZI contain the real and imaginary   
            parts of the eigenvalues of H.   
            On OUTPUT, RITZR and RITZI are sorted so that the unwanted   
            eigenvalues are in the first NP locations and the wanted   
            portion is in the last KEV locations.  When exact shifts are   
            selected, the unwanted part corresponds to the shifts to   
            be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues   
            are further sorted so that the ones with largest Ritz values   
            are first.   

    BOUNDS  Double precision array of length KEV+NP.  (INPUT/OUTPUT)   
            Error bounds corresponding to the ordering in RITZ.   

    SHIFTR, SHIFTI  *** USE deprecated as of version 2.1. ***   


   \EndDoc   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \Routines called:   
       dsortc  ARPACK sorting routine.   
       dcopy   Level 1 BLAS that copies one vector to another .   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       xx/xx/92: Version ' 2.1'   

   \SCCS Information: @(#)   
   FILE: ngets.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2   

   \Remarks   
       1. xxxx   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdngets_(integer *ishift, char *which, integer *kev, 
	integer *np, doublereal *ritzr, doublereal *ritzi, doublereal *bounds,
	 doublereal *shiftr, doublereal *shifti)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    real t0, t1;
    extern /* Subroutine */ int igraphdvout_(integer *, integer *, doublereal *, 
	    integer *, char *, ftnlen), igraphivout_(integer *, integer *, integer *
	    , integer *, char *, ftnlen), igraphsecond_(real *);
    integer logfil, ndigit, mngets = 0;
    extern /* Subroutine */ int igraphdsortc_(char *, logical *, integer *, 
	    doublereal *, doublereal *, doublereal *);
    integer msglvl;
    real tngets = 0.;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %----------------------%   
       | Intrinsics Functions |   
       %----------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       %-------------------------------%   
       | Initialize timing statistics  |   
       | & message level for debugging |   
       %-------------------------------%   

       Parameter adjustments */
    --bounds;
    --ritzi;
    --ritzr;
    --shiftr;
    --shifti;

    /* Function Body */
    igraphsecond_(&t0);
    msglvl = mngets;

/*     %----------------------------------------------------%   
       | LM, SM, LR, SR, LI, SI case.                       |   
       | Sort the eigenvalues of H into the desired order   |   
       | and apply the resulting order to BOUNDS.           |   
       | The eigenvalues are sorted so that the wanted part |   
       | are always in the last KEV locations.              |   
       | We first do a pre-processing sort in order to keep |   
       | complex conjugate pairs together                   |   
       %----------------------------------------------------% */

    if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0) {
	i__1 = *kev + *np;
	igraphdsortc_("LR", &dlae2__c_true, &i__1, &ritzr[1], &ritzi[1], &bounds[1]);
    } else if (s_cmp(which, "SM", (ftnlen)2, (ftnlen)2) == 0) {
	i__1 = *kev + *np;
	igraphdsortc_("SR", &dlae2__c_true, &i__1, &ritzr[1], &ritzi[1], &bounds[1]);
    } else if (s_cmp(which, "LR", (ftnlen)2, (ftnlen)2) == 0) {
	i__1 = *kev + *np;
	igraphdsortc_("LM", &dlae2__c_true, &i__1, &ritzr[1], &ritzi[1], &bounds[1]);
    } else if (s_cmp(which, "SR", (ftnlen)2, (ftnlen)2) == 0) {
	i__1 = *kev + *np;
	igraphdsortc_("SM", &dlae2__c_true, &i__1, &ritzr[1], &ritzi[1], &bounds[1]);
    } else if (s_cmp(which, "LI", (ftnlen)2, (ftnlen)2) == 0) {
	i__1 = *kev + *np;
	igraphdsortc_("LM", &dlae2__c_true, &i__1, &ritzr[1], &ritzi[1], &bounds[1]);
    } else if (s_cmp(which, "SI", (ftnlen)2, (ftnlen)2) == 0) {
	i__1 = *kev + *np;
	igraphdsortc_("SM", &dlae2__c_true, &i__1, &ritzr[1], &ritzi[1], &bounds[1]);
    }

    i__1 = *kev + *np;
    igraphdsortc_(which, &dlae2__c_true, &i__1, &ritzr[1], &ritzi[1], &bounds[1]);

/*     %-------------------------------------------------------%   
       | Increase KEV by one if the ( ritzr(np),ritzi(np) )    |   
       | = ( ritzr(np+1),-ritzi(np+1) ) and ritz(np) .ne. zero |   
       | Accordingly decrease NP by one. In other words keep   |   
       | complex conjugate pairs together.                     |   
       %-------------------------------------------------------% */

    if (ritzr[*np + 1] - ritzr[*np] == 0. && ritzi[*np + 1] + ritzi[*np] == 
	    0.) {
	--(*np);
	++(*kev);
    }

    if (*ishift == 1) {

/*        %-------------------------------------------------------%   
          | Sort the unwanted Ritz values used as shifts so that  |   
          | the ones with largest Ritz estimates are first        |   
          | This will tend to minimize the effects of the         |   
          | forward instability of the iteration when they shifts |   
          | are applied in subroutine dnapps.                     |   
          | Be careful and use 'SR' since we want to sort BOUNDS! |   
          %-------------------------------------------------------% */

	igraphdsortc_("SR", &dlae2__c_true, np, &bounds[1], &ritzr[1], &ritzi[1]);
    }

    igraphsecond_(&t1);
    tngets += t1 - t0;

    if (msglvl > 0) {
	igraphivout_(&logfil, &dlae2__c__1, kev, &ndigit, "_ngets: KEV is", (ftnlen)14);
	igraphivout_(&logfil, &dlae2__c__1, np, &ndigit, "_ngets: NP is", (ftnlen)13);
	i__1 = *kev + *np;
	igraphdvout_(&logfil, &i__1, &ritzr[1], &ndigit, "_ngets: Eigenvalues of c"
		"urrent H matrix -- real part", (ftnlen)52);
	i__1 = *kev + *np;
	igraphdvout_(&logfil, &i__1, &ritzi[1], &ndigit, "_ngets: Eigenvalues of c"
		"urrent H matrix -- imag part", (ftnlen)52);
	i__1 = *kev + *np;
	igraphdvout_(&logfil, &i__1, &bounds[1], &ndigit, "_ngets: Ritz estimates "
		"of the current KEV+NP Ritz values", (ftnlen)56);
    }

    return 0;

/*     %---------------%   
       | End of dngets |   
       %---------------% */

} /* igraphdngets_ */


/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static integer dlaev2__c__1 = 1;

/* -----------------------------------------------------------------------   
   \BeginDoc   

   \Name: dlaqrb   

   \Description:   
    Compute the eigenvalues and the Schur decomposition of an upper   
    Hessenberg submatrix in rows and columns ILO to IHI.  Only the   
    last component of the Schur vectors are computed.   

    This is mostly a modification of the LAPACK routine dlahqr.   

   \Usage:   
    call dlaqrb   
       ( WANTT, N, ILO, IHI, H, LDH, WR, WI,  Z, INFO )   

   \Arguments   
    WANTT   Logical variable.  (INPUT)   
            = .TRUE. : the full Schur form T is required;   
            = .FALSE.: only eigenvalues are required.   

    N       Integer.  (INPUT)   
            The order of the matrix H.  N >= 0.   

    ILO     Integer.  (INPUT)   
    IHI     Integer.  (INPUT)   
            It is assumed that H is already upper quasi-triangular in   
            rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless   
            ILO = 1). SLAQRB works primarily with the Hessenberg   
            submatrix in rows and columns ILO to IHI, but applies   
            transformations to all of H if WANTT is .TRUE..   
            1 <= ILO <= max(1,IHI); IHI <= N.   

    H       Double precision array, dimension (LDH,N).  (INPUT/OUTPUT)   
            On entry, the upper Hessenberg matrix H.   
            On exit, if WANTT is .TRUE., H is upper quasi-triangular in   
            rows and columns ILO:IHI, with any 2-by-2 diagonal blocks in   
            standard form. If WANTT is .FALSE., the contents of H are   
            unspecified on exit.   

    LDH     Integer.  (INPUT)   
            The leading dimension of the array H. LDH >= max(1,N).   

    WR      Double precision array, dimension (N).  (OUTPUT)   
    WI      Double precision array, dimension (N).  (OUTPUT)   
            The real and imaginary parts, respectively, of the computed   
            eigenvalues ILO to IHI are stored in the corresponding   
            elements of WR and WI. If two eigenvalues are computed as a   
            complex conjugate pair, they are stored in consecutive   
            elements of WR and WI, say the i-th and (i+1)th, with   
            WI(i) > 0 and WI(i+1) < 0. If WANTT is .TRUE., the   
            eigenvalues are stored in the same order as on the diagonal   
            of the Schur form returned in H, with WR(i) = H(i,i), and, if   
            H(i:i+1,i:i+1) is a 2-by-2 diagonal block,   
            WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).   

    Z       Double precision array, dimension (N).  (OUTPUT)   
            On exit Z contains the last components of the Schur vectors.   

    INFO    Integer.  (OUPUT)   
            = 0: successful exit   
            > 0: SLAQRB failed to compute all the eigenvalues ILO to IHI   
                 in a total of 30*(IHI-ILO+1) iterations; if INFO = i,   
                 elements i+1:ihi of WR and WI contain those eigenvalues   
                 which have been successfully computed.   

   \Remarks   
    1. None.   

   -----------------------------------------------------------------------   

   \BeginLib   

   \Local variables:   
       xxxxxx  real   

   \Routines called:   
       dlabad  LAPACK routine that computes machine constants.   
       dlamch  LAPACK routine that determines machine constants.   
       dlanhs  LAPACK routine that computes various norms of a matrix.   
       dlanv2  LAPACK routine that computes the Schur factorization of   
               2 by 2 nonsymmetric matrix in standard form.   
       dlarfg  LAPACK Householder reflection construction routine.   
       dcopy   Level 1 BLAS that copies one vector to another.   
       drot    Level 1 BLAS that applies a rotation to a 2 by 2 matrix.   

   \Author   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Dept. of Computational &     Houston, Texas   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       xx/xx/92: Version ' 2.4'   
                 Modified from the LAPACK routine dlahqr so that only the   
                 last component of the Schur vectors are computed.   

   \SCCS Information: @(#)   
   FILE: laqrb.F   SID: 2.2   DATE OF SID: 8/27/96   RELEASE: 2   

   \Remarks   
       1. None   

   \EndLib   

   -----------------------------------------------------------------------   

   Subroutine */ int igraphdlaqrb_(logical *wantt, integer *n, integer *ilo, 
	integer *ihi, doublereal *h__, integer *ldh, doublereal *wr, 
	doublereal *wi, doublereal *z__, integer *info)
{
    /* System generated locals */
    integer h_dim1, h_offset, i__1, i__2, i__3, i__4;
    doublereal d__1, d__2;

    /* Local variables */
    integer i__, j, k, l, m;
    doublereal s, v[3];
    integer i1, i2;
    doublereal t1, t2, t3, v1, v2, v3, h00, h10, h11, h12, h21, h22, h33, h44;
    integer nh;
    doublereal cs;
    integer nr;
    doublereal sn, h33s, h44s;
    integer itn, its;
    doublereal ulp, sum, tst1, h43h34, unfl, ovfl;
    extern /* Subroutine */ int igraphdrot_(integer *, doublereal *, integer *, 
	    doublereal *, integer *, doublereal *, doublereal *);
    doublereal work[1];
    extern /* Subroutine */ int igraphdcopy_(integer *, doublereal *, integer *, 
	    doublereal *, integer *), igraphdlanv2_(doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *, 
	    doublereal *, doublereal *, doublereal *, doublereal *), igraphdlabad_(
	    doublereal *, doublereal *);
    extern doublereal igraphdlamch_(char *);
    extern /* Subroutine */ int igraphdlarfg_(integer *, doublereal *, doublereal *,
	     integer *, doublereal *);
    extern doublereal igraphdlanhs_(char *, integer *, doublereal *, integer *, 
	    doublereal *);
    doublereal smlnum;


/*     %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %------------------------%   
       | Local Scalars & Arrays |   
       %------------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       Parameter adjustments */
    h_dim1 = *ldh;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;
    --wr;
    --wi;
    --z__;

    /* Function Body */
    *info = 0;

/*     %--------------------------%   
       | Quick return if possible |   
       %--------------------------% */

    if (*n == 0) {
	return 0;
    }
    if (*ilo == *ihi) {
	wr[*ilo] = h__[*ilo + *ilo * h_dim1];
	wi[*ilo] = 0.;
	return 0;
    }

/*     %---------------------------------------------%   
       | Initialize the vector of last components of |   
       | the Schur vectors for accumulation.         |   
       %---------------------------------------------% */

    i__1 = *n - 1;
    for (j = 1; j <= i__1; ++j) {
	z__[j] = 0.;
/* L5: */
    }
    z__[*n] = 1.;

    nh = *ihi - *ilo + 1;

/*     %-------------------------------------------------------------%   
       | Set machine-dependent constants for the stopping criterion. |   
       | If norm(H) <= sqrt(OVFL), overflow should not occur.        |   
       %-------------------------------------------------------------% */

    unfl = igraphdlamch_("safe minimum");
    ovfl = 1. / unfl;
    igraphdlabad_(&unfl, &ovfl);
    ulp = igraphdlamch_("precision");
    smlnum = unfl * (nh / ulp);

/*     %---------------------------------------------------------------%   
       | I1 and I2 are the indices of the first row and last column    |   
       | of H to which transformations must be applied. If eigenvalues |   
       | only are computed, I1 and I2 are set inside the main loop.    |   
       | Zero out H(J+2,J) = ZERO for J=1:N if WANTT = .TRUE.          |   
       | else H(J+2,J) for J=ILO:IHI-ILO-1 if WANTT = .FALSE.          |   
       %---------------------------------------------------------------% */

    if (*wantt) {
	i1 = 1;
	i2 = *n;
	i__1 = i2 - 2;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    h__[i1 + i__ + 1 + i__ * h_dim1] = 0.;
/* L8: */
	}
    } else {
	i__1 = *ihi - *ilo - 1;
	for (i__ = 1; i__ <= i__1; ++i__) {
	    h__[*ilo + i__ + 1 + (*ilo + i__ - 1) * h_dim1] = 0.;
/* L9: */
	}
    }

/*     %---------------------------------------------------%   
       | ITN is the total number of QR iterations allowed. |   
       %---------------------------------------------------% */

    itn = nh * 30;

/*     ------------------------------------------------------------------   
       The main loop begins here. I is the loop index and decreases from   
       IHI to ILO in steps of 1 or 2. Each iteration of the loop works   
       with the active submatrix in rows and columns L to I.   
       Eigenvalues I+1 to IHI have already converged. Either L = ILO or   
       H(L,L-1) is negligible so that the matrix splits.   
       ------------------------------------------------------------------ */

    i__ = *ihi;
L10:
    l = *ilo;
    if (i__ < *ilo) {
	goto L150;
    }
/*     %--------------------------------------------------------------%   
       | Perform QR iterations on rows and columns ILO to I until a   |   
       | submatrix of order 1 or 2 splits off at the bottom because a |   
       | subdiagonal element has become negligible.                   |   
       %--------------------------------------------------------------% */
    i__1 = itn;
    for (its = 0; its <= i__1; ++its) {

/*        %----------------------------------------------%   
          | Look for a single small subdiagonal element. |   
          %----------------------------------------------% */

	i__2 = l + 1;
	for (k = i__; k >= i__2; --k) {
	    tst1 = (d__1 = h__[k - 1 + (k - 1) * h_dim1], abs(d__1)) + (d__2 =
		     h__[k + k * h_dim1], abs(d__2));
	    if (tst1 == 0.) {
		i__3 = i__ - l + 1;
		tst1 = igraphdlanhs_("1", &i__3, &h__[l + l * h_dim1], ldh, work);
	    }
/* Computing MAX */
	    d__2 = ulp * tst1;
	    if ((d__1 = h__[k + (k - 1) * h_dim1], abs(d__1)) <= max(d__2,
		    smlnum)) {
		goto L30;
	    }
/* L20: */
	}
L30:
	l = k;
	if (l > *ilo) {

/*           %------------------------%   
             | H(L,L-1) is negligible |   
             %------------------------% */

	    h__[l + (l - 1) * h_dim1] = 0.;
	}

/*        %-------------------------------------------------------------%   
          | Exit from loop if a submatrix of order 1 or 2 has split off |   
          %-------------------------------------------------------------% */

	if (l >= i__ - 1) {
	    goto L140;
	}

/*        %---------------------------------------------------------%   
          | Now the active submatrix is in rows and columns L to I. |   
          | If eigenvalues only are being computed, only the active |   
          | submatrix need be transformed.                          |   
          %---------------------------------------------------------% */

	if (! (*wantt)) {
	    i1 = l;
	    i2 = i__;
	}

	if (its == 10 || its == 20) {

/*           %-------------------%   
             | Exceptional shift |   
             %-------------------% */

	    s = (d__1 = h__[i__ + (i__ - 1) * h_dim1], abs(d__1)) + (d__2 = 
		    h__[i__ - 1 + (i__ - 2) * h_dim1], abs(d__2));
	    h44 = s * .75;
	    h33 = h44;
	    h43h34 = s * -.4375 * s;

	} else {

/*           %-----------------------------------------%   
             | Prepare to use Wilkinson's double shift |   
             %-----------------------------------------% */

	    h44 = h__[i__ + i__ * h_dim1];
	    h33 = h__[i__ - 1 + (i__ - 1) * h_dim1];
	    h43h34 = h__[i__ + (i__ - 1) * h_dim1] * h__[i__ - 1 + i__ * 
		    h_dim1];
	}

/*        %-----------------------------------------------------%   
          | Look for two consecutive small subdiagonal elements |   
          %-----------------------------------------------------% */

	i__2 = l;
	for (m = i__ - 2; m >= i__2; --m) {

/*           %---------------------------------------------------------%   
             | Determine the effect of starting the double-shift QR    |   
             | iteration at row M, and see if this would make H(M,M-1) |   
             | negligible.                                             |   
             %---------------------------------------------------------% */

	    h11 = h__[m + m * h_dim1];
	    h22 = h__[m + 1 + (m + 1) * h_dim1];
	    h21 = h__[m + 1 + m * h_dim1];
	    h12 = h__[m + (m + 1) * h_dim1];
	    h44s = h44 - h11;
	    h33s = h33 - h11;
	    v1 = (h33s * h44s - h43h34) / h21 + h12;
	    v2 = h22 - h11 - h33s - h44s;
	    v3 = h__[m + 2 + (m + 1) * h_dim1];
	    s = abs(v1) + abs(v2) + abs(v3);
	    v1 /= s;
	    v2 /= s;
	    v3 /= s;
	    v[0] = v1;
	    v[1] = v2;
	    v[2] = v3;
	    if (m == l) {
		goto L50;
	    }
	    h00 = h__[m - 1 + (m - 1) * h_dim1];
	    h10 = h__[m + (m - 1) * h_dim1];
	    tst1 = abs(v1) * (abs(h00) + abs(h11) + abs(h22));
	    if (abs(h10) * (abs(v2) + abs(v3)) <= ulp * tst1) {
		goto L50;
	    }
/* L40: */
	}
L50:

/*        %----------------------%   
          | Double-shift QR step |   
          %----------------------% */

	i__2 = i__ - 1;
	for (k = m; k <= i__2; ++k) {

/*           ------------------------------------------------------------   
             The first iteration of this loop determines a reflection G   
             from the vector V and applies it from left and right to H,   
             thus creating a nonzero bulge below the subdiagonal.   

             Each subsequent iteration determines a reflection G to   
             restore the Hessenberg form in the (K-1)th column, and thus   
             chases the bulge one step toward the bottom of the active   
             submatrix. NR is the order of G.   
             ------------------------------------------------------------   

   Computing MIN */
	    i__3 = 3, i__4 = i__ - k + 1;
	    nr = min(i__3,i__4);
	    if (k > m) {
		igraphdcopy_(&nr, &h__[k + (k - 1) * h_dim1], &dlaev2__c__1, v, &dlaev2__c__1);
	    }
	    igraphdlarfg_(&nr, v, &v[1], &dlaev2__c__1, &t1);
	    if (k > m) {
		h__[k + (k - 1) * h_dim1] = v[0];
		h__[k + 1 + (k - 1) * h_dim1] = 0.;
		if (k < i__ - 1) {
		    h__[k + 2 + (k - 1) * h_dim1] = 0.;
		}
	    } else if (m > l) {
		h__[k + (k - 1) * h_dim1] = -h__[k + (k - 1) * h_dim1];
	    }
	    v2 = v[1];
	    t2 = t1 * v2;
	    if (nr == 3) {
		v3 = v[2];
		t3 = t1 * v3;

/*              %------------------------------------------------%   
                | Apply G from the left to transform the rows of |   
                | the matrix in columns K to I2.                 |   
                %------------------------------------------------% */

		i__3 = i2;
		for (j = k; j <= i__3; ++j) {
		    sum = h__[k + j * h_dim1] + v2 * h__[k + 1 + j * h_dim1] 
			    + v3 * h__[k + 2 + j * h_dim1];
		    h__[k + j * h_dim1] -= sum * t1;
		    h__[k + 1 + j * h_dim1] -= sum * t2;
		    h__[k + 2 + j * h_dim1] -= sum * t3;
/* L60: */
		}

/*              %----------------------------------------------------%   
                | Apply G from the right to transform the columns of |   
                | the matrix in rows I1 to min(K+3,I).               |   
                %----------------------------------------------------%   

   Computing MIN */
		i__4 = k + 3;
		i__3 = min(i__4,i__);
		for (j = i1; j <= i__3; ++j) {
		    sum = h__[j + k * h_dim1] + v2 * h__[j + (k + 1) * h_dim1]
			     + v3 * h__[j + (k + 2) * h_dim1];
		    h__[j + k * h_dim1] -= sum * t1;
		    h__[j + (k + 1) * h_dim1] -= sum * t2;
		    h__[j + (k + 2) * h_dim1] -= sum * t3;
/* L70: */
		}

/*              %----------------------------------%   
                | Accumulate transformations for Z |   
                %----------------------------------% */

		sum = z__[k] + v2 * z__[k + 1] + v3 * z__[k + 2];
		z__[k] -= sum * t1;
		z__[k + 1] -= sum * t2;
		z__[k + 2] -= sum * t3;
	    } else if (nr == 2) {

/*              %------------------------------------------------%   
                | Apply G from the left to transform the rows of |   
                | the matrix in columns K to I2.                 |   
                %------------------------------------------------% */

		i__3 = i2;
		for (j = k; j <= i__3; ++j) {
		    sum = h__[k + j * h_dim1] + v2 * h__[k + 1 + j * h_dim1];
		    h__[k + j * h_dim1] -= sum * t1;
		    h__[k + 1 + j * h_dim1] -= sum * t2;
/* L90: */
		}

/*              %----------------------------------------------------%   
                | Apply G from the right to transform the columns of |   
                | the matrix in rows I1 to min(K+3,I).               |   
                %----------------------------------------------------% */

		i__3 = i__;
		for (j = i1; j <= i__3; ++j) {
		    sum = h__[j + k * h_dim1] + v2 * h__[j + (k + 1) * h_dim1]
			    ;
		    h__[j + k * h_dim1] -= sum * t1;
		    h__[j + (k + 1) * h_dim1] -= sum * t2;
/* L100: */
		}

/*              %----------------------------------%   
                | Accumulate transformations for Z |   
                %----------------------------------% */

		sum = z__[k] + v2 * z__[k + 1];
		z__[k] -= sum * t1;
		z__[k + 1] -= sum * t2;
	    }
/* L120: */
	}
/* L130: */
    }

/*     %-------------------------------------------------------%   
       | Failure to converge in remaining number of iterations |   
       %-------------------------------------------------------% */

    *info = i__;
    return 0;
L140:
    if (l == i__) {

/*        %------------------------------------------------------%   
          | H(I,I-1) is negligible: one eigenvalue has converged |   
          %------------------------------------------------------% */

	wr[i__] = h__[i__ + i__ * h_dim1];
	wi[i__] = 0.;
    } else if (l == i__ - 1) {

/*        %--------------------------------------------------------%   
          | H(I-1,I-2) is negligible;                              |   
          | a pair of eigenvalues have converged.                  |   
          |                                                        |   
          | Transform the 2-by-2 submatrix to standard Schur form, |   
          | and compute and store the eigenvalues.                 |   
          %--------------------------------------------------------% */

	igraphdlanv2_(&h__[i__ - 1 + (i__ - 1) * h_dim1], &h__[i__ - 1 + i__ * 
		h_dim1], &h__[i__ + (i__ - 1) * h_dim1], &h__[i__ + i__ * 
		h_dim1], &wr[i__ - 1], &wi[i__ - 1], &wr[i__], &wi[i__], &cs, 
		&sn);
	if (*wantt) {

/*           %-----------------------------------------------------%   
             | Apply the transformation to the rest of H and to Z, |   
             | as required.                                        |   
             %-----------------------------------------------------% */

	    if (i2 > i__) {
		i__1 = i2 - i__;
		igraphdrot_(&i__1, &h__[i__ - 1 + (i__ + 1) * h_dim1], ldh, &h__[
			i__ + (i__ + 1) * h_dim1], ldh, &cs, &sn);
	    }
	    i__1 = i__ - i1 - 1;
	    igraphdrot_(&i__1, &h__[i1 + (i__ - 1) * h_dim1], &dlaev2__c__1, &h__[i1 + i__ *
		     h_dim1], &dlaev2__c__1, &cs, &sn);
	    sum = cs * z__[i__ - 1] + sn * z__[i__];
	    z__[i__] = cs * z__[i__] - sn * z__[i__ - 1];
	    z__[i__ - 1] = sum;
	}
    }

/*     %---------------------------------------------------------%   
       | Decrement number of remaining iterations, and return to |   
       | start of the main loop with new value of I.             |   
       %---------------------------------------------------------% */

    itn -= its;
    i__ = l - 1;
    goto L10;
L150:
    return 0;

/*     %---------------%   
       | End of dlaqrb |   
       %---------------% */

} /* igraphdlaqrb_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static doublereal dlaexc__c_b21 = .66666666666666663;
static integer dlaexc__c__1 = 1;
static integer dlaexc__c__2 = 2;
static logical dlaexc__c_true = TRUE_;
static doublereal dlaexc__c_b119 = 1.;

/* \BeginDoc   

   \Name: dseupd   

   \Description:   

    This subroutine returns the converged approximations to eigenvalues   
    of A*z = lambda*B*z and (optionally):   

        (1) the corresponding approximate eigenvectors,   

        (2) an orthonormal (Lanczos) basis for the associated approximate   
            invariant subspace,   

        (3) Both.   

    There is negligible additional cost to obtain eigenvectors.  An orthonormal   
    (Lanczos) basis is always computed.  There is an additional storage cost   
    of n*nev if both are requested (in this case a separate array Z must be   
    supplied).   

    These quantities are obtained from the Lanczos factorization computed   
    by DSAUPD for the linear operator OP prescribed by the MODE selection   
    (see IPARAM(7) in DSAUPD documentation.)  DSAUPD must be called before   
    this routine is called. These approximate eigenvalues and vectors are   
    commonly called Ritz values and Ritz vectors respectively.  They are   
    referred to as such in the comments that follow.   The computed orthonormal   
    basis for the invariant subspace corresponding to these Ritz values is   
    referred to as a Lanczos basis.   

    See documentation in the header of the subroutine DSAUPD for a definition   
    of OP as well as other terms and the relation of computed Ritz values   
    and vectors of OP with respect to the given problem  A*z = lambda*B*z.   

    The approximate eigenvalues of the original problem are returned in   
    ascending algebraic order.  The user may elect to call this routine   
    once for each desired Ritz vector and store it peripherally if desired.   
    There is also the option of computing a selected set of these vectors   
    with a single call.   

   \Usage:   
    call dseupd   
       ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, BMAT, N, WHICH, NEV, TOL,   
         RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, LWORKL, INFO )   

    RVEC    LOGICAL  (INPUT)   
            Specifies whether Ritz vectors corresponding to the Ritz value   
            approximations to the eigenproblem A*z = lambda*B*z are computed.   

               RVEC = .FALSE.     Compute Ritz values only.   

               RVEC = .TRUE.      Compute Ritz vectors.   

    HOWMNY  Character*1  (INPUT)   
            Specifies how many Ritz vectors are wanted and the form of Z   
            the matrix of Ritz vectors. See remark 1 below.   
            = 'A': compute NEV Ritz vectors;   
            = 'S': compute some of the Ritz vectors, specified   
                   by the logical array SELECT.   

    SELECT  Logical array of dimension NEV.  (INPUT)   
            If HOWMNY = 'S', SELECT specifies the Ritz vectors to be   
            computed. To select the Ritz vector corresponding to a   
            Ritz value D(j), SELECT(j) must be set to .TRUE..   
            If HOWMNY = 'A' , SELECT is not referenced.   

    D       Double precision array of dimension NEV.  (OUTPUT)   
            On exit, D contains the Ritz value approximations to the   
            eigenvalues of A*z = lambda*B*z. The values are returned   
            in ascending order. If IPARAM(7) = 3,4,5 then D represents   
            the Ritz values of OP computed by dsaupd transformed to   
            those of the original eigensystem A*z = lambda*B*z. If   
            IPARAM(7) = 1,2 then the Ritz values of OP are the same   
            as the those of A*z = lambda*B*z.   

    Z       Double precision N by NEV array if HOWMNY = 'A'.  (OUTPUT)   
            On exit, Z contains the B-orthonormal Ritz vectors of the   
            eigensystem A*z = lambda*B*z corresponding to the Ritz   
            value approximations.   
            If  RVEC = .FALSE. then Z is not referenced.   
            NOTE: The array Z may be set equal to first NEV columns of the   
            Arnoldi/Lanczos basis array V computed by DSAUPD.   

    LDZ     Integer.  (INPUT)   
            The leading dimension of the array Z.  If Ritz vectors are   
            desired, then  LDZ .ge.  max( 1, N ).  In any case,  LDZ .ge. 1.   

    SIGMA   Double precision  (INPUT)   
            If IPARAM(7) = 3,4,5 represents the shift. Not referenced if   
            IPARAM(7) = 1 or 2.   


    **** The remaining arguments MUST be the same as for the   ****   
    **** call to DNAUPD that was just completed.               ****   

    NOTE: The remaining arguments   

             BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,   
             WORKD, WORKL, LWORKL, INFO   

           must be passed directly to DSEUPD following the last call   
           to DSAUPD.  These arguments MUST NOT BE MODIFIED between   
           the the last call to DSAUPD and the call to DSEUPD.   

    Two of these parameters (WORKL, INFO) are also output parameters:   

    WORKL   Double precision work array of length LWORKL.  (OUTPUT/WORKSPACE)   
            WORKL(1:4*ncv) contains information obtained in   
            dsaupd.  They are not changed by dseupd.   
            WORKL(4*ncv+1:ncv*ncv+8*ncv) holds the   
            untransformed Ritz values, the computed error estimates,   
            and the associated eigenvector matrix of H.   

            Note: IPNTR(8:10) contains the pointer into WORKL for addresses   
            of the above information computed by dseupd.   
            -------------------------------------------------------------   
            IPNTR(8): pointer to the NCV RITZ values of the original system.   
            IPNTR(9): pointer to the NCV corresponding error bounds.   
            IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors   
                       of the tridiagonal matrix T. Only referenced by   
                       dseupd if RVEC = .TRUE. See Remarks.   
            -------------------------------------------------------------   

    INFO    Integer.  (OUTPUT)   
            Error flag on output.   
            =  0: Normal exit.   
            = -1: N must be positive.   
            = -2: NEV must be positive.   
            = -3: NCV must be greater than NEV and less than or equal to N.   
            = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.   
            = -6: BMAT must be one of 'I' or 'G'.   
            = -7: Length of private work WORKL array is not sufficient.   
            = -8: Error return from trid. eigenvalue calculation;   
                  Information error from LAPACK routine dsteqr.   
            = -9: Starting vector is zero.   
            = -10: IPARAM(7) must be 1,2,3,4,5.   
            = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.   
            = -12: NEV and WHICH = 'BE' are incompatible.   
            = -14: DSAUPD did not find any eigenvalues to sufficient   
                   accuracy.   
            = -15: HOWMNY must be one of 'A' or 'S' if RVEC = .true.   
            = -16: HOWMNY = 'S' not yet implemented   

   \BeginLib   

   \References:   
    1. D.C. Sorensen, "Implicit Application of Polynomial Filters in   
       a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),   
       pp 357-385.   
    2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly   
       Restarted Arnoldi Iteration", Rice University Technical Report   
       TR95-13, Department of Computational and Applied Mathematics.   
    3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,   
       1980.   
    4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",   
       Computer Physics Communications, 53 (1989), pp 169-179.   
    5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to   
       Implement the Spectral Transformation", Math. Comp., 48 (1987),   
       pp 663-673.   
    6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos   
       Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",   
       SIAM J. Matr. Anal. Apps.,  January (1993).   
    7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines   
       for Updating the QR decomposition", ACM TOMS, December 1990,   
       Volume 16 Number 4, pp 369-377.   

   \Remarks   
    1. The converged Ritz values are always returned in increasing   
       (algebraic) order.   

    2. Currently only HOWMNY = 'A' is implemented. It is included at this   
       stage for the user who wants to incorporate it.   

   \Routines called:   
       dsesrt  ARPACK routine that sorts an array X, and applies the   
               corresponding permutation to a matrix A.   
       dsortr  dsortr  ARPACK sorting routine.   
       ivout   ARPACK utility routine that prints integers.   
       dvout   ARPACK utility routine that prints vectors.   
       dgeqr2  LAPACK routine that computes the QR factorization of   
               a matrix.   
       dlacpy  LAPACK matrix copy routine.   
       dlamch  LAPACK routine that determines machine constants.   
       dorm2r  LAPACK routine that applies an orthogonal matrix in   
               factored form.   
       dsteqr  LAPACK routine that computes eigenvalues and eigenvectors   
               of a tridiagonal matrix.   
       dger    Level 2 BLAS rank one update to a matrix.   
       dcopy   Level 1 BLAS that copies one vector to another .   
       dnrm2   Level 1 BLAS that computes the norm of a vector.   
       dscal   Level 1 BLAS that scales a vector.   
       dswap   Level 1 BLAS that swaps the contents of two vectors.   
   \Authors   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Chao Yang                    Houston, Texas   
       Dept. of Computational &   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \Revision history:   
       12/15/93: Version ' 2.1'   

   \SCCS Information: @(#)   
   FILE: seupd.F   SID: 2.7   DATE OF SID: 8/27/96   RELEASE: 2   

   \EndLib   

   -----------------------------------------------------------------------   
   Subroutine */ int igraphdseupd_(logical *rvec, char *howmny, logical *select, 
	doublereal *d__, doublereal *z__, integer *ldz, doublereal *sigma, 
	char *bmat, integer *n, char *which, integer *nev, doublereal *tol, 
	doublereal *resid, integer *ncv, doublereal *v, integer *ldv, integer 
	*iparam, integer *ipntr, doublereal *workd, doublereal *workl, 
	integer *lworkl, integer *info)
{
    /* System generated locals */
    integer v_dim1, v_offset, z_dim1, z_offset, i__1;
    doublereal d__1, d__2, d__3;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    double pow_dd(doublereal *, doublereal *);

    /* Local variables */
    integer j, k, ih, iq, iw;
    doublereal kv[2];
    integer ibd, ihb, ihd, ldh, ilg, ldq, ism, irz;
    extern /* Subroutine */ int igraphdger_(integer *, integer *, doublereal *, 
	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
	    integer *);
    integer mode;
    doublereal eps23;
    integer ierr;
    doublereal temp;
    integer next;
    char type__[6];
    integer ritz;
    extern doublereal igraphdnrm2_(integer *, doublereal *, integer *);
    extern /* Subroutine */ int igraphdscal_(integer *, doublereal *, doublereal *, 
	    integer *);
    logical reord;
    extern /* Subroutine */ int igraphdcopy_(integer *, doublereal *, integer *, 
	    doublereal *, integer *);
    integer nconv;
    doublereal rnorm;
    extern /* Subroutine */ int igraphdvout_(integer *, integer *, doublereal *, 
	    integer *, char *, ftnlen), igraphivout_(integer *, integer *, integer *
	    , integer *, char *, ftnlen), igraphdgeqr2_(integer *, integer *, 
	    doublereal *, integer *, doublereal *, doublereal *, integer *);
    doublereal bnorm2;
    extern /* Subroutine */ int igraphdorm2r_(char *, char *, integer *, integer *, 
	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
	    integer *, doublereal *, integer *);
    doublereal thres1, thres2;
    extern doublereal igraphdlamch_(char *);
    extern /* Subroutine */ int igraphdlacpy_(char *, integer *, integer *, 
	    doublereal *, integer *, doublereal *, integer *);
    integer logfil, ndigit, bounds, mseupd = 0;
    extern /* Subroutine */ int igraphdsteqr_(char *, integer *, doublereal *, 
	    doublereal *, doublereal *, integer *, doublereal *, integer *);
    integer msglvl, ktrord;
    extern /* Subroutine */ int igraphdsesrt_(char *, logical *, integer *, 
	    doublereal *, integer *, doublereal *, integer *), 
	    igraphdsortr_(char *, logical *, integer *, doublereal *, doublereal *);
    doublereal tempbnd;
    integer leftptr, rghtptr;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %--------------%   
       | Local Arrays |   
       %--------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %---------------------%   
       | Intrinsic Functions |   
       %---------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       %------------------------%   
       | Set default parameters |   
       %------------------------%   

       Parameter adjustments */
    --workd;
    --resid;
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --d__;
    --select;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    --iparam;
    --ipntr;
    --workl;

    /* Function Body */
    msglvl = mseupd;
    mode = iparam[7];
    nconv = iparam[5];
    *info = 0;

/*     %--------------%   
       | Quick return |   
       %--------------% */

    if (nconv == 0) {
	goto L9000;
    }
    ierr = 0;

    if (nconv <= 0) {
	ierr = -14;
    }
    if (*n <= 0) {
	ierr = -1;
    }
    if (*nev <= 0) {
	ierr = -2;
    }
    if (*ncv <= *nev || *ncv > *n) {
	ierr = -3;
    }
    if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) != 0 && s_cmp(which, "SM", (
	    ftnlen)2, (ftnlen)2) != 0 && s_cmp(which, "LA", (ftnlen)2, (
	    ftnlen)2) != 0 && s_cmp(which, "SA", (ftnlen)2, (ftnlen)2) != 0 &&
	     s_cmp(which, "BE", (ftnlen)2, (ftnlen)2) != 0) {
	ierr = -5;
    }
    if (*(unsigned char *)bmat != 'I' && *(unsigned char *)bmat != 'G') {
	ierr = -6;
    }
    if (*(unsigned char *)howmny != 'A' && *(unsigned char *)howmny != 'P' && 
	    *(unsigned char *)howmny != 'S' && *rvec) {
	ierr = -15;
    }
    if (*rvec && *(unsigned char *)howmny == 'S') {
	ierr = -16;
    }

/* Computing 2nd power */
    i__1 = *ncv;
    if (*rvec && *lworkl < i__1 * i__1 + (*ncv << 3)) {
	ierr = -7;
    }

    if (mode == 1 || mode == 2) {
	s_copy(type__, "REGULR", (ftnlen)6, (ftnlen)6);
    } else if (mode == 3) {
	s_copy(type__, "SHIFTI", (ftnlen)6, (ftnlen)6);
    } else if (mode == 4) {
	s_copy(type__, "BUCKLE", (ftnlen)6, (ftnlen)6);
    } else if (mode == 5) {
	s_copy(type__, "CAYLEY", (ftnlen)6, (ftnlen)6);
    } else {
	ierr = -10;
    }
    if (mode == 1 && *(unsigned char *)bmat == 'G') {
	ierr = -11;
    }
    if (*nev == 1 && s_cmp(which, "BE", (ftnlen)2, (ftnlen)2) == 0) {
	ierr = -12;
    }

/*     %------------%   
       | Error Exit |   
       %------------% */

    if (ierr != 0) {
	*info = ierr;
	goto L9000;
    }

/*     %-------------------------------------------------------%   
       | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |   
       | etc... and the remaining workspace.                   |   
       | Also update pointer to be used on output.             |   
       | Memory is laid out as follows:                        |   
       | workl(1:2*ncv) := generated tridiagonal matrix H      |   
       |       The subdiagonal is stored in workl(2:ncv).      |   
       |       The dead spot is workl(1) but upon exiting      |   
       |       dsaupd stores the B-norm of the last residual   |   
       |       vector in workl(1). We use this !!!             |   
       | workl(2*ncv+1:2*ncv+ncv) := ritz values               |   
       |       The wanted values are in the first NCONV spots. |   
       | workl(3*ncv+1:3*ncv+ncv) := computed Ritz estimates   |   
       |       The wanted values are in the first NCONV spots. |   
       | NOTE: workl(1:4*ncv) is set by dsaupd and is not      |   
       |       modified by dseupd.                             |   
       %-------------------------------------------------------%   

       %-------------------------------------------------------%   
       | The following is used and set by dseupd.              |   
       | workl(4*ncv+1:4*ncv+ncv) := used as workspace during  |   
       |       computation of the eigenvectors of H. Stores    |   
       |       the diagonal of H. Upon EXIT contains the NCV   |   
       |       Ritz values of the original system. The first   |   
       |       NCONV spots have the wanted values. If MODE =   |   
       |       1 or 2 then will equal workl(2*ncv+1:3*ncv).    |   
       | workl(5*ncv+1:5*ncv+ncv) := used as workspace during  |   
       |       computation of the eigenvectors of H. Stores    |   
       |       the subdiagonal of H. Upon EXIT contains the    |   
       |       NCV corresponding Ritz estimates of the         |   
       |       original system. The first NCONV spots have the |   
       |       wanted values. If MODE = 1,2 then will equal    |   
       |       workl(3*ncv+1:4*ncv).                           |   
       | workl(6*ncv+1:6*ncv+ncv*ncv) := orthogonal Q that is  |   
       |       the eigenvector matrix for H as returned by     |   
       |       dsteqr. Not referenced if RVEC = .False.        |   
       |       Ordering follows that of workl(4*ncv+1:5*ncv)   |   
       | workl(6*ncv+ncv*ncv+1:6*ncv+ncv*ncv+2*ncv) :=         |   
       |       Workspace. Needed by dsteqr and by dseupd.      |   
       | GRAND total of NCV*(NCV+8) locations.                 |   
       %-------------------------------------------------------% */


    ih = ipntr[5];
    ritz = ipntr[6];
    bounds = ipntr[7];
    ldh = *ncv;
    ldq = *ncv;
    ihd = bounds + ldh;
    ihb = ihd + ldh;
    iq = ihb + ldh;
    iw = iq + ldh * *ncv;
    next = iw + (*ncv << 1);
    ipntr[4] = next;
    ipntr[8] = ihd;
    ipntr[9] = ihb;
    ipntr[10] = iq;

/*     %----------------------------------------%   
       | irz points to the Ritz values computed |   
       |     by _seigt before exiting _saup2.   |   
       | ibd points to the Ritz estimates       |   
       |     computed by _seigt before exiting  |   
       |     _saup2.                            |   
       %----------------------------------------% */

    irz = ipntr[11] + *ncv;
    ibd = irz + *ncv;


/*     %---------------------------------%   
       | Set machine dependent constant. |   
       %---------------------------------% */

    eps23 = igraphdlamch_("Epsilon-Machine");
    eps23 = pow_dd(&eps23, &dlaexc__c_b21);

/*     %---------------------------------------%   
       | RNORM is B-norm of the RESID(1:N).    |   
       | BNORM2 is the 2 norm of B*RESID(1:N). |   
       | Upon exit of dsaupd WORKD(1:N) has    |   
       | B*RESID(1:N).                         |   
       %---------------------------------------% */

    rnorm = workl[ih];
    if (*(unsigned char *)bmat == 'I') {
	bnorm2 = rnorm;
    } else if (*(unsigned char *)bmat == 'G') {
	bnorm2 = igraphdnrm2_(n, &workd[1], &dlaexc__c__1);
    }

    if (*rvec) {

/*        %------------------------------------------------%   
          | Get the converged Ritz value on the boundary.  |   
          | This value will be used to dermine whether we  |   
          | need to reorder the eigenvalues and            |   
          | eigenvectors comupted by _steqr, and is        |   
          | referred to as the "threshold" value.          |   
          |                                                |   
          | A Ritz value gamma is said to be a wanted      |   
          | one, if                                        |   
          | abs(gamma) .ge. threshold, when WHICH = 'LM';  |   
          | abs(gamma) .le. threshold, when WHICH = 'SM';  |   
          | gamma      .ge. threshold, when WHICH = 'LA';  |   
          | gamma      .le. threshold, when WHICH = 'SA';  |   
          | gamma .le. thres1 .or. gamma .ge. thres2       |   
          |                            when WHICH = 'BE';  |   
          |                                                |   
          | Note: converged Ritz values and associated     |   
          | Ritz estimates have been placed in the first   |   
          | NCONV locations in workl(ritz) and             |   
          | workl(bounds) respectively. They have been     |   
          | sorted (in _saup2) according to the WHICH      |   
          | selection criterion. (Except in the case       |   
          | WHICH = 'BE', they are sorted in an increasing |   
          | order.)                                        |   
          %------------------------------------------------% */

	if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(which, 
		"SM", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(which, "LA", (
		ftnlen)2, (ftnlen)2) == 0 || s_cmp(which, "SA", (ftnlen)2, (
		ftnlen)2) == 0) {

	    thres1 = workl[ritz];

	    if (msglvl > 2) {
		igraphdvout_(&logfil, &dlaexc__c__1, &thres1, &ndigit, "_seupd: Threshold "
			"eigenvalue used for re-ordering", (ftnlen)49);
	    }

	} else if (s_cmp(which, "BE", (ftnlen)2, (ftnlen)2) == 0) {

/*            %------------------------------------------------%   
              | Ritz values returned from _saup2 have been     |   
              | sorted in increasing order.  Thus two          |   
              | "threshold" values (one for the small end, one |   
              | for the large end) are in the middle.          |   
              %------------------------------------------------% */

	    ism = max(*nev,nconv) / 2;
	    ilg = ism + 1;
	    thres1 = workl[ism];
	    thres2 = workl[ilg];

	    if (msglvl > 2) {
		kv[0] = thres1;
		kv[1] = thres2;
		igraphdvout_(&logfil, &dlaexc__c__2, kv, &ndigit, "_seupd: Threshold eigen"
			"values used for re-ordering", (ftnlen)50);
	    }

	}

/*        %----------------------------------------------------------%   
          | Check to see if all converged Ritz values appear within  |   
          | the first NCONV diagonal elements returned from _seigt.  |   
          | This is done in the following way:                       |   
          |                                                          |   
          | 1) For each Ritz value obtained from _seigt, compare it  |   
          |    with the threshold Ritz value computed above to       |   
          |    determine whether it is a wanted one.                 |   
          |                                                          |   
          | 2) If it is wanted, then check the corresponding Ritz    |   
          |    estimate to see if it has converged.  If it has, set  |   
          |    correponding entry in the logical array SELECT to     |   
          |    .TRUE..                                               |   
          |                                                          |   
          | If SELECT(j) = .TRUE. and j > NCONV, then there is a     |   
          | converged Ritz value that does not appear at the top of  |   
          | the diagonal matrix computed by _seigt in _saup2.        |   
          | Reordering is needed.                                    |   
          %----------------------------------------------------------% */

	reord = FALSE_;
	ktrord = 0;
	i__1 = *ncv - 1;
	for (j = 0; j <= i__1; ++j) {
	    select[j + 1] = FALSE_;
	    if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0) {
		if ((d__1 = workl[irz + j], abs(d__1)) >= abs(thres1)) {
/* Computing MAX */
		    d__2 = eps23, d__3 = (d__1 = workl[irz + j], abs(d__1));
		    tempbnd = max(d__2,d__3);
		    if (workl[ibd + j] <= *tol * tempbnd) {
			select[j + 1] = TRUE_;
		    }
		}
	    } else if (s_cmp(which, "SM", (ftnlen)2, (ftnlen)2) == 0) {
		if ((d__1 = workl[irz + j], abs(d__1)) <= abs(thres1)) {
/* Computing MAX */
		    d__2 = eps23, d__3 = (d__1 = workl[irz + j], abs(d__1));
		    tempbnd = max(d__2,d__3);
		    if (workl[ibd + j] <= *tol * tempbnd) {
			select[j + 1] = TRUE_;
		    }
		}
	    } else if (s_cmp(which, "LA", (ftnlen)2, (ftnlen)2) == 0) {
		if (workl[irz + j] >= thres1) {
/* Computing MAX */
		    d__2 = eps23, d__3 = (d__1 = workl[irz + j], abs(d__1));
		    tempbnd = max(d__2,d__3);
		    if (workl[ibd + j] <= *tol * tempbnd) {
			select[j + 1] = TRUE_;
		    }
		}
	    } else if (s_cmp(which, "SA", (ftnlen)2, (ftnlen)2) == 0) {
		if (workl[irz + j] <= thres1) {
/* Computing MAX */
		    d__2 = eps23, d__3 = (d__1 = workl[irz + j], abs(d__1));
		    tempbnd = max(d__2,d__3);
		    if (workl[ibd + j] <= *tol * tempbnd) {
			select[j + 1] = TRUE_;
		    }
		}
	    } else if (s_cmp(which, "BE", (ftnlen)2, (ftnlen)2) == 0) {
		if (workl[irz + j] <= thres1 || workl[irz + j] >= thres2) {
/* Computing MAX */
		    d__2 = eps23, d__3 = (d__1 = workl[irz + j], abs(d__1));
		    tempbnd = max(d__2,d__3);
		    if (workl[ibd + j] <= *tol * tempbnd) {
			select[j + 1] = TRUE_;
		    }
		}
	    }
	    if (j + 1 > nconv) {
		reord = select[j + 1] || reord;
	    }
	    if (select[j + 1]) {
		++ktrord;
	    }
/* L10: */
	}
/*        %-------------------------------------------%   
          | If KTRORD .ne. NCONV, something is wrong. |   
          %-------------------------------------------% */

	if (msglvl > 2) {
	    igraphivout_(&logfil, &dlaexc__c__1, &ktrord, &ndigit, "_seupd: Number of spec"
		    "ified eigenvalues", (ftnlen)39);
	    igraphivout_(&logfil, &dlaexc__c__1, &nconv, &ndigit, "_seupd: Number of \"con"
		    "verged\" eigenvalues", (ftnlen)41);
	}

/*        %-----------------------------------------------------------%   
          | Call LAPACK routine _steqr to compute the eigenvalues and |   
          | eigenvectors of the final symmetric tridiagonal matrix H. |   
          | Initialize the eigenvector matrix Q to the identity.      |   
          %-----------------------------------------------------------% */

	i__1 = *ncv - 1;
	igraphdcopy_(&i__1, &workl[ih + 1], &dlaexc__c__1, &workl[ihb], &dlaexc__c__1);
	igraphdcopy_(ncv, &workl[ih + ldh], &dlaexc__c__1, &workl[ihd], &dlaexc__c__1);

	igraphdsteqr_("Identity", ncv, &workl[ihd], &workl[ihb], &workl[iq], &ldq, &
		workl[iw], &ierr);

	if (ierr != 0) {
	    *info = -8;
	    goto L9000;
	}

	if (msglvl > 1) {
	    igraphdcopy_(ncv, &workl[iq + *ncv - 1], &ldq, &workl[iw], &dlaexc__c__1);
	    igraphdvout_(&logfil, ncv, &workl[ihd], &ndigit, "_seupd: NCV Ritz val"
		    "ues of the final H matrix", (ftnlen)45);
	    igraphdvout_(&logfil, ncv, &workl[iw], &ndigit, "_seupd: last row of t"
		    "he eigenvector matrix for H", (ftnlen)48);
	}

	if (reord) {

/*           %---------------------------------------------%   
             | Reordered the eigenvalues and eigenvectors  |   
             | computed by _steqr so that the "converged"  |   
             | eigenvalues appear in the first NCONV       |   
             | positions of workl(ihd), and the associated |   
             | eigenvectors appear in the first NCONV      |   
             | columns.                                    |   
             %---------------------------------------------% */

	    leftptr = 1;
	    rghtptr = *ncv;

	    if (*ncv == 1) {
		goto L30;
	    }

L20:
	    if (select[leftptr]) {

/*              %-------------------------------------------%   
                | Search, from the left, for the first Ritz |   
                | value that has not converged.             |   
                %-------------------------------------------% */

		++leftptr;

	    } else if (! select[rghtptr]) {

/*              %----------------------------------------------%   
                | Search, from the right, the first Ritz value |   
                | that has converged.                          |   
                %----------------------------------------------% */

		--rghtptr;

	    } else {

/*              %----------------------------------------------%   
                | Swap the Ritz value on the left that has not |   
                | converged with the Ritz value on the right   |   
                | that has converged.  Swap the associated     |   
                | eigenvector of the tridiagonal matrix H as   |   
                | well.                                        |   
                %----------------------------------------------% */

		temp = workl[ihd + leftptr - 1];
		workl[ihd + leftptr - 1] = workl[ihd + rghtptr - 1];
		workl[ihd + rghtptr - 1] = temp;
		igraphdcopy_(ncv, &workl[iq + *ncv * (leftptr - 1)], &dlaexc__c__1, &workl[
			iw], &dlaexc__c__1);
		igraphdcopy_(ncv, &workl[iq + *ncv * (rghtptr - 1)], &dlaexc__c__1, &workl[
			iq + *ncv * (leftptr - 1)], &dlaexc__c__1);
		igraphdcopy_(ncv, &workl[iw], &dlaexc__c__1, &workl[iq + *ncv * (rghtptr - 
			1)], &dlaexc__c__1);
		++leftptr;
		--rghtptr;

	    }

	    if (leftptr < rghtptr) {
		goto L20;
	    }

L30:
	    ;
	}

	if (msglvl > 2) {
	    igraphdvout_(&logfil, ncv, &workl[ihd], &ndigit, "_seupd: The eigenval"
		    "ues of H--reordered", (ftnlen)39);
	}

/*        %----------------------------------------%   
          | Load the converged Ritz values into D. |   
          %----------------------------------------% */

	igraphdcopy_(&nconv, &workl[ihd], &dlaexc__c__1, &d__[1], &dlaexc__c__1);

    } else {

/*        %-----------------------------------------------------%   
          | Ritz vectors not required. Load Ritz values into D. |   
          %-----------------------------------------------------% */

	igraphdcopy_(&nconv, &workl[ritz], &dlaexc__c__1, &d__[1], &dlaexc__c__1);
	igraphdcopy_(ncv, &workl[ritz], &dlaexc__c__1, &workl[ihd], &dlaexc__c__1);

    }

/*     %------------------------------------------------------------------%   
       | Transform the Ritz values and possibly vectors and corresponding |   
       | Ritz estimates of OP to those of A*x=lambda*B*x. The Ritz values |   
       | (and corresponding data) are returned in ascending order.        |   
       %------------------------------------------------------------------% */

    if (s_cmp(type__, "REGULR", (ftnlen)6, (ftnlen)6) == 0) {

/*        %---------------------------------------------------------%   
          | Ascending sort of wanted Ritz values, vectors and error |   
          | bounds. Not necessary if only Ritz values are desired.  |   
          %---------------------------------------------------------% */

	if (*rvec) {
	    igraphdsesrt_("LA", rvec, &nconv, &d__[1], ncv, &workl[iq], &ldq);
	} else {
	    igraphdcopy_(ncv, &workl[bounds], &dlaexc__c__1, &workl[ihb], &dlaexc__c__1);
	}

    } else {

/*        %-------------------------------------------------------------%   
          | *  Make a copy of all the Ritz values.                      |   
          | *  Transform the Ritz values back to the original system.   |   
          |    For TYPE = 'SHIFTI' the transformation is                |   
          |             lambda = 1/theta + sigma                        |   
          |    For TYPE = 'BUCKLE' the transformation is                |   
          |             lambda = sigma * theta / ( theta - 1 )          |   
          |    For TYPE = 'CAYLEY' the transformation is                |   
          |             lambda = sigma * (theta + 1) / (theta - 1 )     |   
          |    where the theta are the Ritz values returned by dsaupd.  |   
          | NOTES:                                                      |   
          | *The Ritz vectors are not affected by the transformation.   |   
          |  They are only reordered.                                   |   
          %-------------------------------------------------------------% */

	igraphdcopy_(ncv, &workl[ihd], &dlaexc__c__1, &workl[iw], &dlaexc__c__1);
	if (s_cmp(type__, "SHIFTI", (ftnlen)6, (ftnlen)6) == 0) {
	    i__1 = *ncv;
	    for (k = 1; k <= i__1; ++k) {
		workl[ihd + k - 1] = 1. / workl[ihd + k - 1] + *sigma;
/* L40: */
	    }
	} else if (s_cmp(type__, "BUCKLE", (ftnlen)6, (ftnlen)6) == 0) {
	    i__1 = *ncv;
	    for (k = 1; k <= i__1; ++k) {
		workl[ihd + k - 1] = *sigma * workl[ihd + k - 1] / (workl[ihd 
			+ k - 1] - 1.);
/* L50: */
	    }
	} else if (s_cmp(type__, "CAYLEY", (ftnlen)6, (ftnlen)6) == 0) {
	    i__1 = *ncv;
	    for (k = 1; k <= i__1; ++k) {
		workl[ihd + k - 1] = *sigma * (workl[ihd + k - 1] + 1.) / (
			workl[ihd + k - 1] - 1.);
/* L60: */
	    }
	}

/*        %-------------------------------------------------------------%   
          | *  Store the wanted NCONV lambda values into D.             |   
          | *  Sort the NCONV wanted lambda in WORKL(IHD:IHD+NCONV-1)   |   
          |    into ascending order and apply sort to the NCONV theta   |   
          |    values in the transformed system. We'll need this to     |   
          |    compute Ritz estimates in the original system.           |   
          | *  Finally sort the lambda's into ascending order and apply |   
          |    to Ritz vectors if wanted. Else just sort lambda's into  |   
          |    ascending order.                                         |   
          | NOTES:                                                      |   
          | *workl(iw:iw+ncv-1) contain the theta ordered so that they  |   
          |  match the ordering of the lambda. We'll use them again for |   
          |  Ritz vector purification.                                  |   
          %-------------------------------------------------------------% */

	igraphdcopy_(&nconv, &workl[ihd], &dlaexc__c__1, &d__[1], &dlaexc__c__1);
	igraphdsortr_("LA", &dlaexc__c_true, &nconv, &workl[ihd], &workl[iw]);
	if (*rvec) {
	    igraphdsesrt_("LA", rvec, &nconv, &d__[1], ncv, &workl[iq], &ldq);
	} else {
	    igraphdcopy_(ncv, &workl[bounds], &dlaexc__c__1, &workl[ihb], &dlaexc__c__1);
	    d__1 = bnorm2 / rnorm;
	    igraphdscal_(ncv, &d__1, &workl[ihb], &dlaexc__c__1);
	    igraphdsortr_("LA", &dlaexc__c_true, &nconv, &d__[1], &workl[ihb]);
	}

    }

/*     %------------------------------------------------%   
       | Compute the Ritz vectors. Transform the wanted |   
       | eigenvectors of the symmetric tridiagonal H by |   
       | the Lanczos basis matrix V.                    |   
       %------------------------------------------------% */

    if (*rvec && *(unsigned char *)howmny == 'A') {

/*        %----------------------------------------------------------%   
          | Compute the QR factorization of the matrix representing  |   
          | the wanted invariant subspace located in the first NCONV |   
          | columns of workl(iq,ldq).                                |   
          %----------------------------------------------------------% */

	igraphdgeqr2_(ncv, &nconv, &workl[iq], &ldq, &workl[iw + *ncv], &workl[ihb],
		 &ierr);


/*        %--------------------------------------------------------%   
          | * Postmultiply V by Q.                                 |   
          | * Copy the first NCONV columns of VQ into Z.           |   
          | The N by NCONV matrix Z is now a matrix representation |   
          | of the approximate invariant subspace associated with  |   
          | the Ritz values in workl(ihd).                         |   
          %--------------------------------------------------------% */

	igraphdorm2r_("Right", "Notranspose", n, ncv, &nconv, &workl[iq], &ldq, &
		workl[iw + *ncv], &v[v_offset], ldv, &workd[*n + 1], &ierr);
	igraphdlacpy_("All", n, &nconv, &v[v_offset], ldv, &z__[z_offset], ldz);

/*        %-----------------------------------------------------%   
          | In order to compute the Ritz estimates for the Ritz |   
          | values in both systems, need the last row of the    |   
          | eigenvector matrix. Remember, it's in factored form |   
          %-----------------------------------------------------% */

	i__1 = *ncv - 1;
	for (j = 1; j <= i__1; ++j) {
	    workl[ihb + j - 1] = 0.;
/* L65: */
	}
	workl[ihb + *ncv - 1] = 1.;
	igraphdorm2r_("Left", "Transpose", ncv, &dlaexc__c__1, &nconv, &workl[iq], &ldq, &
		workl[iw + *ncv], &workl[ihb], ncv, &temp, &ierr);

    } else if (*rvec && *(unsigned char *)howmny == 'S') {

/*     Not yet implemented. See remark 2 above. */

    }

    if (s_cmp(type__, "REGULR", (ftnlen)6, (ftnlen)6) == 0 && *rvec) {

	i__1 = *ncv;
	for (j = 1; j <= i__1; ++j) {
	    workl[ihb + j - 1] = rnorm * (d__1 = workl[ihb + j - 1], abs(d__1)
		    );
/* L70: */
	}

    } else if (s_cmp(type__, "REGULR", (ftnlen)6, (ftnlen)6) != 0 && *rvec) {

/*        %-------------------------------------------------%   
          | *  Determine Ritz estimates of the theta.       |   
          |    If RVEC = .true. then compute Ritz estimates |   
          |               of the theta.                     |   
          |    If RVEC = .false. then copy Ritz estimates   |   
          |              as computed by dsaupd.             |   
          | *  Determine Ritz estimates of the lambda.      |   
          %-------------------------------------------------% */

	igraphdscal_(ncv, &bnorm2, &workl[ihb], &dlaexc__c__1);
	if (s_cmp(type__, "SHIFTI", (ftnlen)6, (ftnlen)6) == 0) {

	    i__1 = *ncv;
	    for (k = 1; k <= i__1; ++k) {
/* Computing 2nd power */
		d__2 = workl[iw + k - 1];
		workl[ihb + k - 1] = (d__1 = workl[ihb + k - 1], abs(d__1)) / 
			(d__2 * d__2);
/* L80: */
	    }

	} else if (s_cmp(type__, "BUCKLE", (ftnlen)6, (ftnlen)6) == 0) {

	    i__1 = *ncv;
	    for (k = 1; k <= i__1; ++k) {
/* Computing 2nd power */
		d__2 = workl[iw + k - 1] - 1.;
		workl[ihb + k - 1] = *sigma * (d__1 = workl[ihb + k - 1], abs(
			d__1)) / (d__2 * d__2);
/* L90: */
	    }

	} else if (s_cmp(type__, "CAYLEY", (ftnlen)6, (ftnlen)6) == 0) {

	    i__1 = *ncv;
	    for (k = 1; k <= i__1; ++k) {
		workl[ihb + k - 1] = (d__1 = workl[ihb + k - 1] / workl[iw + 
			k - 1] * (workl[iw + k - 1] - 1.), abs(d__1));
/* L100: */
	    }

	}

    }

    if (s_cmp(type__, "REGULR", (ftnlen)6, (ftnlen)6) != 0 && msglvl > 1) {
	igraphdvout_(&logfil, &nconv, &d__[1], &ndigit, "_seupd: Untransformed con"
		"verged Ritz values", (ftnlen)43);
	igraphdvout_(&logfil, &nconv, &workl[ihb], &ndigit, "_seupd: Ritz estimate"
		"s of the untransformed Ritz values", (ftnlen)55);
    } else if (msglvl > 1) {
	igraphdvout_(&logfil, &nconv, &d__[1], &ndigit, "_seupd: Converged Ritz va"
		"lues", (ftnlen)29);
	igraphdvout_(&logfil, &nconv, &workl[ihb], &ndigit, "_seupd: Associated Ri"
		"tz estimates", (ftnlen)33);
    }

/*     %-------------------------------------------------%   
       | Ritz vector purification step. Formally perform |   
       | one of inverse subspace iteration. Only used    |   
       | for MODE = 3,4,5. See reference 7               |   
       %-------------------------------------------------% */

    if (*rvec && (s_cmp(type__, "SHIFTI", (ftnlen)6, (ftnlen)6) == 0 || s_cmp(
	    type__, "CAYLEY", (ftnlen)6, (ftnlen)6) == 0)) {

	i__1 = nconv - 1;
	for (k = 0; k <= i__1; ++k) {
	    workl[iw + k] = workl[iq + k * ldq + *ncv - 1] / workl[iw + k];
/* L110: */
	}

    } else if (*rvec && s_cmp(type__, "BUCKLE", (ftnlen)6, (ftnlen)6) == 0) {

	i__1 = nconv - 1;
	for (k = 0; k <= i__1; ++k) {
	    workl[iw + k] = workl[iq + k * ldq + *ncv - 1] / (workl[iw + k] - 
		    1.);
/* L120: */
	}

    }

    if (s_cmp(type__, "REGULR", (ftnlen)6, (ftnlen)6) != 0) {
	igraphdger_(n, &nconv, &dlaexc__c_b119, &resid[1], &dlaexc__c__1, &workl[iw], &dlaexc__c__1, &z__[
		z_offset], ldz);
    }

L9000:

    return 0;

/*     %---------------%   
       | End of dseupd |   
       %---------------% */

} /* igraphdseupd_ */

/*  -- translated by f2c (version 20100827).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/



/* Table of constant values */

static doublereal dlagtf__c_b3 = .66666666666666663;
static integer dlagtf__c__1 = 1;
static doublereal dlagtf__c_b44 = 0.;
static doublereal dlagtf__c_b45 = 1.;
static logical dlagtf__c_true = TRUE_;
static doublereal dlagtf__c_b71 = -1.;

/* \BeginDoc   

   \Name: dneupd   

   \Description:   

    This subroutine returns the converged approximations to eigenvalues   
    of A*z = lambda*B*z and (optionally):   

        (1) The corresponding approximate eigenvectors;   

        (2) An orthonormal basis for the associated approximate   
            invariant subspace;   

        (3) Both.   

    There is negligible additional cost to obtain eigenvectors.  An orthonormal   
    basis is always computed.  There is an additional storage cost of n*nev   
    if both are requested (in this case a separate array Z must be supplied).   

    The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z   
    are derived from approximate eigenvalues and eigenvectors of   
    of the linear operator OP prescribed by the MODE selection in the   
    call to DNAUPD.  DNAUPD must be called before this routine is called.   
    These approximate eigenvalues and vectors are commonly called Ritz   
    values and Ritz vectors respectively.  They are referred to as such   
    in the comments that follow.  The computed orthonormal basis for the   
    invariant subspace corresponding to these Ritz values is referred to as a   
    Schur basis.   

    See documentation in the header of the subroutine DNAUPD for   
    definition of OP as well as other terms and the relation of computed   
    Ritz values and Ritz vectors of OP with respect to the given problem   
    A*z = lambda*B*z.  For a brief description, see definitions of   
    IPARAM(7), MODE and WHICH in the documentation of DNAUPD.   

   \Usage:   
    call dneupd   
       ( RVEC, HOWMNY, SELECT, DR, DI, Z, LDZ, SIGMAR, SIGMAI, WORKEV, BMAT,   
         N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL,   
         LWORKL, INFO )   

   \Arguments:   
    RVEC    LOGICAL  (INPUT)   
            Specifies whether a basis for the invariant subspace corresponding   
            to the converged Ritz value approximations for the eigenproblem   
            A*z = lambda*B*z is computed.   

               RVEC = .FALSE.     Compute Ritz values only.   

               RVEC = .TRUE.      Compute the Ritz vectors or Schur vectors.   
                                  See Remarks below.   

    HOWMNY  Character*1  (INPUT)   
            Specifies the form of the basis for the invariant subspace   
            corresponding to the converged Ritz values that is to be computed.   

            = 'A': Compute NEV Ritz vectors;   
            = 'P': Compute NEV Schur vectors;   
            = 'S': compute some of the Ritz vectors, specified   
                   by the logical array SELECT.   

    SELECT  Logical array of dimension NCV.  (INPUT)   
            If HOWMNY = 'S', SELECT specifies the Ritz vectors to be   
            computed. To select the Ritz vector corresponding to a   
            Ritz value (DR(j), DI(j)), SELECT(j) must be set to .TRUE..   
            If HOWMNY = 'A' or 'P', SELECT is used as internal workspace.   

    DR      Double precision array of dimension NEV+1.  (OUTPUT)   
            If IPARAM(7) = 1,2 or 3 and SIGMAI=0.0  then on exit: DR contains   
            the real part of the Ritz  approximations to the eigenvalues of   
            A*z = lambda*B*z.   
            If IPARAM(7) = 3, 4 and SIGMAI is not equal to zero, then on exit:   
            DR contains the real part of the Ritz values of OP computed by   
            DNAUPD. A further computation must be performed by the user   
            to transform the Ritz values computed for OP by DNAUPD to those   
            of the original system A*z = lambda*B*z. See remark 3 below.   

    DI      Double precision array of dimension NEV+1.  (OUTPUT)   
            On exit, DI contains the imaginary part of the Ritz value   
            approximations to the eigenvalues of A*z = lambda*B*z associated   
            with DR.   

            NOTE: When Ritz values are complex, they will come in complex   
                  conjugate pairs.  If eigenvectors are requested, the   
                  corresponding Ritz vectors will also come in conjugate   
                  pairs and the real and imaginary parts of these are   
                  represented in two consecutive columns of the array Z   
                  (see below).   

    Z       Double precision N by NEV+1 array if RVEC = .TRUE. and HOWMNY = 'A'. (OUTPUT)   
            On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of   
            Z represent approximate eigenvectors (Ritz vectors) corresponding   
            to the NCONV=IPARAM(5) Ritz values for eigensystem   
            A*z = lambda*B*z.   

            The complex Ritz vector associated with the Ritz value   
            with positive imaginary part is stored in two consecutive   
            columns.  The first column holds the real part of the Ritz   
            vector and the second column holds the imaginary part.  The   
            Ritz vector associated with the Ritz value with negative   
            imaginary part is simply the complex conjugate of the Ritz vector   
            associated with the positive imaginary part.   

            If  RVEC = .FALSE. or HOWMNY = 'P', then Z is not referenced.   

            NOTE: If if RVEC = .TRUE. and a Schur basis is not required,   
            the array Z may be set equal to first NEV+1 columns of the Arnoldi   
            basis array V computed by DNAUPD.  In this case the Arnoldi basis   
            will be destroyed and overwritten with the eigenvector basis.   

    LDZ     Integer.  (INPUT)   
            The leading dimension of the array Z.  If Ritz vectors are   
            desired, then  LDZ >= max( 1, N ).  In any case,  LDZ >= 1.   

    SIGMAR  Double precision  (INPUT)   
            If IPARAM(7) = 3 or 4, represents the real part of the shift.   
            Not referenced if IPARAM(7) = 1 or 2.   

    SIGMAI  Double precision  (INPUT)   
            If IPARAM(7) = 3 or 4, represents the imaginary part of the shift.   
            Not referenced if IPARAM(7) = 1 or 2. See remark 3 below.   

    WORKEV  Double precision work array of dimension 3*NCV.  (WORKSPACE)   

    **** The remaining arguments MUST be the same as for the   ****   
    **** call to DNAUPD that was just completed.               ****   

    NOTE: The remaining arguments   

             BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,   
             WORKD, WORKL, LWORKL, INFO   

           must be passed directly to DNEUPD following the last call   
           to DNAUPD.  These arguments MUST NOT BE MODIFIED between   
           the the last call to DNAUPD and the call to DNEUPD.   

    Three of these parameters (V, WORKL, INFO) are also output parameters:   

    V       Double precision N by NCV array.  (INPUT/OUTPUT)   

            Upon INPUT: the NCV columns of V contain the Arnoldi basis   
                        vectors for OP as constructed by DNAUPD .   

            Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns   
                         contain approximate Schur vectors that span the   
                         desired invariant subspace.  See Remark 2 below.   

            NOTE: If the array Z has been set equal to first NEV+1 columns   
            of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the   
            Arnoldi basis held by V has been overwritten by the desired   
            Ritz vectors.  If a separate array Z has been passed then   
            the first NCONV=IPARAM(5) columns of V will contain approximate   
            Schur vectors that span the desired invariant subspace.   

    WORKL   Double precision work array of length LWORKL.  (OUTPUT/WORKSPACE)   
            WORKL(1:ncv*ncv+3*ncv) contains information obtained in   
            dnaupd.  They are not changed by dneupd.   
            WORKL(ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) holds the   
            real and imaginary part of the untransformed Ritz values,   
            the upper quasi-triangular matrix for H, and the   
            associated matrix representation of the invariant subspace for H.   

            Note: IPNTR(9:13) contains the pointer into WORKL for addresses   
            of the above information computed by dneupd.   
            -------------------------------------------------------------   
            IPNTR(9):  pointer to the real part of the NCV RITZ values of the   
                       original system.   
            IPNTR(10): pointer to the imaginary part of the NCV RITZ values of   
                       the original system.   
            IPNTR(11): pointer to the NCV corresponding error bounds.   
            IPNTR(12): pointer to the NCV by NCV upper quasi-triangular   
                       Schur matrix for H.   
            IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors   
                       of the upper Hessenberg matrix H. Only referenced by   
                       dneupd if RVEC = .TRUE. See Remark 2 below.   
            -------------------------------------------------------------   

    INFO    Integer.  (OUTPUT)   
            Error flag on output.   

            =  0: Normal exit.   

            =  1: The Schur form computed by LAPACK routine dlahqr   
                  could not be reordered by LAPACK routine dtrsen.   
                  Re-enter subroutine dneupd with IPARAM(5)=NCV and   
                  increase the size of the arrays DR and DI to have   
                  dimension at least dimension NCV and allocate at least NCV   
                  columns for Z. NOTE: Not necessary if Z and V share   
                  the same space. Please notify the authors if this error   
                  occurs.   

            = -1: N must be positive.   
            = -2: NEV must be positive.   
            = -3: NCV-NEV >= 2 and less than or equal to N.   
            = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'   
            = -6: BMAT must be one of 'I' or 'G'.   
            = -7: Length of private work WORKL array is not sufficient.   
            = -8: Error return from calculation of a real Schur form.   
                  Informational error from LAPACK routine dlahqr.   
            = -9: Error return from calculation of eigenvectors.   
                  Informational error from LAPACK routine dtrevc.   
            = -10: IPARAM(7) must be 1,2,3,4.   
            = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.   
            = -12: HOWMNY = 'S' not yet implemented   
            = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.   
            = -14: DNAUPD did not find any eigenvalues to sufficient   
                   accuracy.   

   \BeginLib   

   \References:   
    1. D.C. Sorensen, "Implicit Application of Polynomial Filters in   
       a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),   
       pp 357-385.   
    2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly   
       Restarted Arnoldi Iteration", Rice University Technical Report   
       TR95-13, Department of Computational and Applied Mathematics.   
    3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for   
       Real Matrices", Linear Algebra and its Applications, vol 88/89,   
       pp 575-595, (1987).   

   \Routines called:   
       ivout   ARPACK utility routine that prints integers.   
       dmout   ARPACK utility routine that prints matrices   
       dvout   ARPACK utility routine that prints vectors.   
       dgeqr2  LAPACK routine that computes the QR factorization of   
               a matrix.   
       dlacpy  LAPACK matrix copy routine.   
       dlahqr  LAPACK routine to compute the real Schur form of an   
               upper Hessenberg matrix.   
       dlamch  LAPACK routine that determines machine constants.   
       dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.   
       dlaset  LAPACK matrix initialization routine.   
       dorm2r  LAPACK routine that applies an orthogonal matrix in   
               factored form.   
       dtrevc  LAPACK routine to compute the eigenvectors of a matrix   
               in upper quasi-triangular form.   
       dtrsen  LAPACK routine that re-orders the Schur form.   
       dtrmm   Level 3 BLAS matrix times an upper triangular matrix.   
       dger    Level 2 BLAS rank one update to a matrix.   
       dcopy   Level 1 BLAS that copies one vector to another .   
       ddot    Level 1 BLAS that computes the scalar product of two vectors.   
       dnrm2   Level 1 BLAS that computes the norm of a vector.   
       dscal   Level 1 BLAS that scales a vector.   

   \Remarks   

    1. Currently only HOWMNY = 'A' and 'P' are implemented.   

       Let X' denote the transpose of X.   

    2. Schur vectors are an orthogonal representation for the basis of   
       Ritz vectors. Thus, their numerical properties are often superior.   
       If RVEC = .TRUE. then the relationship   
               A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and   
       V(:,1:IPARAM(5))' * V(:,1:IPARAM(5)) = I are approximately satisfied.   
       Here T is the leading submatrix of order IPARAM(5) of the real   
       upper quasi-triangular matrix stored workl(ipntr(12)). That is,   
       T is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;   
       each 2-by-2 diagonal block has its diagonal elements equal and its   
       off-diagonal elements of opposite sign.  Corresponding to each 2-by-2   
       diagonal block is a complex conjugate pair of Ritz values. The real   
       Ritz values are stored on the diagonal of T.   

    3. If IPARAM(7) = 3 or 4 and SIGMAI is not equal zero, then the user must   
       form the IPARAM(5) Rayleigh quotients in order to transform the Ritz   
       values computed by DNAUPD for OP to those of A*z = lambda*B*z.   
       Set RVEC = .true. and HOWMNY = 'A', and   
       compute   
             Z(:,I)' * A * Z(:,I) if DI(I) = 0.   
       If DI(I) is not equal to zero and DI(I+1) = - D(I),   
       then the desired real and imaginary parts of the Ritz value are   
             Z(:,I)' * A * Z(:,I) +  Z(:,I+1)' * A * Z(:,I+1),   
             Z(:,I)' * A * Z(:,I+1) -  Z(:,I+1)' * A * Z(:,I), respectively.   
       Another possibility is to set RVEC = .true. and HOWMNY = 'P' and   
       compute V(:,1:IPARAM(5))' * A * V(:,1:IPARAM(5)) and then an upper   
       quasi-triangular matrix of order IPARAM(5) is computed. See remark   
       2 above.   

   \Authors   
       Danny Sorensen               Phuong Vu   
       Richard Lehoucq              CRPC / Rice University   
       Chao Yang                    Houston, Texas   
       Dept. of Computational &   
       Applied Mathematics   
       Rice University   
       Houston, Texas   

   \SCCS Information: @(#)   
   FILE: neupd.F   SID: 2.5   DATE OF SID: 7/31/96   RELEASE: 2   

   \EndLib   

   -----------------------------------------------------------------------   
   Subroutine */ int igraphdneupd_(logical *rvec, char *howmny, logical *select, 
	doublereal *dr, doublereal *di, doublereal *z__, integer *ldz, 
	doublereal *sigmar, doublereal *sigmai, doublereal *workev, char *
	bmat, integer *n, char *which, integer *nev, doublereal *tol, 
	doublereal *resid, integer *ncv, doublereal *v, integer *ldv, integer 
	*iparam, integer *ipntr, doublereal *workd, doublereal *workl, 
	integer *lworkl, integer *info)
{
    /* System generated locals */
    integer v_dim1, v_offset, z_dim1, z_offset, i__1;
    doublereal d__1, d__2;

    /* Builtin functions */
    double pow_dd(doublereal *, doublereal *);
    integer s_cmp(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    integer j, k, ih;
    doublereal vl[1]	/* was [1][1] */;
    integer ibd, ldh, ldq, iri;
    doublereal sep;
    integer irr, wri, wrr;
    extern /* Subroutine */ int igraphdger_(integer *, integer *, doublereal *, 
	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
	    integer *);
    integer mode;
    doublereal eps23;
    integer ierr;
    doublereal temp;
    integer iwev;
    char type__[6];
    extern doublereal igraphdnrm2_(integer *, doublereal *, integer *);
    doublereal temp1;
    extern /* Subroutine */ int igraphdscal_(integer *, doublereal *, doublereal *, 
	    integer *);
    integer ihbds, iconj;
    extern /* Subroutine */ int igraphdgemv_(char *, integer *, integer *, 
	    doublereal *, doublereal *, integer *, doublereal *, integer *, 
	    doublereal *, doublereal *, integer *);
    doublereal conds;
    logical reord;
    extern /* Subroutine */ int igraphdcopy_(integer *, doublereal *, integer *, 
	    doublereal *, integer *);
    integer nconv;
    extern /* Subroutine */ int igraphdtrmm_(char *, char *, char *, char *, 
	    integer *, integer *, doublereal *, doublereal *, integer *, 
	    doublereal *, integer *);
    doublereal thres;
    extern /* Subroutine */ int igraphdmout_(integer *, integer *, integer *, 
	    doublereal *, integer *, integer *, char *, ftnlen);
    integer iwork[1];
    doublereal rnorm;
    integer ritzi;
    extern /* Subroutine */ int igraphdvout_(integer *, integer *, doublereal *, 
	    integer *, char *, ftnlen), igraphivout_(integer *, integer *, integer *
	    , integer *, char *, ftnlen);
    integer ritzr;
    extern /* Subroutine */ int igraphdgeqr2_(integer *, integer *, doublereal *, 
	    integer *, doublereal *, doublereal *, integer *);
    extern doublereal igraphdlapy2_(doublereal *, doublereal *);
    extern /* Subroutine */ int igraphdorm2r_(char *, char *, integer *, integer *, 
	    integer *, doublereal *, integer *, doublereal *, doublereal *, 
	    integer *, doublereal *, integer *);
    extern doublereal igraphdlamch_(char *);
    integer iheigi, iheigr;
    extern /* Subroutine */ int igraphdlahqr_(logical *, logical *, integer *, 
	    integer *, integer *, doublereal *, integer *, doublereal *, 
	    doublereal *, integer *, integer *, doublereal *, integer *, 
	    integer *), igraphdlacpy_(char *, integer *, integer *, doublereal *, 
	    integer *, doublereal *, integer *), igraphdlaset_(char *, 
	    integer *, integer *, doublereal *, doublereal *, doublereal *, 
	    integer *);
    integer logfil, ndigit;
    extern /* Subroutine */ int igraphdtrevc_(char *, char *, logical *, integer *, 
	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
	    integer *, integer *, integer *, doublereal *, integer *);
    integer mneupd = 0, bounds;
    extern /* Subroutine */ int igraphdtrsen_(char *, char *, logical *, integer *, 
	    doublereal *, integer *, doublereal *, integer *, doublereal *, 
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, integer *, integer *, integer *);
    integer msglvl, ktrord, invsub, iuptri, outncv;


/*     %----------------------------------------------------%   
       | Include files for debugging and timing information |   
       %----------------------------------------------------%   


       %------------------%   
       | Scalar Arguments |   
       %------------------%   


       %-----------------%   
       | Array Arguments |   
       %-----------------%   


       %------------%   
       | Parameters |   
       %------------%   


       %---------------%   
       | Local Scalars |   
       %---------------%   


       %----------------------%   
       | External Subroutines |   
       %----------------------%   


       %--------------------%   
       | External Functions |   
       %--------------------%   


       %---------------------%   
       | Intrinsic Functions |   
       %---------------------%   


       %-----------------------%   
       | Executable Statements |   
       %-----------------------%   

       %------------------------%   
       | Set default parameters |   
       %------------------------%   

       Parameter adjustments */
    z_dim1 = *ldz;
    z_offset = 1 + z_dim1;
    z__ -= z_offset;
    --workd;
    --resid;
    --di;
    --dr;
    --workev;
    --select;
    v_dim1 = *ldv;
    v_offset = 1 + v_dim1;
    v -= v_offset;
    --iparam;
    --ipntr;
    --workl;

    /* Function Body */
    msglvl = mneupd;
    mode = iparam[7];
    nconv = iparam[5];
    *info = 0;

/*     %---------------------------------%   
       | Get machine dependent constant. |   
       %---------------------------------% */

    eps23 = igraphdlamch_("Epsilon-Machine");
    eps23 = pow_dd(&eps23, &dlagtf__c_b3);

/*     %--------------%   
       | Quick return |   
       %--------------% */

    ierr = 0;

    if (nconv <= 0) {
	ierr = -14;
    } else if (*n <= 0) {
	ierr = -1;
    } else if (*nev <= 0) {
	ierr = -2;
    } else if (*ncv <= *nev + 1 || *ncv > *n) {
	ierr = -3;
    } else if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) != 0 && s_cmp(which, 
	    "SM", (ftnlen)2, (ftnlen)2) != 0 && s_cmp(which, "LR", (ftnlen)2, 
	    (ftnlen)2) != 0 && s_cmp(which, "SR", (ftnlen)2, (ftnlen)2) != 0 
	    && s_cmp(which, "LI", (ftnlen)2, (ftnlen)2) != 0 && s_cmp(which, 
	    "SI", (ftnlen)2, (ftnlen)2) != 0) {
	ierr = -5;
    } else if (*(unsigned char *)bmat != 'I' && *(unsigned char *)bmat != 'G')
	     {
	ierr = -6;
    } else /* if(complicated condition) */ {
/* Computing 2nd power */
	i__1 = *ncv;
	if (*lworkl < i__1 * i__1 * 3 + *ncv * 6) {
	    ierr = -7;
	} else if (*(unsigned char *)howmny != 'A' && *(unsigned char *)
		howmny != 'P' && *(unsigned char *)howmny != 'S' && *rvec) {
	    ierr = -13;
	} else if (*(unsigned char *)howmny == 'S') {
	    ierr = -12;
	}
    }

    if (mode == 1 || mode == 2) {
	s_copy(type__, "REGULR", (ftnlen)6, (ftnlen)6);
    } else if (mode == 3 && *sigmai == 0.) {
	s_copy(type__, "SHIFTI", (ftnlen)6, (ftnlen)6);
    } else if (mode == 3) {
	s_copy(type__, "REALPT", (ftnlen)6, (ftnlen)6);
    } else if (mode == 4) {
	s_copy(type__, "IMAGPT", (ftnlen)6, (ftnlen)6);
    } else {
	ierr = -10;
    }
    if (mode == 1 && *(unsigned char *)bmat == 'G') {
	ierr = -11;
    }

/*     %------------%   
       | Error Exit |   
       %------------% */

    if (ierr != 0) {
	*info = ierr;
	goto L9000;
    }

/*     %--------------------------------------------------------%   
       | Pointer into WORKL for address of H, RITZ, BOUNDS, Q   |   
       | etc... and the remaining workspace.                    |   
       | Also update pointer to be used on output.              |   
       | Memory is laid out as follows:                         |   
       | workl(1:ncv*ncv) := generated Hessenberg matrix        |   
       | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary   |   
       |                                   parts of ritz values |   
       | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds   |   
       %--------------------------------------------------------%   

       %-----------------------------------------------------------%   
       | The following is used and set by DNEUPD.                  |   
       | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |   
       |                             real part of the Ritz values. |   
       | workl(ncv*ncv+4*ncv+1:ncv*ncv+5*ncv) := The untransformed |   
       |                        imaginary part of the Ritz values. |   
       | workl(ncv*ncv+5*ncv+1:ncv*ncv+6*ncv) := The untransformed |   
       |                           error bounds of the Ritz values |   
       | workl(ncv*ncv+6*ncv+1:2*ncv*ncv+6*ncv) := Holds the upper |   
       |                             quasi-triangular matrix for H |   
       | workl(2*ncv*ncv+6*ncv+1: 3*ncv*ncv+6*ncv) := Holds the    |   
       |       associated matrix representation of the invariant   |   
       |       subspace for H.                                     |   
       | GRAND total of NCV * ( 3 * NCV + 6 ) locations.           |   
       %-----------------------------------------------------------% */

    ih = ipntr[5];
    ritzr = ipntr[6];
    ritzi = ipntr[7];
    bounds = ipntr[8];
    ldh = *ncv;
    ldq = *ncv;
    iheigr = bounds + ldh;
    iheigi = iheigr + ldh;
    ihbds = iheigi + ldh;
    iuptri = ihbds + ldh;
    invsub = iuptri + ldh * *ncv;
    ipntr[9] = iheigr;
    ipntr[10] = iheigi;
    ipntr[11] = ihbds;
    ipntr[12] = iuptri;
    ipntr[13] = invsub;
    wrr = 1;
    wri = *ncv + 1;
    iwev = wri + *ncv;

/*     %-----------------------------------------%   
       | irr points to the REAL part of the Ritz |   
       |     values computed by _neigh before    |   
       |     exiting _naup2.                     |   
       | iri points to the IMAGINARY part of the |   
       |     Ritz values computed by _neigh      |   
       |     before exiting _naup2.              |   
       | ibd points to the Ritz estimates        |   
       |     computed by _neigh before exiting   |   
       |     _naup2.                             |   
       %-----------------------------------------% */

    irr = ipntr[14] + *ncv * *ncv;
    iri = irr + *ncv;
    ibd = iri + *ncv;

/*     %------------------------------------%   
       | RNORM is B-norm of the RESID(1:N). |   
       %------------------------------------% */

    rnorm = workl[ih + 2];
    workl[ih + 2] = 0.;

    if (*rvec) {

/*        %-------------------------------------------%   
          | Get converged Ritz value on the boundary. |   
          | Note: converged Ritz values have been     |   
          | placed in the first NCONV locations in    |   
          | workl(ritzr) and workl(ritzi).  They have |   
          | been sorted (in _naup2) according to the  |   
          | WHICH selection criterion.                |   
          %-------------------------------------------% */

	if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(which, 
		"SM", (ftnlen)2, (ftnlen)2) == 0) {
	    thres = igraphdlapy2_(&workl[ritzr], &workl[ritzi]);
	} else if (s_cmp(which, "LR", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		which, "SR", (ftnlen)2, (ftnlen)2) == 0) {
	    thres = workl[ritzr];
	} else if (s_cmp(which, "LI", (ftnlen)2, (ftnlen)2) == 0 || s_cmp(
		which, "SI", (ftnlen)2, (ftnlen)2) == 0) {
	    thres = (d__1 = workl[ritzi], abs(d__1));
	}

	if (msglvl > 2) {
	    igraphdvout_(&logfil, &dlagtf__c__1, &thres, &ndigit, "_neupd: Threshold eigen"
		    "value used for re-ordering", (ftnlen)49);
	}

/*        %----------------------------------------------------------%   
          | Check to see if all converged Ritz values appear at the  |   
          | top of the upper quasi-triangular matrix computed by     |   
          | _neigh in _naup2.  This is done in the following way:    |   
          |                                                          |   
          | 1) For each Ritz value obtained from _neigh, compare it  |   
          |    with the threshold Ritz value computed above to       |   
          |    determine whether it is a wanted one.                 |   
          |                                                          |   
          | 2) If it is wanted, then check the corresponding Ritz    |   
          |    estimate to see if it has converged.  If it has, set  |   
          |    correponding entry in the logical array SELECT to     |   
          |    .TRUE..                                               |   
          |                                                          |   
          | If SELECT(j) = .TRUE. and j > NCONV, then there is a     |   
          | converged Ritz value that does not appear at the top of  |   
          | the upper quasi-triangular matrix computed by _neigh in  |   
          | _naup2.  Reordering is needed.                           |   
          %----------------------------------------------------------% */

	reord = FALSE_;
	ktrord = 0;
	i__1 = *ncv - 1;
	for (j = 0; j <= i__1; ++j) {
	    select[j + 1] = FALSE_;
	    if (s_cmp(which, "LM", (ftnlen)2, (ftnlen)2) == 0) {
		if (igraphdlapy2_(&workl[irr + j], &workl[iri + j]) >= thres) {
/* Computing MAX */
		    d__1 = eps23, d__2 = igraphdlapy2_(&workl[irr + j], &workl[iri 
			    + j]);
		    temp1 = max(d__1,d__2);
		    if (workl[ibd + j] <= *tol * temp1) {
			select[j + 1] = TRUE_;
		    }
		}
	    } else if (s_cmp(which, "SM", (ftnlen)2, (ftnlen)2) == 0) {
		if (igraphdlapy2_(&workl[irr + j], &workl[iri + j]) <= thres) {
/* Computing MAX */
		    d__1 = eps23, d__2 = igraphdlapy2_(&workl[irr + j], &workl[iri 
			    + j]);
		    temp1 = max(d__1,d__2);
		    if (workl[ibd + j] <= *tol * temp1) {
			select[j + 1] = TRUE_;
		    }
		}
	    } else if (s_cmp(which, "LR", (ftnlen)2, (ftnlen)2) == 0) {
		if (workl[irr + j] >= thres) {
/* Computing MAX */
		    d__1 = eps23, d__2 = igraphdlapy2_(&workl[irr + j], &workl[iri 
			    + j]);
		    temp1 = max(d__1,d__2);
		    if (workl[ibd + j] <= *tol * temp1) {
			select[j + 1] = TRUE_;
		    }
		}
	    } else if (s_cmp(which, "SR", (ftnlen)2, (ftnlen)2) == 0) {
		if (workl[irr + j] <= thres) {
/* Computing MAX */
		    d__1 = eps23, d__2 = igraphdlapy2_(&workl[irr + j], &workl[iri 
			    + j]);
		    temp1 = max(d__1,d__2);
		    if (workl[ibd + j] <= *tol * temp1) {
			select[j + 1] = TRUE_;
		    }
		}
	    } else if (s_cmp(which, "LI", (ftnlen)2, (ftnlen)2) == 0) {
		if ((d__1 = workl[iri + j], abs(d__1)) >= thres) {
/* Computing MAX */
		    d__1 = eps23, d__2 = igraphdlapy2_(&workl[irr + j], &workl[iri 
			    + j]);
		    temp1 = max(d__1,d__2);
		    if (workl[ibd + j] <= *tol * temp1) {
			select[j + 1] = TRUE_;
		    }
		}
	    } else if (s_cmp(which, "SI", (ftnlen)2, (ftnlen)2) == 0) {
		if ((d__1 = workl[iri + j], abs(d__1)) <= thres) {
/* Computing MAX */
		    d__1 = eps23, d__2 = igraphdlapy2_(&workl[irr + j], &workl[iri 
			    + j]);
		    temp1 = max(d__1,d__2);
		    if (workl[ibd + j] <= *tol * temp1) {
			select[j + 1] = TRUE_;
		    }
		}
	    }
	    if (j + 1 > nconv) {
		reord = select[j + 1] || reord;
	    }
	    if (select[j + 1]) {
		++ktrord;
	    }
/* L10: */
	}

	if (msglvl > 2) {
	    igraphivout_(&logfil, &dlagtf__c__1, &ktrord, &ndigit, "_neupd: Number of spec"
		    "ified eigenvalues", (ftnlen)39);
	    igraphivout_(&logfil, &dlagtf__c__1, &nconv, &ndigit, "_neupd: Number of \"con"
		    "verged\" eigenvalues", (ftnlen)41);
	}

/*        %-----------------------------------------------------------%   
          | Call LAPACK routine dlahqr to compute the real Schur form |   
          | of the upper Hessenberg matrix returned by DNAUPD.        |   
          | Make a copy of the upper Hessenberg matrix.               |   
          | Initialize the Schur vector matrix Q to the identity.     |   
          %-----------------------------------------------------------% */

	i__1 = ldh * *ncv;
	igraphdcopy_(&i__1, &workl[ih], &dlagtf__c__1, &workl[iuptri], &dlagtf__c__1);
	igraphdlaset_("All", ncv, ncv, &dlagtf__c_b44, &dlagtf__c_b45, &workl[invsub], &ldq);
	igraphdlahqr_(&dlagtf__c_true, &dlagtf__c_true, ncv, &dlagtf__c__1, ncv, &workl[iuptri], &ldh, &
		workl[iheigr], &workl[iheigi], &dlagtf__c__1, ncv, &workl[invsub], &
		ldq, &ierr);
	igraphdcopy_(ncv, &workl[invsub + *ncv - 1], &ldq, &workl[ihbds], &dlagtf__c__1);

	if (ierr != 0) {
	    *info = -8;
	    goto L9000;
	}

	if (msglvl > 1) {
	    igraphdvout_(&logfil, ncv, &workl[iheigr], &ndigit, "_neupd: Real part"
		    " of the eigenvalues of H", (ftnlen)41);
	    igraphdvout_(&logfil, ncv, &workl[iheigi], &ndigit, "_neupd: Imaginary"
		    " part of the Eigenvalues of H", (ftnlen)46);
	    igraphdvout_(&logfil, ncv, &workl[ihbds], &ndigit, "_neupd: Last row o"
		    "f the Schur vector matrix", (ftnlen)43);
	    if (msglvl > 3) {
		igraphdmout_(&logfil, ncv, ncv, &workl[iuptri], &ldh, &ndigit, 
			"_neupd: The upper quasi-triangular matrix ", (ftnlen)
			42);
	    }
	}

	if (reord) {

/*           %-----------------------------------------------------%   
             | Reorder the computed upper quasi-triangular matrix. |   
             %-----------------------------------------------------% */

	    igraphdtrsen_("None", "V", &select[1], ncv, &workl[iuptri], &ldh, &
		    workl[invsub], &ldq, &workl[iheigr], &workl[iheigi], &
		    nconv, &conds, &sep, &workl[ihbds], ncv, iwork, &dlagtf__c__1, &
		    ierr);

	    if (ierr == 1) {
		*info = 1;
		goto L9000;
	    }

	    if (msglvl > 2) {
		igraphdvout_(&logfil, ncv, &workl[iheigr], &ndigit, "_neupd: Real "
			"part of the eigenvalues of H--reordered", (ftnlen)52);
		igraphdvout_(&logfil, ncv, &workl[iheigi], &ndigit, "_neupd: Imag "
			"part of the eigenvalues of H--reordered", (ftnlen)52);
		if (msglvl > 3) {
		    igraphdmout_(&logfil, ncv, ncv, &workl[iuptri], &ldq, &ndigit, 
			    "_neupd: Quasi-triangular matrix after re-orderi"
			    "ng", (ftnlen)49);
		}
	    }

	}

/*        %---------------------------------------%   
          | Copy the last row of the Schur vector |   
          | into workl(ihbds).  This will be used |   
          | to compute the Ritz estimates of      |   
          | converged Ritz values.                |   
          %---------------------------------------% */

	igraphdcopy_(ncv, &workl[invsub + *ncv - 1], &ldq, &workl[ihbds], &dlagtf__c__1);

/*        %----------------------------------------------------%   
          | Place the computed eigenvalues of H into DR and DI |   
          | if a spectral transformation was not used.         |   
          %----------------------------------------------------% */

	if (s_cmp(type__, "REGULR", (ftnlen)6, (ftnlen)6) == 0) {
	    igraphdcopy_(&nconv, &workl[iheigr], &dlagtf__c__1, &dr[1], &dlagtf__c__1);
	    igraphdcopy_(&nconv, &workl[iheigi], &dlagtf__c__1, &di[1], &dlagtf__c__1);
	}

/*        %----------------------------------------------------------%   
          | Compute the QR factorization of the matrix representing  |   
          | the wanted invariant subspace located in the first NCONV |   
          | columns of workl(invsub,ldq).                            |   
          %----------------------------------------------------------% */

	igraphdgeqr2_(ncv, &nconv, &workl[invsub], &ldq, &workev[1], &workev[*ncv + 
		1], &ierr);

/*        %---------------------------------------------------------%   
          | * Postmultiply V by Q using dorm2r.                     |   
          | * Copy the first NCONV columns of VQ into Z.            |   
          | * Postmultiply Z by R.                                  |   
          | The N by NCONV matrix Z is now a matrix representation  |   
          | of the approximate invariant subspace associated with   |   
          | the Ritz values in workl(iheigr) and workl(iheigi)      |   
          | The first NCONV columns of V are now approximate Schur  |   
          | vectors associated with the real upper quasi-triangular |   
          | matrix of order NCONV in workl(iuptri)                  |   
          %---------------------------------------------------------% */

	igraphdorm2r_("Right", "Notranspose", n, ncv, &nconv, &workl[invsub], &ldq, 
		&workev[1], &v[v_offset], ldv, &workd[*n + 1], &ierr);
	igraphdlacpy_("All", n, &nconv, &v[v_offset], ldv, &z__[z_offset], ldz);

	i__1 = nconv;
	for (j = 1; j <= i__1; ++j) {

/*           %---------------------------------------------------%   
             | Perform both a column and row scaling if the      |   
             | diagonal element of workl(invsub,ldq) is negative |   
             | I'm lazy and don't take advantage of the upper    |   
             | quasi-triangular form of workl(iuptri,ldq)        |   
             | Note that since Q is orthogonal, R is a diagonal  |   
             | matrix consisting of plus or minus ones           |   
             %---------------------------------------------------% */

	    if (workl[invsub + (j - 1) * ldq + j - 1] < 0.) {
		igraphdscal_(&nconv, &dlagtf__c_b71, &workl[iuptri + j - 1], &ldq);
		igraphdscal_(&nconv, &dlagtf__c_b71, &workl[iuptri + (j - 1) * ldq], &dlagtf__c__1);
	    }

/* L20: */
	}

	if (*(unsigned char *)howmny == 'A') {

/*           %--------------------------------------------%   
             | Compute the NCONV wanted eigenvectors of T |   
             | located in workl(iuptri,ldq).              |   
             %--------------------------------------------% */

	    i__1 = *ncv;
	    for (j = 1; j <= i__1; ++j) {
		if (j <= nconv) {
		    select[j] = TRUE_;
		} else {
		    select[j] = FALSE_;
		}
/* L30: */
	    }

	    igraphdtrevc_("Right", "Select", &select[1], ncv, &workl[iuptri], &ldq, 
		    vl, &dlagtf__c__1, &workl[invsub], &ldq, ncv, &outncv, &workev[1],
		     &ierr);

	    if (ierr != 0) {
		*info = -9;
		goto L9000;
	    }

/*           %------------------------------------------------%   
             | Scale the returning eigenvectors so that their |   
             | Euclidean norms are all one. LAPACK subroutine |   
             | dtrevc returns each eigenvector normalized so  |   
             | that the element of largest magnitude has      |   
             | magnitude 1;                                   |   
             %------------------------------------------------% */

	    iconj = 0;
	    i__1 = nconv;
	    for (j = 1; j <= i__1; ++j) {

		if (workl[iheigi + j - 1] == 0.) {

/*                 %----------------------%   
                   | real eigenvalue case |   
                   %----------------------% */

		    temp = igraphdnrm2_(ncv, &workl[invsub + (j - 1) * ldq], &dlagtf__c__1);
		    d__1 = 1. / temp;
		    igraphdscal_(ncv, &d__1, &workl[invsub + (j - 1) * ldq], &dlagtf__c__1);

		} else {

/*                 %-------------------------------------------%   
                   | Complex conjugate pair case. Note that    |   
                   | since the real and imaginary part of      |   
                   | the eigenvector are stored in consecutive |   
                   | columns, we further normalize by the      |   
                   | square root of two.                       |   
                   %-------------------------------------------% */

		    if (iconj == 0) {
			d__1 = igraphdnrm2_(ncv, &workl[invsub + (j - 1) * ldq], &
				dlagtf__c__1);
			d__2 = igraphdnrm2_(ncv, &workl[invsub + j * ldq], &dlagtf__c__1);
			temp = igraphdlapy2_(&d__1, &d__2);
			d__1 = 1. / temp;
			igraphdscal_(ncv, &d__1, &workl[invsub + (j - 1) * ldq], &
				dlagtf__c__1);
			d__1 = 1. / temp;
			igraphdscal_(ncv, &d__1, &workl[invsub + j * ldq], &dlagtf__c__1);
			iconj = 1;
		    } else {
			iconj = 0;
		    }

		}

/* L40: */
	    }

	    igraphdgemv_("T", ncv, &nconv, &dlagtf__c_b45, &workl[invsub], &ldq, &workl[
		    ihbds], &dlagtf__c__1, &dlagtf__c_b44, &workev[1], &dlagtf__c__1);

	    iconj = 0;
	    i__1 = nconv;
	    for (j = 1; j <= i__1; ++j) {
		if (workl[iheigi + j - 1] != 0.) {

/*                 %-------------------------------------------%   
                   | Complex conjugate pair case. Note that    |   
                   | since the real and imaginary part of      |   
                   | the eigenvector are stored in consecutive |   
                   %-------------------------------------------% */

		    if (iconj == 0) {
			workev[j] = igraphdlapy2_(&workev[j], &workev[j + 1]);
			workev[j + 1] = workev[j];
			iconj = 1;
		    } else {
			iconj = 0;
		    }
		}
/* L45: */
	    }

	    if (msglvl > 2) {
		igraphdcopy_(ncv, &workl[invsub + *ncv - 1], &ldq, &workl[ihbds], &
			dlagtf__c__1);
		igraphdvout_(&logfil, ncv, &workl[ihbds], &ndigit, "_neupd: Last r"
			"ow of the eigenvector matrix for T", (ftnlen)48);
		if (msglvl > 3) {
		    igraphdmout_(&logfil, ncv, ncv, &workl[invsub], &ldq, &ndigit, 
			    "_neupd: The eigenvector matrix for T", (ftnlen)
			    36);
		}
	    }

/*           %---------------------------------------%   
             | Copy Ritz estimates into workl(ihbds) |   
             %---------------------------------------% */

	    igraphdcopy_(&nconv, &workev[1], &dlagtf__c__1, &workl[ihbds], &dlagtf__c__1);

/*           %---------------------------------------------------------%   
             | Compute the QR factorization of the eigenvector matrix  |   
             | associated with leading portion of T in the first NCONV |   
             | columns of workl(invsub,ldq).                           |   
             %---------------------------------------------------------% */

	    igraphdgeqr2_(ncv, &nconv, &workl[invsub], &ldq, &workev[1], &workev[*
		    ncv + 1], &ierr);

/*           %----------------------------------------------%   
             | * Postmultiply Z by Q.                       |   
             | * Postmultiply Z by R.                       |   
             | The N by NCONV matrix Z is now contains the  |   
             | Ritz vectors associated with the Ritz values |   
             | in workl(iheigr) and workl(iheigi).          |   
             %----------------------------------------------% */

	    igraphdorm2r_("Right", "Notranspose", n, ncv, &nconv, &workl[invsub], &
		    ldq, &workev[1], &z__[z_offset], ldz, &workd[*n + 1], &
		    ierr);

	    igraphdtrmm_("Right", "Upper", "No transpose", "Non-unit", n, &nconv, &
		    dlagtf__c_b45, &workl[invsub], &ldq, &z__[z_offset], ldz);

	}

    } else {

/*        %------------------------------------------------------%   
          | An approximate invariant subspace is not needed.     |   
          | Place the Ritz values computed DNAUPD into DR and DI |   
          %------------------------------------------------------% */

	igraphdcopy_(&nconv, &workl[ritzr], &dlagtf__c__1, &dr[1], &dlagtf__c__1);
	igraphdcopy_(&nconv, &workl[ritzi], &dlagtf__c__1, &di[1], &dlagtf__c__1);
	igraphdcopy_(&nconv, &workl[ritzr], &dlagtf__c__1, &workl[iheigr], &dlagtf__c__1);
	igraphdcopy_(&nconv, &workl[ritzi], &dlagtf__c__1, &workl[iheigi], &dlagtf__c__1);
	igraphdcopy_(&nconv, &workl[bounds], &dlagtf__c__1, &workl[ihbds], &dlagtf__c__1);
    }

/*     %------------------------------------------------%   
       | Transform the Ritz values and possibly vectors |   
       | and corresponding error bounds of OP to those  |   
       | of A*x = lambda*B*x.                           |   
       %------------------------------------------------% */

    if (s_cmp(type__, "REGULR", (ftnlen)6, (ftnlen)6) == 0) {

	if (*rvec) {
	    igraphdscal_(ncv, &rnorm, &workl[ihbds], &dlagtf__c__1);
	}

    } else {

/*        %---------------------------------------%   
          |   A spectral transformation was used. |   
          | * Determine the Ritz estimates of the |   
          |   Ritz values in the original system. |   
          %---------------------------------------% */

	if (s_cmp(type__, "SHIFTI", (ftnlen)6, (ftnlen)6) == 0) {

	    if (*rvec) {
		igraphdscal_(ncv, &rnorm, &workl[ihbds], &dlagtf__c__1);
	    }

	    i__1 = *ncv;
	    for (k = 1; k <= i__1; ++k) {
		temp = igraphdlapy2_(&workl[iheigr + k - 1], &workl[iheigi + k - 1])
			;
		workl[ihbds + k - 1] = (d__1 = workl[ihbds + k - 1], abs(d__1)
			) / temp / temp;
/* L50: */
	    }

	} else if (s_cmp(type__, "REALPT", (ftnlen)6, (ftnlen)6) == 0) {

	    i__1 = *ncv;
	    for (k = 1; k <= i__1; ++k) {
/* L60: */
	    }

	} else if (s_cmp(type__, "IMAGPT", (ftnlen)6, (ftnlen)6) == 0) {

	    i__1 = *ncv;
	    for (k = 1; k <= i__1; ++k) {
/* L70: */
	    }

	}

/*        %-----------------------------------------------------------%   
          | *  Transform the Ritz values back to the original system. |   
          |    For TYPE = 'SHIFTI' the transformation is              |   
          |             lambda = 1/theta + sigma                      |   
          |    For TYPE = 'REALPT' or 'IMAGPT' the user must from     |   
          |    Rayleigh quotients or a projection. See remark 3 above.|   
          | NOTES:                                                    |   
          | *The Ritz vectors are not affected by the transformation. |   
          %-----------------------------------------------------------% */

	if (s_cmp(type__, "SHIFTI", (ftnlen)6, (ftnlen)6) == 0) {

	    i__1 = *ncv;
	    for (k = 1; k <= i__1; ++k) {
		temp = igraphdlapy2_(&workl[iheigr + k - 1], &workl[iheigi + k - 1])
			;
		workl[iheigr + k - 1] = workl[iheigr + k - 1] / temp / temp + 
			*sigmar;
		workl[iheigi + k - 1] = -workl[iheigi + k - 1] / temp / temp 
			+ *sigmai;
/* L80: */
	    }

	    igraphdcopy_(&nconv, &workl[iheigr], &dlagtf__c__1, &dr[1], &dlagtf__c__1);
	    igraphdcopy_(&nconv, &workl[iheigi], &dlagtf__c__1, &di[1], &dlagtf__c__1);

	} else if (s_cmp(type__, "REALPT", (ftnlen)6, (ftnlen)6) == 0 || 
		s_cmp(type__, "IMAGPT", (ftnlen)6, (ftnlen)6) == 0) {

	    igraphdcopy_(&nconv, &workl[iheigr], &dlagtf__c__1, &dr[1], &dlagtf__c__1);
	    igraphdcopy_(&nconv, &workl[iheigi], &dlagtf__c__1, &di[1], &dlagtf__c__1);

	}

    }

    if (s_cmp(type__, "SHIFTI", (ftnlen)6, (ftnlen)6) == 0 && msglvl > 1) {
	igraphdvout_(&logfil, &nconv, &dr[1], &ndigit, "_neupd: Untransformed real"
		" part of the Ritz valuess.", (ftnlen)52);
	igraphdvout_(&logfil, &nconv, &di[1], &ndigit, "_neupd: Untransformed imag"
		" part of the Ritz valuess.", (ftnlen)52);
	igraphdvout_(&logfil, &nconv, &workl[ihbds], &ndigit, "_neupd: Ritz estima"
		"tes of untransformed Ritz values.", (ftnlen)52);
    } else if (s_cmp(type__, "REGULR", (ftnlen)6, (ftnlen)6) == 0 && msglvl > 
	    1) {
	igraphdvout_(&logfil, &nconv, &dr[1], &ndigit, "_neupd: Real parts of conv"
		"erged Ritz values.", (ftnlen)44);
	igraphdvout_(&logfil, &nconv, &di[1], &ndigit, "_neupd: Imag parts of conv"
		"erged Ritz values.", (ftnlen)44);
	igraphdvout_(&logfil, &nconv, &workl[ihbds], &ndigit, "_neupd: Associated "
		"Ritz estimates.", (ftnlen)34);
    }

/*     %-------------------------------------------------%   
       | Eigenvector Purification step. Formally perform |   
       | one of inverse subspace iteration. Only used    |   
       | for MODE = 2.                                   |   
       %-------------------------------------------------% */

    if (*rvec && *(unsigned char *)howmny == 'A' && s_cmp(type__, "SHIFTI", (
	    ftnlen)6, (ftnlen)6) == 0) {

/*        %------------------------------------------------%   
          | Purify the computed Ritz vectors by adding a   |   
          | little bit of the residual vector:             |   
          |                      T                         |   
          |          resid(:)*( e    s ) / theta           |   
          |                      NCV                       |   
          | where H s = s theta. Remember that when theta  |   
          | has nonzero imaginary part, the corresponding  |   
          | Ritz vector is stored across two columns of Z. |   
          %------------------------------------------------% */

	iconj = 0;
	i__1 = nconv;
	for (j = 1; j <= i__1; ++j) {
	    if (workl[iheigi + j - 1] == 0.) {
		workev[j] = workl[invsub + (j - 1) * ldq + *ncv - 1] / workl[
			iheigr + j - 1];
	    } else if (iconj == 0) {
		temp = igraphdlapy2_(&workl[iheigr + j - 1], &workl[iheigi + j - 1])
			;
		workev[j] = (workl[invsub + (j - 1) * ldq + *ncv - 1] * workl[
			iheigr + j - 1] + workl[invsub + j * ldq + *ncv - 1] *
			 workl[iheigi + j - 1]) / temp / temp;
		workev[j + 1] = (workl[invsub + j * ldq + *ncv - 1] * workl[
			iheigr + j - 1] - workl[invsub + (j - 1) * ldq + *ncv 
			- 1] * workl[iheigi + j - 1]) / temp / temp;
		iconj = 1;
	    } else {
		iconj = 0;
	    }
/* L110: */
	}

/*        %---------------------------------------%   
          | Perform a rank one update to Z and    |   
          | purify all the Ritz vectors together. |   
          %---------------------------------------% */

	igraphdger_(n, &nconv, &dlagtf__c_b45, &resid[1], &dlagtf__c__1, &workev[1], &dlagtf__c__1, &z__[
		z_offset], ldz);

    }

L9000:

    return 0;

/*     %---------------%   
       | End of DNEUPD |   
       %---------------% */

} /* igraphdneupd_ */




/* The ARPACK example file dssimp.f is used as a template */

static int igraph_i_arpack_err_dsaupd(int error) {
    switch (error) {
    case  1:      return IGRAPH_ARPACK_MAXIT;
    case  3:      return IGRAPH_ARPACK_NOSHIFT;
    case -1:      return IGRAPH_ARPACK_NPOS;
    case -2:      return IGRAPH_ARPACK_NEVNPOS;
    case -3:      return IGRAPH_ARPACK_NCVSMALL;
    case -4:      return IGRAPH_ARPACK_NONPOSI;
    case -5:      return IGRAPH_ARPACK_WHICHINV;
    case -6:      return IGRAPH_ARPACK_BMATINV;
    case -7:      return IGRAPH_ARPACK_WORKLSMALL;
    case -8:      return IGRAPH_ARPACK_TRIDERR;
    case -9:      return IGRAPH_ARPACK_ZEROSTART;
    case -10:     return IGRAPH_ARPACK_MODEINV;
    case -11:     return IGRAPH_ARPACK_MODEBMAT;
    case -12:     return IGRAPH_ARPACK_ISHIFT;
    case -13:     return IGRAPH_ARPACK_NEVBE;
    case -9999:   return IGRAPH_ARPACK_NOFACT;
    default:      return IGRAPH_ARPACK_UNKNOWN;
    }
}

static int igraph_i_arpack_err_dseupd(int error) {
    switch (error) {
    case -1:      return IGRAPH_ARPACK_NPOS;
    case -2:      return IGRAPH_ARPACK_NEVNPOS;
    case -3:      return IGRAPH_ARPACK_NCVSMALL;
    case -5:      return IGRAPH_ARPACK_WHICHINV;
    case -6:      return IGRAPH_ARPACK_BMATINV;
    case -7:      return IGRAPH_ARPACK_WORKLSMALL;
    case -8:      return IGRAPH_ARPACK_TRIDERR;
    case -9:      return IGRAPH_ARPACK_ZEROSTART;
    case -10:     return IGRAPH_ARPACK_MODEINV;
    case -11:     return IGRAPH_ARPACK_MODEBMAT;
    case -12:     return IGRAPH_ARPACK_NEVBE;
    case -14:     return IGRAPH_ARPACK_FAILED;
    case -15:     return IGRAPH_ARPACK_HOWMNY;
    case -16:     return IGRAPH_ARPACK_HOWMNYS;
    case -17:     return IGRAPH_ARPACK_EVDIFF;
    default:      return IGRAPH_ARPACK_UNKNOWN;
    }

}

static int igraph_i_arpack_err_dnaupd(int error) {
    switch (error) {
    case  1:      return IGRAPH_ARPACK_MAXIT;
    case  3:      return IGRAPH_ARPACK_NOSHIFT;
    case -1:      return IGRAPH_ARPACK_NPOS;
    case -2:      return IGRAPH_ARPACK_NEVNPOS;
    case -3:      return IGRAPH_ARPACK_NCVSMALL;
    case -4:      return IGRAPH_ARPACK_NONPOSI;
    case -5:      return IGRAPH_ARPACK_WHICHINV;
    case -6:      return IGRAPH_ARPACK_BMATINV;
    case -7:      return IGRAPH_ARPACK_WORKLSMALL;
    case -8:      return IGRAPH_ARPACK_TRIDERR;
    case -9:      return IGRAPH_ARPACK_ZEROSTART;
    case -10:     return IGRAPH_ARPACK_MODEINV;
    case -11:     return IGRAPH_ARPACK_MODEBMAT;
    case -12:     return IGRAPH_ARPACK_ISHIFT;
    case -9999:   return IGRAPH_ARPACK_NOFACT;
    default:      return IGRAPH_ARPACK_UNKNOWN;
    }
}

static int igraph_i_arpack_err_dneupd(int error) {
    switch (error) {
    case  1:      return IGRAPH_ARPACK_REORDER;
    case -1:      return IGRAPH_ARPACK_NPOS;
    case -2:      return IGRAPH_ARPACK_NEVNPOS;
    case -3:      return IGRAPH_ARPACK_NCVSMALL;
    case -5:      return IGRAPH_ARPACK_WHICHINV;
    case -6:      return IGRAPH_ARPACK_BMATINV;
    case -7:      return IGRAPH_ARPACK_WORKLSMALL;
    case -8:      return IGRAPH_ARPACK_SHUR;
    case -9:      return IGRAPH_ARPACK_LAPACK;
    case -10:     return IGRAPH_ARPACK_MODEINV;
    case -11:     return IGRAPH_ARPACK_MODEBMAT;
    case -12:     return IGRAPH_ARPACK_HOWMNYS;
    case -13:     return IGRAPH_ARPACK_HOWMNY;
    case -14:     return IGRAPH_ARPACK_FAILED;
    case -15:     return IGRAPH_ARPACK_EVDIFF;
    default:      return IGRAPH_ARPACK_UNKNOWN;
    }
}

/**
 * \function igraph_arpack_options_init
 * Initialize ARPACK options
 *
 * Initializes ARPACK options, set them to default values.
 * You can always pass the initialized \ref igraph_arpack_options_t
 * object to built-in igraph functions without any modification. The
 * built-in igraph functions modify the options to perform their
 * calculation, e.g. \ref igraph_pagerank() always searches for the
 * eigenvalue with the largest magnitude, regardless of the supplied
 * value.
 * </para><para>
 * If you want to implement your own function involving eigenvalue
 * calculation using ARPACK, however, you will likely need to set up
 * the fields for yourself.
 * \param o The \ref igraph_arpack_options_t object to initialize.
 *
 * Time complexity: O(1).
 */

void igraph_arpack_options_init(igraph_arpack_options_t *o) {
    o->bmat[0] = 'I';
    o->n = 0;         /* needs to be updated! */
    o->which[0] = 'X'; o->which[1] = 'X';
    o->nev = 1;
    o->tol = 0;
    o->ncv = 0;       /* 0 means "automatic" */
    o->ldv = o->n;        /* will be updated to (real) n */
    o->ishift = 1;
    o->mxiter = 3000;
    o->nb = 1;
    o->mode = 1;
    o->start = 0;
    o->lworkl = 0;
    o->sigma = 0;
    o->sigmai = 0;
    o->info = o->start;

    o->iparam[0] = o->ishift; o->iparam[1] = 0; o->iparam[2] = o->mxiter; o->iparam[3] = o->nb;
    o->iparam[4] = 0; o->iparam[5] = 0; o->iparam[6] = o->mode; o->iparam[7] = 0;
    o->iparam[8] = 0; o->iparam[9] = 0; o->iparam[10] = 0;
}

/**
 * \function igraph_arpack_storage_init
 * Initialize ARPACK storage
 *
 * You only need this function if you want to run multiple eigenvalue
 * calculations using ARPACK, and want to spare the memory
 * allocation/deallocation between each two runs. Otherwise it is safe
 * to supply a null pointer as the \c storage argument of both \ref
 * igraph_arpack_rssolve() and \ref igraph_arpack_rnsolve() to make
 * memory allocated and deallocated automatically.
 *
 * </para><para>Don't forget to call the \ref
 * igraph_arpack_storage_destroy() function on the storage object if
 * you don't need it any more.
 * \param s The \ref igraph_arpack_storage_t object to initialize.
 * \param maxn The maximum order of the matrices.
 * \param maxncv The maximum NCV parameter intended to use.
 * \param maxldv The maximum LDV parameter intended to use.
 * \param symm Whether symmetric or non-symmetric problems will be
 *    solved using this \ref igraph_arpack_storage_t. (You cannot use
 *    the same storage both with symmetric and non-symmetric solvers.)
 * \return Error code.
 *
 * Time complexity: O(maxncv*(maxldv+maxn)).
 */

int igraph_arpack_storage_init(igraph_arpack_storage_t *s, long int maxn,
                               long int maxncv, long int maxldv,
                               igraph_bool_t symm) {

    /* TODO: check arguments */
    s->maxn = (int) maxn;
    s->maxncv = (int) maxncv;
    s->maxldv = (int) maxldv;

#define CHECKMEM(x) \
    if (!x) { \
        IGRAPH_ERROR("Cannot allocate memory for ARPACK", IGRAPH_ENOMEM); \
    } \
    IGRAPH_FINALLY(igraph_free, x);

    s->v = igraph_Calloc(maxldv * maxncv, igraph_real_t); CHECKMEM(s->v);
    s->workd = igraph_Calloc(3 * maxn, igraph_real_t); CHECKMEM(s->workd);
    s->d = igraph_Calloc(2 * maxncv, igraph_real_t); CHECKMEM(s->d);
    s->resid = igraph_Calloc(maxn, igraph_real_t); CHECKMEM(s->resid);
    s->ax = igraph_Calloc(maxn, igraph_real_t); CHECKMEM(s->ax);
    s->select = igraph_Calloc(maxncv, int); CHECKMEM(s->select);

    if (symm) {
        s->workl = igraph_Calloc(maxncv * (maxncv + 8), igraph_real_t); CHECKMEM(s->workl);
        s->di = 0;
        s->workev = 0;
    } else {
        s->workl = igraph_Calloc(3 * maxncv * (maxncv + 2), igraph_real_t); CHECKMEM(s->workl);
        s->di = igraph_Calloc(2 * maxncv, igraph_real_t); CHECKMEM(s->di);
        s->workev = igraph_Calloc(3 * maxncv, igraph_real_t); CHECKMEM(s->workev);
        IGRAPH_FINALLY_CLEAN(2);
    }

#undef CHECKMEM

    IGRAPH_FINALLY_CLEAN(7);
    return 0;
}

/**
 * \function igraph_arpack_storage_destroy
 * Deallocate ARPACK storage
 *
 * \param s The \ref igraph_arpack_storage_t object for which the
 *    memory will be deallocated.
 *
 * Time complexity: operating system dependent.
 */

void igraph_arpack_storage_destroy(igraph_arpack_storage_t *s) {

    if (s->di) {
        igraph_Free(s->di);
    }
    if (s->workev) {
        igraph_Free(s->workev);
    }

    igraph_Free(s->workl);
    igraph_Free(s->select);
    igraph_Free(s->ax);
    igraph_Free(s->resid);
    igraph_Free(s->d);
    igraph_Free(s->workd);
    igraph_Free(s->v);
}

/**
 * "Solver" for 1x1 eigenvalue problems since ARPACK sometimes blows up with
 * these.
 */
static int igraph_i_arpack_rssolve_1x1(igraph_arpack_function_t *fun, void *extra,
                                       igraph_arpack_options_t* options,
                                       igraph_vector_t* values, igraph_matrix_t* vectors) {
    igraph_real_t a, b;
    int nev = options->nev;

    if (nev <= 0) {
        IGRAPH_ERROR("ARPACK error", IGRAPH_ARPACK_NEVNPOS);
    }

    /* Probe the value in the matrix */
    a = 1;
    if (fun(&b, &a, 1, extra)) {
        IGRAPH_ERROR("ARPACK error while evaluating matrix-vector product",
                     IGRAPH_ARPACK_PROD);
    }

    options->nconv = nev;

    if (values != 0) {
        IGRAPH_CHECK(igraph_vector_resize(values, 1));
        VECTOR(*values)[0] = b;
    }

    if (vectors != 0) {
        IGRAPH_CHECK(igraph_matrix_resize(vectors, 1, 1));
        MATRIX(*vectors, 0, 0) = 1;
    }

    return IGRAPH_SUCCESS;
}

/**
 * "Solver" for 1x1 eigenvalue problems since ARPACK sometimes blows up with
 * these.
 */
static int igraph_i_arpack_rnsolve_1x1(igraph_arpack_function_t *fun, void *extra,
                                       igraph_arpack_options_t* options,
                                       igraph_matrix_t* values, igraph_matrix_t* vectors) {
    igraph_real_t a, b;
    int nev = options->nev;

    if (nev <= 0) {
        IGRAPH_ERROR("ARPACK error", IGRAPH_ARPACK_NEVNPOS);
    }

    /* Probe the value in the matrix */
    a = 1;
    if (fun(&b, &a, 1, extra)) {
        IGRAPH_ERROR("ARPACK error while evaluating matrix-vector product",
                     IGRAPH_ARPACK_PROD);
    }

    options->nconv = nev;

    if (values != 0) {
        IGRAPH_CHECK(igraph_matrix_resize(values, 1, 2));
        MATRIX(*values, 0, 0) = b; MATRIX(*values, 0, 1) = 0;
    }

    if (vectors != 0) {
        IGRAPH_CHECK(igraph_matrix_resize(vectors, 1, 1));
        MATRIX(*vectors, 0, 0) = 1;
    }

    return IGRAPH_SUCCESS;
}

/**
 * "Solver" for 2x2 nonsymmetric eigenvalue problems since ARPACK sometimes
 * blows up with these.
 */
static int igraph_i_arpack_rnsolve_2x2(igraph_arpack_function_t *fun, void *extra,
                                       igraph_arpack_options_t* options, igraph_matrix_t* values,
                                       igraph_matrix_t* vectors) {
    igraph_real_t vec[2], mat[4];
    igraph_real_t a, b, c, d;
    igraph_real_t trace, det, tsq4_minus_d;
    igraph_complex_t eval1, eval2;
    igraph_complex_t evec1[2], evec2[2];
    igraph_bool_t swap_evals = 0;
    igraph_bool_t complex_evals = 0;
    int nev = options->nev;

    if (nev <= 0) {
        IGRAPH_ERROR("ARPACK error", IGRAPH_ARPACK_NEVNPOS);
    }
    if (nev > 2) {
        nev = 2;
    }

    /* Probe the values in the matrix */
    vec[0] = 1; vec[1] = 0;
    if (fun(mat, vec, 2, extra)) {
        IGRAPH_ERROR("ARPACK error while evaluating matrix-vector product",
                     IGRAPH_ARPACK_PROD);
    }
    vec[0] = 0; vec[1] = 1;
    if (fun(mat + 2, vec, 2, extra)) {
        IGRAPH_ERROR("ARPACK error while evaluating matrix-vector product",
                     IGRAPH_ARPACK_PROD);
    }
    a = mat[0]; b = mat[2]; c = mat[1]; d = mat[3];

    /* Get the trace and the determinant */
    trace = a + d;
    det = a * d - b * c;
    tsq4_minus_d = trace * trace / 4 - det;

    /* Calculate the eigenvalues */
    complex_evals = tsq4_minus_d < 0;
    eval1 = igraph_complex_sqrt_real(tsq4_minus_d);
    if (complex_evals) {
        eval2 = igraph_complex_mul_real(eval1, -1);
    } else {
        /* to avoid having -0 in the imaginary part */
        eval2 = igraph_complex(-IGRAPH_REAL(eval1), 0);
    }
    eval1 = igraph_complex_add_real(eval1, trace / 2);
    eval2 = igraph_complex_add_real(eval2, trace / 2);

    if (c != 0) {
        evec1[0] = igraph_complex_sub_real(eval1, d);
        evec1[1] = igraph_complex(c, 0);
        evec2[0] = igraph_complex_sub_real(eval2, d);
        evec2[1] = igraph_complex(c, 0);
    } else if (b != 0) {
        evec1[0] = igraph_complex(b, 0);
        evec1[1] = igraph_complex_sub_real(eval1, a);
        evec2[0] = igraph_complex(b, 0);
        evec2[1] = igraph_complex_sub_real(eval2, a);
    } else {
        evec1[0] = igraph_complex(1, 0);
        evec1[1] = igraph_complex(0, 0);
        evec2[0] = igraph_complex(0, 0);
        evec2[1] = igraph_complex(1, 0);
    }

    /* Sometimes we have to swap eval1 with eval2 and evec1 with eval2;
     * determine whether we have to do it now */
    if (options->which[0] == 'S') {
        if (options->which[1] == 'M') {
            /* eval1 must be the one with the smallest magnitude */
            swap_evals = (igraph_complex_mod(eval1) > igraph_complex_mod(eval2));
        } else if (options->which[1] == 'R') {
            /* eval1 must be the one with the smallest real part */
            swap_evals = (IGRAPH_REAL(eval1) > IGRAPH_REAL(eval2));
        } else if (options->which[1] == 'I') {
            /* eval1 must be the one with the smallest imaginary part */
            swap_evals = (IGRAPH_IMAG(eval1) > IGRAPH_IMAG(eval2));
        } else {
            IGRAPH_ERROR("ARPACK error", IGRAPH_ARPACK_WHICHINV);
        }
    } else if (options->which[0] == 'L') {
        if (options->which[1] == 'M') {
            /* eval1 must be the one with the largest magnitude */
            swap_evals = (igraph_complex_mod(eval1) < igraph_complex_mod(eval2));
        } else if (options->which[1] == 'R') {
            /* eval1 must be the one with the largest real part */
            swap_evals = (IGRAPH_REAL(eval1) < IGRAPH_REAL(eval2));
        } else if (options->which[1] == 'I') {
            /* eval1 must be the one with the largest imaginary part */
            swap_evals = (IGRAPH_IMAG(eval1) < IGRAPH_IMAG(eval2));
        } else {
            IGRAPH_ERROR("ARPACK error", IGRAPH_ARPACK_WHICHINV);
        }
    } else if (options->which[0] == 'X' && options->which[1] == 'X') {
        /* No preference on the ordering of eigenvectors */
    } else {
        /* fprintf(stderr, "%c%c\n", options->which[0], options->which[1]); */
        IGRAPH_ERROR("ARPACK error", IGRAPH_ARPACK_WHICHINV);
    }

    options->nconv = nev;

    if (swap_evals) {
        igraph_complex_t dummy;
        dummy = eval1; eval1 = eval2; eval2 = dummy;
        dummy = evec1[0]; evec1[0] = evec2[0]; evec2[0] = dummy;
        dummy = evec1[1]; evec1[1] = evec2[1]; evec2[1] = dummy;
    }

    if (complex_evals) {
        /* The eigenvalues are conjugate pairs, so we store only the
         * one with positive imaginary part */
        if (IGRAPH_IMAG(eval1) < 0) {
            eval1 = eval2;
            evec1[0] = evec2[0]; evec1[1] = evec2[1];
        }
    }

    if (values != 0) {
        IGRAPH_CHECK(igraph_matrix_resize(values, nev, 2));
        MATRIX(*values, 0, 0) = IGRAPH_REAL(eval1);
        MATRIX(*values, 0, 1) = IGRAPH_IMAG(eval1);
        if (nev > 1) {
            MATRIX(*values, 1, 0) = IGRAPH_REAL(eval2);
            MATRIX(*values, 1, 1) = IGRAPH_IMAG(eval2);
        }
    }

    if (vectors != 0) {
        if (complex_evals) {
            IGRAPH_CHECK(igraph_matrix_resize(vectors, 2, 2));
            MATRIX(*vectors, 0, 0) = IGRAPH_REAL(evec1[0]);
            MATRIX(*vectors, 1, 0) = IGRAPH_REAL(evec1[1]);
            MATRIX(*vectors, 0, 1) = IGRAPH_IMAG(evec1[0]);
            MATRIX(*vectors, 1, 1) = IGRAPH_IMAG(evec1[1]);
        } else {
            IGRAPH_CHECK(igraph_matrix_resize(vectors, 2, nev));
            MATRIX(*vectors, 0, 0) = IGRAPH_REAL(evec1[0]);
            MATRIX(*vectors, 1, 0) = IGRAPH_REAL(evec1[1]);
            if (nev > 1) {
                MATRIX(*vectors, 0, 1) = IGRAPH_REAL(evec2[0]);
                MATRIX(*vectors, 1, 1) = IGRAPH_REAL(evec2[1]);
            }
        }
    }

    return IGRAPH_SUCCESS;
}

/**
 * "Solver" for symmetric 2x2 eigenvalue problems since ARPACK sometimes blows
 * up with these.
 */
static int igraph_i_arpack_rssolve_2x2(igraph_arpack_function_t *fun, void *extra,
                                       igraph_arpack_options_t* options, igraph_vector_t* values,
                                       igraph_matrix_t* vectors) {
    igraph_real_t vec[2], mat[4];
    igraph_real_t a, b, c, d;
    igraph_real_t trace, det, tsq4_minus_d;
    igraph_real_t eval1, eval2;
    int nev = options->nev;

    if (nev <= 0) {
        IGRAPH_ERROR("ARPACK error", IGRAPH_ARPACK_NEVNPOS);
    }
    if (nev > 2) {
        nev = 2;
    }

    /* Probe the values in the matrix */
    vec[0] = 1; vec[1] = 0;
    if (fun(mat, vec, 2, extra)) {
        IGRAPH_ERROR("ARPACK error while evaluating matrix-vector product",
                     IGRAPH_ARPACK_PROD);
    }
    vec[0] = 0; vec[1] = 1;
    if (fun(mat + 2, vec, 2, extra)) {
        IGRAPH_ERROR("ARPACK error while evaluating matrix-vector product",
                     IGRAPH_ARPACK_PROD);
    }
    a = mat[0]; b = mat[2]; c = mat[1]; d = mat[3];

    /* Get the trace and the determinant */
    trace = a + d;
    det = a * d - b * c;
    tsq4_minus_d = trace * trace / 4 - det;

    if (tsq4_minus_d >= 0) {
        /* Both eigenvalues are real */
        eval1 = trace / 2 + sqrt(tsq4_minus_d);
        eval2 = trace / 2 - sqrt(tsq4_minus_d);
        if (c != 0) {
            mat[0] = eval1 - d; mat[2] = eval2 - d;
            mat[1] = c;       mat[3] = c;
        } else if (b != 0) {
            mat[0] = b;       mat[2] = b;
            mat[1] = eval1 - a; mat[3] = eval2 - a;
        } else {
            mat[0] = 1; mat[2] = 0;
            mat[1] = 0; mat[3] = 1;
        }
    } else {
        /* Both eigenvalues are complex. Should not happen with symmetric
         * matrices. */
        IGRAPH_ERROR("ARPACK error, 2x2 matrix is not symmetric", IGRAPH_EINVAL);
    }

    /* eval1 is always the larger eigenvalue. If we want the smaller
     * one, we have to swap eval1 with eval2 and also the columns of mat */
    if (options->which[0] == 'S') {
        trace = eval1; eval1 = eval2; eval2 = trace;
        trace = mat[0]; mat[0] = mat[2]; mat[2] = trace;
        trace = mat[1]; mat[1] = mat[3]; mat[3] = trace;
    } else if (options->which[0] == 'L' || options->which[0] == 'B') {
        /* Nothing to do here */
    } else if (options->which[0] == 'X' && options->which[1] == 'X') {
        /* No preference on the ordering of eigenvectors */
    } else {
        IGRAPH_ERROR("ARPACK error", IGRAPH_ARPACK_WHICHINV);
    }

    options->nconv = nev;

    if (values != 0) {
        IGRAPH_CHECK(igraph_vector_resize(values, nev));
        VECTOR(*values)[0] = eval1;
        if (nev > 1) {
            VECTOR(*values)[1] = eval2;
        }
    }

    if (vectors != 0) {
        IGRAPH_CHECK(igraph_matrix_resize(vectors, 2, nev));
        MATRIX(*vectors, 0, 0) = mat[0];
        MATRIX(*vectors, 1, 0) = mat[1];
        if (nev > 1) {
            MATRIX(*vectors, 0, 1) = mat[2];
            MATRIX(*vectors, 1, 1) = mat[3];
        }
    }

    return IGRAPH_SUCCESS;
}

int igraph_arpack_rssort(igraph_vector_t *values, igraph_matrix_t *vectors,
                         const igraph_arpack_options_t *options,
                         igraph_real_t *d, const igraph_real_t *v) {

    igraph_vector_t order;
    char sort[2];
    int apply = 1;
    unsigned int n = (unsigned int) options->n;
    int nconv = options->nconv;
    int nev = options->nev;
    unsigned int nans = (unsigned int) (nconv < nev ? nconv : nev);

#define which(a,b) (options->which[0]==a && options->which[1]==b)

    if (which('L', 'A')) {
        sort[0] = 'S'; sort[1] = 'A';
    } else if (which('S', 'A')) {
        sort[0] = 'L'; sort[1] = 'A';
    } else if (which('L', 'M')) {
        sort[0] = 'S'; sort[1] = 'M';
    } else if (which('S', 'M')) {
        sort[0] = 'L'; sort[1] = 'M';
    } else if (which('B', 'E')) {
        sort[0] = 'L'; sort[1] = 'A';
    }

    IGRAPH_CHECK(igraph_vector_init_seq(&order, 0, nconv - 1));
    IGRAPH_FINALLY(igraph_vector_destroy, &order);
#ifdef HAVE_GFORTRAN
    igraphdsortr_(sort, &apply, &nconv, d, VECTOR(order), /*which_len=*/ 2);
#else
    igraphdsortr_(sort, &apply, &nconv, d, VECTOR(order));
#endif

    /* BE is special */
    if (which('B', 'E')) {
        int w = 0, l1 = 0, l2 = nev - 1;
        igraph_vector_t order2, d2;
        IGRAPH_VECTOR_INIT_FINALLY(&order2, nev);
        IGRAPH_VECTOR_INIT_FINALLY(&d2, nev);
        while (l1 <= l2) {
            VECTOR(order2)[w] = VECTOR(order)[l1];
            VECTOR(d2)[w] = d[l1];
            w++; l1++;
            if (l1 <= l2) {
                VECTOR(order2)[w] = VECTOR(order)[l2];
                VECTOR(d2)[w] = d[l2];
                w++; l2--;
            }
        }
        igraph_vector_update(&order, &order2);
        igraph_vector_copy_to(&d2, d);
        igraph_vector_destroy(&order2);
        igraph_vector_destroy(&d2);
        IGRAPH_FINALLY_CLEAN(2);
    }

#undef which

    /* Copy values */
    if (values) {
        IGRAPH_CHECK(igraph_vector_resize(values, nans));
        memcpy(VECTOR(*values), d, sizeof(igraph_real_t) * nans);
    }

    /* Reorder vectors */
    if (vectors) {
        int i;
        IGRAPH_CHECK(igraph_matrix_resize(vectors, n, nans));
        for (i = 0; i < nans; i++) {
            unsigned int idx = (unsigned int) VECTOR(order)[i];
            const igraph_real_t *ptr = v + n * idx;
            memcpy(&MATRIX(*vectors, 0, i), ptr, sizeof(igraph_real_t) * n);
        }
    }

    igraph_vector_destroy(&order);
    IGRAPH_FINALLY_CLEAN(1);

    return 0;
}

int igraph_arpack_rnsort(igraph_matrix_t *values, igraph_matrix_t *vectors,
                         const igraph_arpack_options_t *options,
                         igraph_real_t *dr, igraph_real_t *di,
                         igraph_real_t *v) {

    igraph_vector_t order;
    char sort[2];
    int apply = 1, i;
    unsigned int n = (unsigned int) options->n;
    int nconv = options->nconv;
    int nev = options->nev;
    unsigned int nans = (unsigned int) (nconv < nev ? nconv : nev);

#define which(a,b) (options->which[0]==a && options->which[1]==b)

    if (which('L', 'M')) {
        sort[0] = 'S'; sort[1] = 'M';
    } else if (which('S', 'M')) {
        sort[0] = 'L'; sort[1] = 'M';
    } else if (which('L', 'R')) {
        sort[0] = 'S'; sort[1] = 'R';
    } else if (which('S', 'R')) {
        sort[0] = 'L'; sort[1] = 'R';
    } else if (which('L', 'I')) {
        sort[0] = 'S'; sort[1] = 'I';
    } else if (which('S', 'I')) {
        sort[0] = 'L'; sort[1] = 'I';
    }

#undef which

    IGRAPH_CHECK(igraph_vector_init_seq(&order, 0, nconv - 1));
    IGRAPH_FINALLY(igraph_vector_destroy, &order);
#ifdef HAVE_GFORTRAN
    igraphdsortc_(sort, &apply, &nconv, dr, di, VECTOR(order), /*which_len=*/ 2);
#else
    igraphdsortc_(sort, &apply, &nconv, dr, di, VECTOR(order));
#endif

    if (values) {
        IGRAPH_CHECK(igraph_matrix_resize(values, nans, 2));
        memcpy(&MATRIX(*values, 0, 0), dr, sizeof(igraph_real_t) * nans);
        memcpy(&MATRIX(*values, 0, 1), di, sizeof(igraph_real_t) * nans);
    }

    if (vectors) {
        int nc = 0, nr = 0, ncol, vx = 0;
        for (i = 0; i < nans; i++) {
            if (di[i] == 0) {
                nr++;
            } else {
                nc++;
            }
        }
        ncol = (nc / 2) * 2 + (nc % 2) * 2 + nr;
        IGRAPH_CHECK(igraph_matrix_resize(vectors, n, ncol));

        for (i = 0; i < nans; i++) {
            unsigned int idx;

            idx = (unsigned int) VECTOR(order)[i];

            if (di[i] == 0) {
                /* real eigenvalue, single eigenvector */
                memcpy(&MATRIX(*vectors, 0, vx), v + n * idx, sizeof(igraph_real_t) * n);
                vx++;
            } else if (di[i] > 0) {
                /* complex eigenvalue, positive imaginary part encountered first.
                 * ARPACK stores its eigenvector directly in two consecutive columns.
                 * The complex conjugate pair of the eigenvalue (if any) will be in
                 * the next column and we will skip it because we advance 'i' below */
                memcpy(&MATRIX(*vectors, 0, vx), v + n * idx, sizeof(igraph_real_t) * 2 * n);
                vx += 2;
                i++;
            } else {
                /* complex eigenvalue, negative imaginary part encountered first.
                     * The positive one will be the next one, but we need to copy the
                     * eigenvector corresponding to the eigenvalue with the positive
                     * imaginary part. */
                idx = (unsigned int) VECTOR(order)[i + 1];
                memcpy(&MATRIX(*vectors, 0, vx), v + n * idx, sizeof(igraph_real_t) * 2 * n);
                vx += 2;
                i++;
            }
        }
    }

    igraph_vector_destroy(&order);
    IGRAPH_FINALLY_CLEAN(1);

    if (values) {
        /* Strive to include complex conjugate eigenvalue pairs in a way that the
         * positive imaginary part comes first */
        for (i = 0; i < nans; i++) {
            if (MATRIX(*values, i, 1) == 0) {
                /* Real eigenvalue, nothing to do */
            } else if (MATRIX(*values, i, 1) < 0) {
                /* Negative imaginary part came first; negate the imaginary part for
                 * this eigenvalue and the next one (which is the complex conjugate
                 * pair), and skip it */
                MATRIX(*values, i, 1) *= -1;
                i++;
                if (i < nans) {
                    MATRIX(*values, i, 1) *= -1;
                }
            } else {
                /* Positive imaginary part; skip the next eigenvalue, which is the
                 * complex conjugate pair */
                i++;
            }
        }
    }

    return 0;
}

/**
 * \function igraph_i_arpack_auto_ncv
 * \brief Tries to set up the value of \c ncv in an \c igraph_arpack_options_t
 *        automagically.
 */
static void igraph_i_arpack_auto_ncv(igraph_arpack_options_t* options) {
    /* This is similar to how Octave determines the value of ncv, with some
     * modifications. */
    int min_ncv = options->nev * 2 + 1;

    /* Use twice the number of desired eigenvectors plus one by default */
    options->ncv = min_ncv;
    /* ...but use at least 20 Lanczos vectors... */
    if (options->ncv < 20) {
        options->ncv = 20;
    }
    /* ...but having ncv close to n leads to some problems with small graphs
     * (example: PageRank of "A <--> C, D <--> E, B"), so we don't let it
     * to be larger than n / 2...
     */
    if (options->ncv > options->n / 2) {
        options->ncv = options->n / 2;
    }
    /* ...but we need at least min_ncv. */
    if (options->ncv < min_ncv) {
        options->ncv = min_ncv;
    }
    /* ...but at most n */
    if (options->ncv > options->n) {
        options->ncv = options->n;
    }
}

/**
 * \function igraph_i_arpack_report_no_convergence
 * \brief Prints a warning that informs the user that the ARPACK solver
 *        did not converge.
 */
static void igraph_i_arpack_report_no_convergence(const igraph_arpack_options_t* options) {
    char buf[1024];
    snprintf(buf, sizeof(buf), "ARPACK solver failed to converge (%d iterations, "
             "%d/%d eigenvectors converged)", options->iparam[2],
             options->iparam[4], options->nev);
    IGRAPH_WARNING(buf);
}

/**
 * \function igraph_arpack_rssolve
 * \brief ARPACK solver for symmetric matrices
 *
 * This is the ARPACK solver for symmetric matrices. Please use
 * \ref igraph_arpack_rnsolve() for non-symmetric matrices.
 * \param fun Pointer to an \ref igraph_arpack_function_t object,
 *     the function that performs the matrix-vector multiplication.
 * \param extra An extra argument to be passed to \c fun.
 * \param options An \ref igraph_arpack_options_t object.
 * \param storage An \ref igraph_arpack_storage_t object, or a null
 *     pointer. In the latter case memory allocation and deallocation
 *     is performed automatically. Either this or the \p vectors argument
 *     must be non-null if the ARPACK iteration is started from a
 *     given starting vector. If both are given \p vectors take
 *     precedence.
 * \param values If not a null pointer, then it should be a pointer to an
 *     initialized vector. The eigenvalues will be stored here. The
 *     vector will be resized as needed.
 * \param vectors If not a null pointer, then it must be a pointer to
 *     an initialized matrix. The eigenvectors will be stored in the
 *     columns of the matrix. The matrix will be resized as needed.
 *     Either this or the \p vectors argument must be non-null if the
 *     ARPACK iteration is started from a given starting vector. If
 *     both are given \p vectors take precedence.
 * \return Error code.
 *
 * Time complexity: depends on the matrix-vector
 * multiplication. Usually a small number of iterations is enough, so
 * if the matrix is sparse and the matrix-vector multiplication can be
 * done in O(n) time (the number of vertices), then the eigenvalues
 * are found in O(n) time as well.
 */

int igraph_arpack_rssolve(igraph_arpack_function_t *fun, void *extra,
                          igraph_arpack_options_t *options,
                          igraph_arpack_storage_t *storage,
                          igraph_vector_t *values, igraph_matrix_t *vectors) {

    igraph_real_t *v, *workl, *workd, *d, *resid, *ax;
    igraph_bool_t free_them = 0;
    int *select, i;

    int ido = 0;
    int rvec = vectors || storage ? 1 : 0; /* calculate eigenvectors? */
    char *all = "All";

    int origldv = options->ldv, origlworkl = options->lworkl,
        orignev = options->nev, origncv = options->ncv;
    char origwhich[2] = { options->which[0], options->which[1] };
    igraph_real_t origtol = options->tol;

    /* Special case for 1x1 and 2x2 matrices in mode 1 */
    if (options->mode == 1 && options->n == 1) {
        return igraph_i_arpack_rssolve_1x1(fun, extra, options, values, vectors);
    } else if (options->mode == 1 && options->n == 2) {
        return igraph_i_arpack_rssolve_2x2(fun, extra, options, values, vectors);
    }

    /* Brush up options if needed */
    if (options->ldv == 0) {
        options->ldv = options->n;
    }
    if (options->ncv == 0) {
        igraph_i_arpack_auto_ncv(options);
    }
    if (options->lworkl == 0) {
        options->lworkl = options->ncv * (options->ncv + 8);
    }
    if (options->which[0] == 'X') {
        options->which[0] = 'L';
        options->which[1] = 'M';
    }

    if (storage) {
        /* Storage provided */
        if (storage->maxn < options->n) {
            IGRAPH_ERROR("Not enough storage for ARPACK (`n')", IGRAPH_EINVAL);
        }
        if (storage->maxncv < options->ncv) {
            IGRAPH_ERROR("Not enough storage for ARPACK (`ncv')", IGRAPH_EINVAL);
        }
        if (storage->maxldv < options->ldv) {
            IGRAPH_ERROR("Not enough storage for ARPACK (`ldv')", IGRAPH_EINVAL);
        }

        v      = storage->v;
        workl  = storage->workl;
        workd  = storage->workd;
        d      = storage->d;
        resid  = storage->resid;
        ax     = storage->ax;
        select = storage->select;

    } else {
        /* Storage not provided */
        free_them = 1;

#define CHECKMEM(x) \
    if (!x) { \
        IGRAPH_ERROR("Cannot allocate memory for ARPACK", IGRAPH_ENOMEM); \
    } \
    IGRAPH_FINALLY(igraph_free, x);

        v = igraph_Calloc(options->ldv * options->ncv, igraph_real_t); CHECKMEM(v);
        workl = igraph_Calloc(options->lworkl, igraph_real_t); CHECKMEM(workl);
        workd = igraph_Calloc(3 * options->n, igraph_real_t); CHECKMEM(workd);
        d = igraph_Calloc(2 * options->ncv, igraph_real_t); CHECKMEM(d);
        resid = igraph_Calloc(options->n, igraph_real_t); CHECKMEM(resid);
        ax = igraph_Calloc(options->n, igraph_real_t); CHECKMEM(ax);
        select = igraph_Calloc(options->ncv, int); CHECKMEM(select);

#undef CHECKMEM

    }

    /* Set final bits */
    options->bmat[0] = 'I';
    options->iparam[0] = options->ishift;
    options->iparam[1] = 0;   // not referenced
    options->iparam[2] = options->mxiter;
    options->iparam[3] = 1;   // currently dsaupd() works only for nb=1
    options->iparam[4] = 0;
    options->iparam[5] = 0;   // not referenced
    options->iparam[6] = options->mode;
    options->iparam[7] = 0;   // return value
    options->iparam[8] = 0;   // return value
    options->iparam[9] = 0;   // return value
    options->iparam[10] = 0;  // return value
    options->info = options->start;
    if (options->start) {
        if (!storage && !vectors) {
            IGRAPH_ERROR("Starting vector not given", IGRAPH_EINVAL);
        }
        if (vectors && (igraph_matrix_nrow(vectors) != options->n ||
                        igraph_matrix_ncol(vectors) != 1)) {
            IGRAPH_ERROR("Invalid starting vector size", IGRAPH_EINVAL);
        }
        if (vectors) {
            for (i = 0; i < options->n; i++) {
                resid[i] = MATRIX(*vectors, i, 0);
            }
        }
    }

    /* Ok, we have everything */
    while (1) {
#ifdef HAVE_GFORTRAN
        igraphdsaupd_(&ido, options->bmat, &options->n, options->which,
                      &options->nev, &options->tol,
                      resid, &options->ncv, v, &options->ldv,
                      options->iparam, options->ipntr,
                      workd, workl, &options->lworkl, &options->info,
                      /*bmat_len=*/ 1, /*which_len=*/ 2);
#else
        igraphdsaupd_(&ido, options->bmat, &options->n, options->which,
                      &options->nev, &options->tol,
                      resid, &options->ncv, v, &options->ldv,
                      options->iparam, options->ipntr,
                      workd, workl, &options->lworkl, &options->info);
#endif

        if (ido == -1 || ido == 1) {
            igraph_real_t *from = workd + options->ipntr[0] - 1;
            igraph_real_t *to = workd + options->ipntr[1] - 1;
            if (fun(to, from, options->n, extra) != 0) {
                IGRAPH_ERROR("ARPACK error while evaluating matrix-vector product",
                             IGRAPH_ARPACK_PROD);
            }

        } else {
            break;
        }
    }

    if (options->info == 1) {
        igraph_i_arpack_report_no_convergence(options);
    }
    if (options->info != 0) {
        IGRAPH_ERROR("ARPACK error", igraph_i_arpack_err_dsaupd(options->info));
    }

    options->ierr = 0;
#ifdef HAVE_GFORTRAN
    igraphdseupd_(&rvec, all, select, d, v, &options->ldv,
                  &options->sigma, options->bmat, &options->n,
                  options->which, &options->nev, &options->tol,
                  resid, &options->ncv, v, &options->ldv, options->iparam,
                  options->ipntr, workd, workl, &options->lworkl,
                  &options->ierr, /*howmny_len=*/ 1, /*bmat_len=*/ 1,
                  /*which_len=*/ 2);
#else
    igraphdseupd_(&rvec, all, select, d, v, &options->ldv,
                  &options->sigma, options->bmat, &options->n,
                  options->which, &options->nev, &options->tol,
                  resid, &options->ncv, v, &options->ldv, options->iparam,
                  options->ipntr, workd, workl, &options->lworkl,
                  &options->ierr);
#endif

    if (options->ierr != 0) {
        IGRAPH_ERROR("ARPACK error", igraph_i_arpack_err_dseupd(options->ierr));
    }

    /* Save the result */

    options->noiter = options->iparam[2];
    options->nconv = options->iparam[4];
    options->numop = options->iparam[8];
    options->numopb = options->iparam[9];
    options->numreo = options->iparam[10];

    if (options->nconv < options->nev) {
        IGRAPH_WARNING("Not enough eigenvalues/vectors in symmetric ARPACK "
                       "solver");
    }

    if (values || vectors) {
        IGRAPH_CHECK(igraph_arpack_rssort(values, vectors, options, d, v));
    }

    options->ldv = origldv;
    options->ncv = origncv;
    options->lworkl = origlworkl;
    options->which[0] = origwhich[0]; options->which[1] = origwhich[1];
    options->tol = origtol;
    options->nev = orignev;

    /* Clean up if needed */
    if (free_them) {
        igraph_Free(select);
        igraph_Free(ax);
        igraph_Free(resid);
        igraph_Free(d);
        igraph_Free(workd);
        igraph_Free(workl);
        igraph_Free(v);
        IGRAPH_FINALLY_CLEAN(7);
    }
    return 0;
}

/**
 * \function igraph_arpack_rnsolve
 * \brief ARPACK solver for non-symmetric matrices
 *
 * Please always consider calling \ref igraph_arpack_rssolve() if your
 * matrix is symmetric, it is much faster.
 * \ref igraph_arpack_rnsolve() for non-symmetric matrices.
 * </para><para>
 * Note that ARPACK is not called for 2x2 matrices as an exact algebraic
 * solution exists in these cases.
 *
 * \param fun Pointer to an \ref igraph_arpack_function_t object,
 *     the function that performs the matrix-vector multiplication.
 * \param extra An extra argument to be passed to \c fun.
 * \param options An \ref igraph_arpack_options_t object.
 * \param storage An \ref igraph_arpack_storage_t object, or a null
 *     pointer. In the latter case memory allocation and deallocation
 *     is performed automatically.
 * \param values If not a null pointer, then it should be a pointer to an
 *     initialized matrix. The (possibly complex) eigenvalues will be
 *     stored here. The matrix will have two columns, the first column
 *     contains the real, the second the imaginary parts of the
 *     eigenvalues.
 *     The matrix will be resized as needed.
 * \param vectors If not a null pointer, then it must be a pointer to
 *     an initialized matrix. The eigenvectors will be stored in the
 *     columns of the matrix. The matrix will be resized as needed.
 *     Note that real eigenvalues will have real eigenvectors in a single
 *     column in this matrix; however, complex eigenvalues come in conjugate
 *     pairs and the result matrix will store the eigenvector corresponding to
 *     the eigenvalue with \em positive imaginary part only. Since in this case
 *     the eigenvector is also complex, it will occupy \em two columns in the
 *     eigenvector matrix (the real and the imaginary parts, in this order).
 *     Caveat: if the eigenvalue vector returns only the eigenvalue with the
 *     \em negative imaginary part for a complex conjugate eigenvalue pair, the
 *     result vector will \em still store the eigenvector corresponding to the
 *     eigenvalue with the positive imaginary part (since this is how ARPACK
 *     works).
 * \return Error code.
 *
 * Time complexity: depends on the matrix-vector
 * multiplication. Usually a small number of iterations is enough, so
 * if the matrix is sparse and the matrix-vector multiplication can be
 * done in O(n) time (the number of vertices), then the eigenvalues
 * are found in O(n) time as well.
 */

int igraph_arpack_rnsolve(igraph_arpack_function_t *fun, void *extra,
                          igraph_arpack_options_t *options,
                          igraph_arpack_storage_t *storage,
                          igraph_matrix_t *values, igraph_matrix_t *vectors) {

    igraph_real_t *v, *workl, *workd, *dr, *di, *resid, *workev;
    igraph_bool_t free_them = 0;
    int *select, i;

    int ido = 0;
    int rvec = vectors || storage ? 1 : 0;
    char *all = "All";

    int origldv = options->ldv, origlworkl = options->lworkl,
        orignev = options->nev, origncv = options->ncv;
    char origwhich[2] = { options->which[0], options->which[1] };
    igraph_real_t origtol = options->tol;
    int d_size;

    /* Special case for 1x1 and 2x2 matrices in mode 1 */
    if (options->mode == 1 && options->n == 1) {
        return igraph_i_arpack_rnsolve_1x1(fun, extra, options, values, vectors);
    } else if (options->mode == 1 && options->n == 2) {
        return igraph_i_arpack_rnsolve_2x2(fun, extra, options, values, vectors);
    }

    /* Brush up options if needed */
    if (options->ldv == 0) {
        options->ldv = options->n;
    }
    if (options->ncv == 0) {
        igraph_i_arpack_auto_ncv(options);
    }
    if (options->lworkl == 0) {
        options->lworkl = 3 * options->ncv * (options->ncv + 2);
    }
    if (options->which[0] == 'X') {
        options->which[0] = 'L';
        options->which[1] = 'M';
    }

    if (storage) {
        /* Storage provided */
        if (storage->maxn < options->n) {
            IGRAPH_ERROR("Not enough storage for ARPACK (`n')", IGRAPH_EINVAL);
        }
        if (storage->maxncv < options->ncv) {
            IGRAPH_ERROR("Not enough storage for ARPACK (`ncv')", IGRAPH_EINVAL);
        }
        if (storage->maxldv < options->ldv) {
            IGRAPH_ERROR("Not enough storage for ARPACK (`ldv')", IGRAPH_EINVAL);
        }

        v      = storage->v;
        workl  = storage->workl;
        workd  = storage->workd;
        workev = storage->workev;
        dr     = storage->d;
        di     = storage->di;
        d_size = options->n;
        resid  = storage->resid;
        select = storage->select;

    } else {
        /* Storage not provided */
        free_them = 1;

#define CHECKMEM(x) \
    if (!x) { \
        IGRAPH_ERROR("Cannot allocate memory for ARPACK", IGRAPH_ENOMEM); \
    } \
    IGRAPH_FINALLY(igraph_free, x);

        v = igraph_Calloc(options->n * options->ncv, igraph_real_t); CHECKMEM(v);
        workl = igraph_Calloc(options->lworkl, igraph_real_t); CHECKMEM(workl);
        workd = igraph_Calloc(3 * options->n, igraph_real_t); CHECKMEM(workd);
        d_size = 2 * options->nev + 1 > options->ncv ? 2 * options->nev + 1 : options->ncv;
        dr = igraph_Calloc(d_size, igraph_real_t); CHECKMEM(dr);
        di = igraph_Calloc(d_size, igraph_real_t); CHECKMEM(di);
        resid = igraph_Calloc(options->n, igraph_real_t); CHECKMEM(resid);
        select = igraph_Calloc(options->ncv, int); CHECKMEM(select);
        workev = igraph_Calloc(3 * options->ncv, igraph_real_t); CHECKMEM(workev);

#undef CHECKMEM

    }

    /* Set final bits */
    options->bmat[0] = 'I';
    options->iparam[0] = options->ishift;
    options->iparam[1] = 0;   // not referenced
    options->iparam[2] = options->mxiter;
    options->iparam[3] = 1;   // currently dnaupd() works only for nb=1
    options->iparam[4] = 0;
    options->iparam[5] = 0;   // not referenced
    options->iparam[6] = options->mode;
    options->iparam[7] = 0;   // return value
    options->iparam[8] = 0;   // return value
    options->iparam[9] = 0;   // return value
    options->iparam[10] = 0;  // return value
    options->info = options->start;
    if (options->start) {
        if (igraph_matrix_nrow(vectors) != options->n || igraph_matrix_ncol(vectors) != 1) {
            IGRAPH_ERROR("Invalid starting vector size", IGRAPH_EINVAL);
        }
        for (i = 0; i < options->n; i++) {
            resid[i] = MATRIX(*vectors, i, 0);
        }
    }

    /* Ok, we have everything */
    while (1) {
#ifdef HAVE_GFORTRAN
        igraphdnaupd_(&ido, options->bmat, &options->n, options->which,
                      &options->nev, &options->tol,
                      resid, &options->ncv, v, &options->ldv,
                      options->iparam, options->ipntr,
                      workd, workl, &options->lworkl, &options->info,
                      /*bmat_len=*/ 1, /*which_len=*/ 2);
#else
        igraphdnaupd_(&ido, options->bmat, &options->n, options->which,
                      &options->nev, &options->tol,
                      resid, &options->ncv, v, &options->ldv,
                      options->iparam, options->ipntr,
                      workd, workl, &options->lworkl, &options->info);
#endif

        if (ido == -1 || ido == 1) {
            igraph_real_t *from = workd + options->ipntr[0] - 1;
            igraph_real_t *to = workd + options->ipntr[1] - 1;
            if (fun(to, from, options->n, extra) != 0) {
                IGRAPH_ERROR("ARPACK error while evaluating matrix-vector product",
                             IGRAPH_ARPACK_PROD);
            }
        } else {
            break;
        }
    }

    if (options->info == 1) {
        igraph_i_arpack_report_no_convergence(options);
    }
    if (options->info != 0 && options->info != -9999) {
        IGRAPH_ERROR("ARPACK error", igraph_i_arpack_err_dnaupd(options->info));
    }

    options->ierr = 0;
#ifdef HAVE_GFORTRAN
    igraphdneupd_(&rvec, all, select, dr, di, v, &options->ldv,
                  &options->sigma, &options->sigmai, workev, options->bmat,
                  &options->n, options->which, &options->nev, &options->tol,
                  resid, &options->ncv, v, &options->ldv, options->iparam,
                  options->ipntr, workd, workl, &options->lworkl,
                  &options->ierr, /*howmny_len=*/ 1, /*bmat_len=*/ 1,
                  /*which_len=*/ 2);
#else
    igraphdneupd_(&rvec, all, select, dr, di, v, &options->ldv,
                  &options->sigma, &options->sigmai, workev, options->bmat,
                  &options->n, options->which, &options->nev, &options->tol,
                  resid, &options->ncv, v, &options->ldv, options->iparam,
                  options->ipntr, workd, workl, &options->lworkl,
                  &options->ierr);
#endif

    if (options->ierr != 0) {
        IGRAPH_ERROR("ARPACK error", igraph_i_arpack_err_dneupd(options->info));
    }

    /* Save the result */

    options->noiter = options->iparam[2];
    options->nconv = options->iparam[4];
    options->numop = options->iparam[8];
    options->numopb = options->iparam[9];
    options->numreo = options->iparam[10];

    if (options->nconv < options->nev) {
        IGRAPH_WARNING("Not enough eigenvalues/vectors in ARPACK "
                       "solver");
    }

    /* ARPACK might modify stuff in 'options' so reset everything that could
     * potentially get modified */
    options->ldv = origldv;
    options->ncv = origncv;
    options->lworkl = origlworkl;
    options->which[0] = origwhich[0]; options->which[1] = origwhich[1];
    options->tol = origtol;
    options->nev = orignev;

    if (values || vectors) {
        IGRAPH_CHECK(igraph_arpack_rnsort(values, vectors, options,
                                          dr, di, v));
    }

    /* Clean up if needed */
    if (free_them) {
        igraph_Free(workev);
        igraph_Free(select);
        igraph_Free(resid);
        igraph_Free(di);
        igraph_Free(dr);
        igraph_Free(workd);
        igraph_Free(workl);
        igraph_Free(v);
        IGRAPH_FINALLY_CLEAN(8);
    }
    return 0;
}

/**
 * \function igraph_arpack_unpack_complex
 * \brief Make the result of the non-symmetric ARPACK solver more readable
 *
 * This function works on the output of \ref igraph_arpack_rnsolve and
 * brushes it up a bit: it only keeps \p nev eigenvalues/vectors and
 * every eigenvector is stored in two columns of the \p vectors
 * matrix.
 *
 * </para><para>
 * The output of the non-symmetric ARPACK solver is somewhat hard to
 * parse, as real eigenvectors occupy only one column in the matrix,
 * and the complex conjugate eigenvectors are not stored at all
 * (usually). The other problem is that the solver might return more
 * eigenvalues than requested. The common use of this function is to
 * call it directly after \ref igraph_arpack_rnsolve with its \p
 * vectors and \p values argument and \c options->nev as \p nev.
 * \param vectors The eigenvector matrix, as returned by \ref
 *   igraph_arpack_rnsolve. It will be resized, typically it will be
 *   larger.
 * \param values The eigenvalue matrix, as returned by \ref
 *   igraph_arpack_rnsolve. It will be resized, typically extra,
 *   unneeded rows (=eigenvalues) will be removed.
 * \param nev The number of eigenvalues/vectors to keep. Can be less
 *   or equal than the number originally requested from ARPACK.
 * \return Error code.
 *
 * Time complexity: linear in the number of elements in the \p vectors
 * matrix.
 */

int igraph_arpack_unpack_complex(igraph_matrix_t *vectors, igraph_matrix_t *values,
                                 long int nev) {

    long int nodes = igraph_matrix_nrow(vectors);
    long int no_evs = igraph_matrix_nrow(values);
    long int i, j, k, wh;
    size_t colsize = (unsigned) nodes * sizeof(igraph_real_t);

    /* Error checks */
    if (nev < 0) {
        IGRAPH_ERROR("`nev' cannot be negative", IGRAPH_EINVAL);
    }
    if (nev > no_evs) {
        IGRAPH_ERROR("`nev' too large, we don't have that many in `values'",
                     IGRAPH_EINVAL);
    }

    IGRAPH_CHECK(igraph_matrix_resize(vectors, nodes, nev * 2));
    for (i = nev; i < igraph_matrix_nrow(values); i++) {
        IGRAPH_CHECK(igraph_matrix_remove_row(values, i));
    }

    /* Calculate where to start copying */
    for (i = 0, j = 0, wh = 0; i < nev; i++) {
        if (MATRIX(*values, i, 1) == 0) { /* TODO: == 0.0 ???? */
            /* real */
            j++;
        } else {
            /* complex */
            if (wh == 0) {
                j += 2;
                wh = 1 - wh;
            }
        }
    }
    j--;

    /* if (j>=origcol) { */
    /*   IGRAPH_WARNING("Too few columns in `vectors', ARPACK results are likely wrong"); */
    /* } */

    /* We copy the j-th eigenvector to the (k-1)-th and k-th column */
    k = nev * 2 - 1;

    for (i = nev - 1; i >= 0; i--) {
        if (MATRIX(*values, i, 1) == 0) {

            /* real */
            memset( &MATRIX(*vectors, 0, k), 0, colsize);
            if (k - 1 != j) {
                memcpy( &MATRIX(*vectors, 0, k - 1), &MATRIX(*vectors, 0, j), colsize);
            }
            k -= 2;
            j -= 1;
        } else {
            /* complex */
            if (k != j) {
                /* Separate copy required, otherwise 'from' and 'to' might
                   overlap */
                memcpy( &MATRIX(*vectors, 0, k), &MATRIX(*vectors, 0, j), colsize);
                memcpy( &MATRIX(*vectors, 0, k - 1), &MATRIX(*vectors, 0, j - 1), colsize);
            }
            if (i > 1 && MATRIX(*values, i, 1) != -MATRIX(*values, i - 1, 1)) {
                /* The next one is not a conjugate of this one */
                j -= 2;
            } else {
                /* Conjugate */
                int l;
                for (l = 0; l < nodes; l++) {
                    MATRIX(*vectors, l, k) = - MATRIX(*vectors, l, k);
                }
            }
            k -= 2;
        }
    }

    return 0;
}
