#include <ACTIONet.h>

namespace ACTIONet {	
    arma::mat get_Q(double alpha, arma::vec& ds_inv, arma::sp_mat& adj_mat) {
        arma::sp_mat I = arma::speye(arma::size(adj_mat));
        arma::mat dn_sqrt_mat = arma::diagmat(ds_inv);

        return .5 * ((1 + alpha) * I - (1 - alpha) * (dn_sqrt_mat * adj_mat * dn_sqrt_mat));
    }

    arma::vec get_gradient(double alpha, arma::vec& q, arma::vec& ds_inv, arma::vec& prob_dist, arma::mat& Q) {
        return Q * q - alpha * ds_inv % prob_dist;
    }

    arma::vec proximal_step(double alpha, double rho, arma::vec& q, arma::vec& gradient, arma::vec& ds) {
        arma::vec y = q - gradient;
        return arma::sign(y) % arma::max(arma::abs(y) - alpha * rho * ds, arma::zeros<arma::vec>(y.n_elem));
    }

    bool is_converge(double epsilon, arma::vec& next_q, arma::vec& q) {
        return arma::norm(next_q - q, 2) < epsilon;
    }
    
    arma::vec diffusion_solve_FISTA(arma::sp_mat& adj_mat, arma::vec& prob_dist, double alpha = 0.15, double rho = 1e-4, double epsilon = 0.001, int max_iter = 20) {
        double beta = (1 - sqrt(alpha)) / (1 + sqrt(alpha));
        
        arma::vec d = arma::vec(arma::sum(adj_mat, 1));
        arma::vec ds = arma::sqrt(d);
        
        arma::vec ds_inv = 1 / ds;
		ds_inv(ds == 0).ones();
		
		
        arma::mat Q = get_Q(alpha, ds_inv, adj_mat);

        arma::vec q, y;
        q = y = arma::zeros<arma::vec>(d.n_elem);



        while (max_iter-- > 0) {
            arma::vec gradient = get_gradient(alpha, y, ds_inv, prob_dist, Q);
            arma::vec next_q = proximal_step(alpha, rho, y, gradient, ds);
            y = next_q + beta * (next_q - q);
            if (is_converge(epsilon, next_q, q)) break;
            q = next_q;
        }
        return q % ds;
    }    
}
