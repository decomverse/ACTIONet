#' @export
plot.ACTIONetExperiment <- function(ace, ...) {
  x <- list(...)
  args <- c(list(ace = quote(ace)), x)

  if ("interactive" %in% names(x)) {
    if (x[["interactive"]] == T) {
      idx <- which(names(x) == "interactive")
      x <- x[-idx]
      args <- c(list(ace = quote(ace)), x)
      p_out <- do.call(plot.ACTIONet.interactive, args)
    }
  } else {
    if (length(x) == 0) {
      p_out <- plot.ACTIONet(ace)
    } else if ("gradient_attr" %in% names(x)) {
      p_out <- do.call(plot.ACTIONet.gradient, as.list(args))
    } else if ("labels_attr" %in% names(x)) {
      p_out <- do.call(plot.ACTIONet, as.list(args))
    } else if ((length(unique(x[[1]])) > 50) & (is.numeric(x[[1]]))) {
      p_out <- do.call(plot.ACTIONet.gradient, as.list(args))
    } else if (sum(unlist(x[[1]]) %in% rownames(ace)) > length(x[[1]]) / 2) {
      genes <- sort(unique(unlist(x[[1]])))
      p_out <- visualize.markers(ace, genes)
    } else {
      p_out <- do.call(plot.ACTIONet, args)
    }
  }

  return(p_out)
}

#' Plot ACTIONet scatter plot
#'
#' @param data 'ACTIONetExperiment' object or two-column numeric matrix of X-Y coordinates.
#' @param label_attr Character vector of length NROW(ace) or colname of 'colData(ace)' containing cell labels of interest (clusters, celltypes, etc.).
#' @param color_attr Character vector of length NROW(ace) or colname of 'colData(ace)' containing hex colors to use for each point, or matrix/data.frame containing RGB values to pass to grDevices::rgb().
#' @param trans_attr Numeric vector of length NROW(ace) or colname of 'colData(ace)' used to compute point transparency. Smaller values are more transparent.
#' @param trans_fac Transparency modifier (default:1.5).
#' @param trans_th Minimum Z-score for which points with 'scale(trans_attr) < trans_th' are masked  (default:-0.5).
#' @param point_size Size of points in ggplot (default:1).
#' @param stroke_size Size of points outline (stroke) in ggplot (default:point_size*0.1).
#' @param stroke_contrast_fac Factor by which to darken point outline for contrast (default:0.1).
#' @param palette Color palette. character vector of hex colors or a palette name to pass to 'ggpubr::get_palette()').
#' @param add_text_labels Whether or not to add floating text labels on the top of annotated clusters. Ignored if 'label_attr=NULL'. (default:'TRUE').
#' @param text_size Size of floating text. Passed to 'ggplot2::geom_label()' (default:3).
#' @param nudge_text_labels Slightly offset labels proportional to cluster size so as to not cover small clusters (default:'TRUE').
#' @param show_legend Show legend based on labels. Ignored if 'label_attr=NULL' or 'color_attr!=NULL' (default:'FALSE').
#' @param coordinate_attr Name of entry in colMaps(ace) containing the 2D plot coordinates if 'data' is an 'ACTIONetExperiment' object (default:'ACTIONet2D').
#' @param color_slot Name of entry in colMaps(ace) containing RGB values for default point colors generated by 'layout_ACTIONet()'. Used only if no other coloring parameters are given or valid (default:'denovo_color').
#' @param point_order Integer vector specifying order in which to plot individual points (default:'NULL').
#' @param use_repel Use ggrepel to distribute cluster labels. Known to be buggy if used with RStudio (default:'TRUE').
#' @param repel_force Numeric to pass as 'force' parameter to 'geom_label_repel()' when 'use_repel=TRUE'. (default:0.05)
#'
#' @return 'ggplot' object.
#'
#' @examples
#' plot.ACTIONet(ace, ace$assigned_archetype)
#' @import ggplot2
#' @export
plot.ACTIONet <- function(ace,
                          label_attr = NULL,
                          color_attr = NULL,
                          trans_attr = NULL,
                          trans_fac = 1.5,
                          trans_th = -0.5,
                          point_size = 1,
                          stroke_size = point_size * 0.1,
                          stroke_contrast_fac = 0.1,
                          palette = CPal_default,
                          add_text_labels = TRUE,
                          text_size = 3,
                          nudge_text_labels = FALSE,
                          show_legend = FALSE,
                          coordinate_attr = "ACTIONet2D",
                          color_slot = "denovo_color",
                          point_order = NULL,
                          use_repel = TRUE,
                          repel_force = 0.05) {
  plot_coors <- .get_plot_coors(ace, coordinate_attr)
  plot_labels <- .get_plot_labels(label_attr, ace)
  plot_fill_col <- .get_plot_colors(color_attr, plot_labels, ace, color_slot, palette)
  plot_alpha <- .get_plot_transparency(trans_attr, ace, trans_fac, trans_th, TRUE)
  plot_border_col <- colorspace::darken(plot_fill_col, stroke_contrast_fac)

  if (is.null(plot_labels)) {
    data_labels <- "NA"
    add_text_labels <- FALSE
    show_legend <- FALSE
    legend_labels <- NULL
    legend_fill_colors <- NULL
  } else {
    data_labels <- plot_labels
    names(plot_fill_col) <- plot_labels
    legend_labels <- sort(unique(plot_labels))
    legend_fill_colors <- plot_fill_col[legend_labels]
  }

  if (!is.null(color_attr)) {
    show_legend <- FALSE
    legend_fill_colors <- NULL
  }

  plot_data <- data.frame(plot_coors,
    labels = data_labels,
    fill = plot_fill_col,
    color = plot_border_col,
    trans = plot_alpha,
    idx = 1:NROW(plot_coors)
  )

  if (is.null(point_order)) {
    pidx <- sample(NROW(plot_data))
  } else {
    pidx <- point_order
  }

  plot_data <- plot_data[pidx, ]

  p_out <- ggplot() +
    geom_point(
      data = plot_data,
      mapping = aes(
        x = x,
        y = y,
        color = color,
        fill = fill,
        alpha = trans
      ),
      shape = 21,
      size = point_size,
      stroke = stroke_size,
      show.legend = show_legend
    ) +
    scale_fill_identity(
      guide = "legend",
      labels = legend_labels,
      breaks = legend_fill_colors
    ) +
    scale_color_identity() +
    scale_alpha_identity() +
    .default_ggtheme

  if (!is.null(plot_labels) && add_text_labels == TRUE) {
    text_layer <- .layout_plot_labels(
      plot_data = plot_data,
      label_names = legend_labels,
      label_colors = legend_fill_colors,
      darken = TRUE,
      alpha_val = 0.5,
      text_size = text_size,
      constrast_fac = 0.5,
      nudge = nudge_text_labels,
      use_repel = use_repel,
      repel_force = repel_force
    )
    p_out <- p_out + text_layer
  }

  p_out
}

#' Main ACTIONet 3D plotting functions
#'
#' @param ace ACTIONet output object
#' @param labels Annotation of interest (clusters, celltypes, etc.) to be projected on the ACTIONet plot
#' @param trans_attr Additional continuous attribute to project onto the transparency of nodes
#' @param trans_th, trans_fac Control the effect of transparency mapping
#' @param point_size Size of nodes in the ACTIONet plot
#' @param palette Color palette (named vector or a name for a given known palette)
#' @param title Main title of the plot
#' @param coordinate_slot Entry in colMaps(ace) containing the plot coordinates (default:'ACTIONet2D')
#'
#' @return Visualized ACTIONet
#'
#' @examples
#' ace <- run.ACTIONet(sce)
#' plot.ACTIONet.3D(ace, ace$assigned_archetype, trans_attr = ace$node_centrality)
#' @export
plot.ACTIONet.3D <- function(ace,
                             labels = NULL,
                             trans_attr = NULL,
                             trans_th = -1,
                             trans_fac = 1,
                             point_size = 1,
                             palette = CPal_default,
                             coordinate_slot = "ACTIONet3D") {
  nV <- length(ncol(ace))

  point_size <- point_size * 0.2

  if (class(ace) == "ACTIONetExperiment") {
    labels <- .preprocess_annotation_labels(labels, ace)
    if (is.character(coordinate_slot)) {
      coors <- as.matrix(colMaps(ace)[[coordinate_slot]])
      coor.mu <- apply(coors, 2, mean)
      coor.sigma <- apply(coors, 2, sd)
      coors <- scale(coors)
    } else {
      coors <- as.matrix(coordinate_slot)
      coor.mu <- apply(coors, 2, mean)
      coor.sigma <- apply(coors, 2, sd)
      coors <- scale(coors)
    }
  } else {
    if (is.matrix(ace) | ACTIONetExperiment:::is.sparseMatrix(ace)) {
      coors <- as.matrix(ace)
      coor.mu <- apply(coors, 2, mean)
      coor.sigma <- apply(coors, 2, sd)
      coors <- scale(coors)
      labels <- .preprocess_annotation_labels(labels)
    } else {
      err <- sprintf("Unknown type for object 'ace'.\n")
      stop(err)
    }
  }

  if (is.null(labels)) {
    if (class(ace) == "ACTIONetExperiment") {
      vCol <- grDevices::rgb(colMaps(ace)$denovo_color)
    } else {
      vCol <- rep("tomato", nrow(coors))
    }
    Annot <- NULL
  } else {
    Annot <- names(labels)[match(sort(unique(labels)), labels)]
    if (length(palette) > 1) {
      if (length(palette) < length(Annot)) {
        palette <- CPal_default
      }
      if (is.null(names(palette))) {
        Pal <- palette[1:length(Annot)]
      } else {
        Pal <- palette[Annot]
      }
    } else {
      Pal <- ggpubr::get_palette(palette, length(Annot))
    }

    names(Pal) <- Annot
    vCol <- Pal[names(labels)]
  }

  if (!is.null(trans_attr)) {
    z <- scale(trans_attr) # (trans_attr - median(trans_attr))/mad(trans_attr)
    beta <- 1 / (1 + exp(-trans_fac * (z - trans_th)))
    beta[z > trans_th] <- 1
    beta <- beta^trans_fac

    vCol.border <- scales::alpha(colorspace::darken(vCol, 0.5), beta)
    vCol <- scales::alpha(vCol, beta)
  } else {
    vCol.border <- colorspace::darken(vCol, 0.5)
  }

  threejs::scatterplot3js(
    x = coors[, 1],
    y = coors[, 2],
    z = coors[, 3],
    axis.scales = FALSE,
    size = point_size,
    axis = FALSE,
    grid = FALSE,
    color = as.character(vCol),
    stroke = as.character(vCol.border),
    bg = "black"
  )
}

#' Plots heatmap of the top-ranked features of an enrichment table
#'
#' @param feat_scores An arbitrary enrichment table with columns being archetypes and rows being specificity of features
#' @param top_features Number of features to return
#' @param reorder_columns Whether to optimally re-order columns of the enrichment table
#'
#' @return Enrichment heatmap
#'
#' @examples
#' feat_scores <- as.matrix(rowMaps(ace)[["unified_feature_specificity"]])
#' plot.top.k.features(feat_scores, 3)
#' @export
plot.top.k.features <- function(feat_scores,
                                top_features = 3,
                                normalize = TRUE,
                                reorder_columns = TRUE,
                                row.title = "Archetypes",
                                column.title = "Genes",
                                rowPal = "black",
                                title = "Enrichment") {
  W <- select.top.k.features(
    feat_scores = feat_scores,
    top_features = top_features,
    normalize = normalize
  )

  gradPal <- (grDevices::colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name = "RdYlBu"))))(100)

  M <- apply(W, 1, max)

  Z <- W
  ht <- ComplexHeatmap::Heatmap(
    matrix = Z,
    name = title,
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    col = gradPal,
    row_title = row.title,
    column_title = column.title,
    column_names_gp = grid::gpar(fontsize = 8, fontface = "bold"),
    row_names_gp = grid::gpar(fontsize = 8, fontface = "bold", col = rowPal),
    column_title_gp = grid::gpar(fontsize = 14, fontface = "bold"),
    row_title_gp = grid::gpar(fontsize = 14, fontface = "bold"),
    row_names_side = "left",
    rect_gp = grid::gpar(col = "black"),
    row_names_max_width = grid::unit(100, "cm"),
    column_names_max_height = grid::unit(100, "cm")
  )

  return(ht)
}


#' Plots projection of features onto the ACTIONet plot
#'
#' @param ace ACTIONet output
#' @param feat_scores An arbitrary enrichment table with columns being archetypes and rows being specificity of features
#' @param top_features Number of features to return
#' @param reorder_columns Whether to optimally re-order columns of the enrichment table
#' @param palette Color palette to use
#' @param title Main title of the plot
#'
#' @return Featur view
#'
#' @examples
#' feat_scores <- as.matrix(rowMaps(ace)[["unified_feature_specificity"]])
#' plot.ACTIONet.feature.view(ace, feat_scores, 5)
#' @export
plot.ACTIONet.feature.view <- function(ace,
                                       feat_scores,
                                       top_features = 5,
                                       palette = NULL,
                                       title = "Feature view",
                                       label_size = 1,
                                       renormalize = FALSE,
                                       footprint_slot = "H_unified") {
  M <- as(colMaps(ace)[[footprint_slot]], "sparseMatrix")

  if (ncol(feat_scores) != ncol(colMaps(ace)[["H_unified"]])) {
    feat_scores <- Matrix::t(feat_scores)
  }

  if (max(feat_scores) > 50) {
    feat_scores <- log1p(feat_scores)
  }

  X <- t(select.top.k.features(
    feat_scores = feat_scores,
    top_features = top_features,
    normalize = renormalize,
    reorder_columns = FALSE
  ))
  selected.features <- colnames(X)

  X <- exp(scale(X))

  core.coors <- Matrix::t(metadata(ace)$backbone$coordinates)
  cs <- Matrix::colSums(X)
  cs[cs == 0] <- 1
  X <- scale(X, center = FALSE, scale = cs)

  feature.coors <- Matrix::t(core.coors %*% X)

  if (is.null(palette)) {
    core.Pal <- grDevices::rgb(S4Vectors::metadata(ace)$backbone$colors)
  } else {
    if (length(palette) == 1) {
      core.Pal <- ggpubr::get_palette(palette, length(unique(ace$archetype.assignment)))
    } else {
      core.Pal <- palette[1:length(unique(ace$archetype.assignment))]
    }
  }
  core.Lab <- grDevices::convertColor(
    color = Matrix::t(grDevices::col2rgb(core.Pal) / 256),
    from = "sRGB",
    to = "Lab"
  )

  feature.color.Lab <- Matrix::t(X) %*% core.Lab
  feature.colors <- grDevices::rgb(grDevices::convertColor(
    color = feature.color.Lab,
    from = "Lab",
    to = "sRGB"
  ))
  names(feature.colors) <- selected.features

  x <- feature.coors[, 1]
  y <- feature.coors[, 2]
  x.min <- min(x)
  x.max <- max(x)
  y.min <- min(y)
  y.max <- max(y)
  x.min <- x.min - (x.max - x.min) / 4
  x.max <- x.max + (x.max - x.min) / 4
  y.min <- y.min - (y.max - y.min) / 4
  y.max <- y.max + (y.max - y.min) / 4
  XL <- c(x.min, x.max)
  YL <- c(y.min, y.max)

  graphics::plot(
    x = x,
    y = y,
    type = "n",
    col = feature.colors,
    axes = FALSE,
    xlab = "",
    ylab = "",
    main = title,
    xlim = XL,
    ylim = YL
  )

  words <- selected.features
  lay <- wordcloud::wordlayout(x, y, words, label_size)

  for (i in 1:length(x)) {
    xl <- lay[i, 1]
    yl <- lay[i, 2]
    w <- lay[i, 3]
    h <- lay[i, 4]
    if (x[i] < xl || x[i] > xl + w || y[i] < yl || y[i] > yl + h) {
      graphics::points(
        x = x[i],
        y = y[i],
        pch = 16,
        col = colorspace::darken(feature.colors[[i]], 0.6),
        cex = 0.75 * label_size
      )

      nx <- xl + 0.5 * w
      ny <- yl + 0.5 * h

      graphics::lines(
        x = c(x[i], nx),
        y = c(y[i], ny),
        col = colorspace::darken(feature.colors[[i]], 0.5)
      )
    }
  }

  loc.x <- lay[, 1] + 0.5 * lay[, 3]
  loc.y <- lay[, 2] + 0.5 * lay[, 4]

  graphics::text(
    x = loc.x,
    y = loc.y,
    labels = words,
    col = feature.colors,
    cex = label_size
  )
}


#' Plots projection of genes onto the ACTIONet plot
#'
#' @param ace ACTIONet output
#' @param top_genes Number of genes to return
#' @param blacklist_pattern List of genes to filter-out
#' @param reorder_columns Whether to optimally re-order columns of the enrichment table
#' @param palette Color palette to use
#' @param title Main title of the plot
#'
#' @return Featur view
#'
#' @examples
#' plot.ACTIONet.gene.view(ace, 5)
#' @export
plot.ACTIONet.gene.view <- function(ace,
                                    top_genes = 5,
                                    palette = NULL,
                                    blacklist_pattern = "\\.|^RPL|^RPS|^MRP|^MT-|^MT|MALAT1|B2M|GAPDH",
                                    title = "",
                                    label_size = 0.8,
                                    renormalize = FALSE) {
  feat_scores <- as.matrix(rowMaps(ace)[["unified_feature_specificity"]])
  filtered.rows <- grep(blacklist_pattern, rownames(feat_scores))
  if (length(filtered.rows) > 0) {
    feat_scores <- feat_scores[-filtered.rows, ]
  }

  plot.ACTIONet.feature.view(
    ace = ace,
    feat_scores = feat_scores,
    title = "Gene view",
    renormalize = renormalize,
    top_features = top_genes
  )
}

#' Interactive ACTIONet visualizetion with Plotly
#'
#' @param data 'ACTIONetExperiment' object or numeric matrix of X-Y(-Z) coordinates.
#' @param label_attr Character vector of length NROW(ace) or colname of 'colData(ace)' containing cell labels of interest (clusters, cell types, etc.). (default:'NULL')
#' @param color_attr Character vector of length NROW(ace) or colname of 'colData(ace)' containing hex colors to use for each point, or matrix/data.frame containing RGB values to pass to grDevices::rgb(). (default:'NULL')
#' @param trans_attr Numeric vector of length NROW(ace) or colname of 'colData(ace)' used to compute point transparency. Smaller values are more transparent. (default:'NULL')
#' @param trans_fac Transparency modifier. (default:1.5)
#' @param trans_th Minimum Z-score for which points with 'scale(trans_attr) < trans_th' are masked. (default:-0.5)
#' @param point_size Size of points in ggplot. (default:3)
#' @param stroke_size Size of points outline (stroke) in ggplot. (default:point_size*0.1)
#' @param stroke_color Marker stroke color. Can be any (single) color value accepted by plotly. If not given, darkened fill colors are used. (default:'NULL')
#' @param stroke_contrast_fac Factor by which to darken point outline for contrast if 'stroke_color=NULL'. (default:0.1)
#' @param palette Color palette. character vector of hex colors or a palette name to pass to 'ggpubr::get_palette()'. (default:CPal_default)
#' @param show_legend Show legend based on labels. (default:'NULL')
#' @param coordinate_attr Name of entry in colMaps(ace) containing the 2D or 3D plot coordinates if 'data' is an 'ACTIONetExperiment' object. (default:'ACTIONet2D' or 'ACTIONet3D' if 'plot_3d=TRUE')
#' @param color_slot Name of entry in colMaps(ace) containing RGB values for default point colors generated by 'layout_ACTIONet()'. Used only if no other coloring parameters are given or valid. (default:'denovo_color')
#' @param point_order Integer vector specifying order in which to plot individual points. (default:'NULL')
#' @param hover_text Vector of values to display on hover. (default:'NULL')
#' @param plot_3d Visualize plot in 3D using 'scatter3D'. Required 3D coordinate input (defaults to 'ACTIONet3D' if data is 'ACTIONetExperiment'). (default:'FALSE')
#' @return plotly object
#'
#' @examples
#'
#' plot.ACTIONet.interactive(ace, ace$assigned_archetype, plot_3d = TRUE)
#' @rawNamespace import(plotly, except = 'last_plot')
#' @export
plot.ACTIONet.interactive <- function(data,
                                      label_attr = NULL,
                                      color_attr = NULL,
                                      trans_attr = NULL,
                                      trans_fac = 1.5,
                                      trans_th = -0.5,
                                      point_size = 3,
                                      stroke_size = point_size * 0.1,
                                      stroke_color = NULL,
                                      stroke_contrast_fac = 0.1,
                                      palette = CPal_default,
                                      show_legend = NULL,
                                      coordinate_attr = "ACTIONet2D",
                                      color_slot = "denovo_color",
                                      point_order = NULL,
                                      hover_text = NULL,
                                      plot_3d = FALSE) {
  plot_coors <- .get_plot_coors(data, coordinate_attr)
  plot_labels <- .get_plot_labels(label_attr, data)
  plot_fill_col <- .get_plot_colors(color_attr, plot_labels, data, color_slot, palette)
  plot_alpha <- .get_plot_transparency(trans_attr, data, trans_fac, trans_th, TRUE)

  if (is.null(stroke_color)) {
    plot_border_col <- colorspace::darken(plot_fill_col, stroke_contrast_fac)
  } else {
    plot_border_col <- stroke_color
  }

  if (plot_3d == TRUE) {
    if (NCOL(plot_coors) < 3) {
      if ("ACTIONet3D" %in% names(colMaps(data))) {
        msg <- sprintf("'plot_3d == TRUE' but given coordinates have < 3 columns.\nUsing 'ACTIONet3D'.\n")
        message(msg)
        plot_coors <- .get_plot_coors(data, "ACTIONet3D")
      } else {
        err <- sprintf("'plot_3d == TRUE' but given coordinates have < 3 columns.\n")
        stop(err)
      }
    }
  }

  plot_data <- data.frame(plot_coors,
    fill = plot_fill_col,
    color = plot_border_col,
    trans = plot_alpha,
    idx = 1:NROW(plot_coors)
  )

  if (is.null(label_attr)) {
    show_legend <- FALSE
    plot_data$labels <- "NA"
  } else {
    plot_data$labels <- plot_labels
  }

  if (!is.null(hover_text)) {
    plot_data$text <- hover_text
  } else {
    if (is.null(label_attr)) {
      plot_data$text <- plot_data$idx
    } else {
      plot_data$text <- plot_data$labels
    }
  }

  if (is.null(point_order)) {
    pidx <- sample(NROW(plot_data))
  } else {
    pidx <- point_order
  }

  plot_data <- plot_data[pidx, ]

  cont_attr <- c(color_attr, trans_attr)
  if (is.null(label_attr) | any(!sapply(cont_attr, is.null))) {
    if (is.null(show_legend)) {
      show_legend <- FALSE
    }

    plot_data$fill <- grDevices::rgb(t(grDevices::col2rgb(plot_data$fill) / 255), alpha = plot_data$trans)
    plot_data$color <- grDevices::rgb(t(grDevices::col2rgb(plot_data$color) / 255), alpha = plot_data$trans)

    p <- .make_plotly_scatter_single_trace(
      x = plot_data$x,
      y = plot_data$y,
      z = plot_data$z,
      label_attr = plot_data$labels,
      cols_fill = plot_data$fill,
      cols_stroke = plot_data$color,
      point_size = point_size,
      stroke_size = stroke_size,
      show_legend = show_legend,
      hover_text = plot_data$text,
      plot_3d = plot_3d
    )
  } else {
    if (is.null(show_legend)) {
      show_legend <- TRUE
    }

    col_idx <- which(!duplicated(plot_data$labels))
    palette_fill <- plot_data$fill[col_idx]
    palette_stroke <- plot_data$color[col_idx]
    names(palette_fill) <- names(palette_stroke) <- plot_data$labels[col_idx]

    p <- .make_plotly_scatter_split_trace(
      x = plot_data$x,
      y = plot_data$y,
      z = plot_data$z,
      label_attr = plot_data$labels,
      cols_fill = palette_fill,
      cols_stroke = palette_stroke,
      point_size = point_size,
      stroke_size = stroke_size,
      show_legend = show_legend,
      hover_text = plot_data$text,
      plot_3d = plot_3d
    )
  }

  return(p)
}


#' Plot gene expression violin plot
#'
#' @param ace ACTIONet output object
#' @param labels Annotation of interest (clusters, celltypes, etc.) to be projected on the ACTIONet plot
#' @param gene_name Name of the gene to plot
#' @param palette Color palette (named vector or a name for a given known palette)
#'
#' @return Visualized ACTIONet
#'
#' @examples
#' plot.individual.gene(ace, ace$assigned_archetype, "CD14")
#' @export
plot.individual.gene <- function(ace,
                                 labels,
                                 gene_name,
                                 features_use = NULL,
                                 assay_name = "logcounts",
                                 palette = CPal_default) {
  clusters <- .preprocess_annotation_labels(ace, labels)
  features_use <- .preprocess_annotation_features(ace, features_use)

  Labels <- names(clusters)
  Annot <- sort(unique(Labels))
  Annot <- Annot[order(clusters[match(Annot, Labels)], decreasing = FALSE)]
  Labels <- factor(Labels, levels = Annot)

  if (length(palette) > 1) {
    if (length(palette) < length(Annot)) {
      if (length(Annot) <= 20) {
        palette <- CPal_default
      } else {
        palette <- CPal_default
      }
    }

    if (is.null(names(palette))) {
      Pal <- palette[1:length(Annot)]
    } else {
      Pal <- palette[Annot]
    }
  } else {
    Pal <- ggpubr::get_palette(palette, length(Annot))
  }

  names(Pal) <- Annot

  if (!(gene_name %in% features_use)) {
    err <- sprintf("Gene %s not found\n", gene_name)
    stop(err)
  }

  x <- SummarizedExperiment::assays(ace)[[assay_name]][gene_name, ]
  if (sum(x) == 0) {
    err <- sprintf("Gene must have non-zero expression.\n")
    stop(err)
  }


  df <- data.frame(Annotation = Labels, Expression = x)
  gp <- ggpubr::ggviolin(
    data = df,
    x = "Annotation",
    y = "Expression",
    fill = "Annotation",
    palette = Pal,
    add = "boxplot",
    add.params = list(fill = "white")
  )
  print(gp)
}

#' Plots gradient of (imputed) values on ACTIONet scatter plot.
#'
#' @param ace 'ACTIONetExperiment' object
#' @param x Numeric vector of length NCOL(ace).
#' @param alpha_val Smoothing parameter for PageRank imputation of 'x'. No imputation if 'alpha_val=0' (default:0.85).
#' @param log_scale Logical value for whether to log-scale values of 'x' (default:'FALSE').
#' @param nonparameteric If 'FALSE', values of 'x' are used as breaks for color gradient. If 'TRUE' the ranks of the values of 'x' are used instead  (default:'FALSE').
#' @param trans_attr Numeric vector of length NROW(ace) or colname of 'colData(ace)' used to compute point transparency. Smaller values are more transparent.
#' @param trans_fac Transparency modifier (default:1.5).
#' @param trans_th Minimum Z-score for which points with 'scale(trans_attr) < trans_th' are masked (default:-0.5).
#' @param point_size Size of points in ggplot (default:1).
#' @param stroke_size Size of points outline (stroke) in ggplot (default:point_size*0.1).
#' @param stroke_contrast_fac Factor by which to darken point outline for contrast (default:0.1).
#' @param grad_palette Gradient color palette. one of ("greys", "inferno", "magma", "viridis", "BlGrRd", "RdYlBu", "Spectral") or value to pass as 'colors' argument to 'grDevices::colorRampPalette()'.
#' @param net_attr Name of entry in colNets(ace) containing the ACTIONet adjacency matrix to use for value imputation if 'alpha_val>0' (default:'ACTIONet').
#' @param coordinate_attr Name of entry in colMaps(ace) containing the 2D plot coordinates (default:'ACTIONet2D').
#'
#' @return 'ggplot' object.
#'
#' @examples
#' ace <- run.ACTIONet(ace)
#' x <- logcounts(ace)["CD14", ]
#' plot.ACTIONet.gradient(ace, x, trans_attr = ace$node_centrality)
#' @export

plot.ACTIONet.gradient <- function(ace,
                                   x,
                                   alpha_val = 0.85,
                                   log_scale = FALSE,
                                   nonparameteric = FALSE,
                                   trans_attr = NULL,
                                   trans_fac = 1.5,
                                   trans_th = -0.5,
                                   point_size = 1,
                                   stroke_size = point_size * 0.1,
                                   stroke_contrast_fac = 0.1,
                                   grad_palette = "magma",
                                   net_attr = "ACTIONet",
                                   coordinate_attr = "ACTIONet2D") {
  NA_col <- "#eeeeee"

  if (length(x) != ncol(ace)) {
    warning("Length of input vector doesn't match the number of cells.")
    return()
  }
  ## Create color gradient generator
  if (grad_palette %in% c("greys", "inferno", "magma", "viridis", "BlGrRd", "RdYlBu", "Spectral")) {
    grad_palette <- switch(grad_palette,
      greys = grDevices::gray.colors(100),
      inferno = viridis::inferno(500, alpha = 0.8),
      magma = viridis::magma(500, alpha = 0.8),
      viridis = viridis::viridis(500, alpha = 0.8),
      BlGrRd = grDevices::colorRampPalette(c("blue", "grey", "red"))(500),
      Spectral = (grDevices::colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name = "Spectral"))))(100),
      RdYlBu = (grDevices::colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name = "RdYlBu"))))(100)
    )
  } else {
    # grad_palette = grDevices::colorRampPalette(c(NA_col, grad_palette))(500)
    grad_palette <- grDevices::colorRampPalette(grad_palette)(500)
  }

  if (log_scale == TRUE) {
    x <- log1p(x)
  }

  if (alpha_val > 0) {
    x <- as.numeric(propNetworkScores(
      G = colNets(ace)[[net_attr]],
      scores = as.matrix(x)
    ))
  }

  col_func <- (scales::col_bin(
    palette = grad_palette,
    domain = NULL,
    na.color = NA_col,
    bins = 7
  ))

  if (nonparameteric == TRUE) {
    plot_fill_col <- col_func(rank(x))
  } else {
    plot_fill_col <- col_func(x)
  }

  idx <- order(x, decreasing = FALSE)

  p_out <- plot.ACTIONet(
    ace = ace,
    label_attr = NULL,
    color_attr = plot_fill_col,
    trans_attr = trans_attr,
    trans_fac = trans_fac,
    trans_th = trans_th,
    point_size = point_size,
    stroke_size = stroke_size,
    stroke_contrast_fac = stroke_contrast_fac,
    palette = NULL,
    add_text_labels = FALSE,
    point_order = idx,
    coordinate_attr = coordinate_attr
  )

  return(p_out)
}


#' Projects a set of markers on the ACTIONet
#' It also optionally imputes the markers.
#'
#' @param ace ACTIONet output object
#' @param markers Set of row features (e.g. genes) to visualize .
#' @param trans_attr Additional continuous attribute to project onto the transparency of nodes
#' @param trans_th, trans_fac Control the effect of transparency mapping
#' @param point_size Size of nodes in the ACTIONet plot
#' @param grad_palette Color palette (named vector or a name for a given known palette)
#' @param coordinate_slot Entry in colMaps(ace) containing the plot coordinates (default:'ACTIONet2D')
#' @param alpha_val Between [0, 1]. If it is greater than 0, smoothing of scores would be performed
#'
#' @return Visualized ACTIONet with projected scores
#'
#' @examples
#' ace <- run.ACTIONet(sce)
#' visualize.markers(ace, markers = c("CD14", "CD19", "CD3G"), trans_attr = ace$node_centrality)
visualize.markers <- function(ace,
                              markers,
                              features_use = NULL,
                              alpha_val = 0.9,
                              assay_name = "logcounts",
                              trans_attr = NULL,
                              trans_th = -0.5,
                              trans_fac = 3,
                              grad_palette = "magma",
                              point_size = 1,
                              net_attr = "ACTIONet",
                              coordinate_attr = "ACTIONet2D",
                              single_plot = FALSE) {
  features_use <- .preprocess_annotation_features(ace, features_use = features_use)
  markers_all <- sort(unique(unlist(markers)))
  marker_set <- intersect(markers_all, features_use)

  if (length(marker_set) == 0) {
    err <- sprintf("No given markers found in feature set.\n")
    stop(err, call. = FALSE)
  }

  if (length(marker_set) == 1) {
    alpha_val <- 0
  }

  if (alpha_val > 0) {
    expression_profile <- impute.genes.using.ACTIONet(
      ace = ace,
      genes = marker_set,
      features_use = features_use,
      alpha_val = alpha_val
    )
  } else {
    expression_profile <- assays(ace)[[assay_name]][match(marker_set, features_use), ,
      drop = FALSE
    ]
    expression_profile <- Matrix::t(expression_profile)
    colnames(expression_profile) <- marker_set
  }

  print(sprintf("Markers Visualized: %s", paste0(marker_set, collapse = ", ")))
  markers_missing <- setdiff(markers_all, marker_set)
  if (length(markers_missing) > 0) {
    print(sprintf("Markers Missing: %s", paste0(markers_missing, collapse = ", ")))
  }

  if (single_plot == TRUE && NCOL(expression_profile) > 1) {
    n <- length(marker_set)
    d <- .plot_arrange_dim(n)
    point_size <- point_size / d[1]
  }

  out <- sapply(colnames(expression_profile), function(feat_name) {
    x <- expression_profile[, feat_name]

    nnz <- round(sum(x^2)^2 / sum(x^4))
    x.threshold <- sort(x, decreasing = TRUE)[nnz]
    x[x < x.threshold] <- 0
    x <- x / max(x)

    p_out <- plot.ACTIONet.gradient(
      ace = ace,
      x = x,
      alpha_val = 0,
      log_scale = FALSE,
      nonparameteric = FALSE,
      trans_attr = trans_attr,
      trans_fac = trans_fac,
      trans_th = trans_th,
      point_size = point_size,
      stroke_size = point_size * 0.1,
      stroke_contrast_fac = 0.1,
      grad_palette = grad_palette,
      net_attr = net_attr,
      coordinate_attr = coordinate_attr
    ) +
      ggtitle(feat_name) +
      theme(plot.title = element_text(hjust = 0.5))

    return(p_out)
  }, simplify = FALSE)

  # n = length(out)
  if (length(out) == 1) {
    out <- out[[1]]
  }

  if (single_plot == TRUE && length(out) > 1) {
    # n = length(marker_set)
    # d = .plot_arrange_dim(n)
    out <- ggpubr::ggarrange(
      plotlist = out,
      nrow = d[1],
      ncol = d[2]
    )
  }

  return(out)
}


select.top.k.genes <- function(ace,
                               top_genes = 5,
                               palette = NULL,
                               blacklist_pattern = "\\.|^RPL|^RPS|^MRP|^MT-|^MT|^RP|MALAT1|B2M|GAPDH",
                               top_features = 3,
                               normalize = FALSE,
                               reorder_columns = FALSE,
                               slot_name = "unified_feature_specificity") {
  feat_scores <- as.matrix(rowMaps(ace)[[slot_name]])
  filtered.rows <- grep(blacklist_pattern, rownames(feat_scores))
  if (length(filtered.rows) > 0) {
    feat_scores <- feat_scores[-filtered.rows, ]
  }

  tbl <- select.top.k.features(
    feat_scores = feat_scores,
    top_features = top_features,
    normalize = normalize,
    reorder_columns = reorder_columns
  )

  return(tbl)
}


plot.top.k.genes <- function(ace,
                             top_genes = 5,
                             palette = NULL,
                             blacklist_pattern = "\\.|^RPL|^RPS|^MRP|^MT-|^MT|^RP|MALAT1|B2M|GAPDH",
                             top_features = 3,
                             normalize = FALSE,
                             reorder_columns = TRUE,
                             row.title = "Archetypes",
                             column.title = "Genes",
                             rowPal = "black",
                             slot_name = "unified_feature_specificity") {
  feat_scores <- as.matrix(rowMaps(ace)[[slot_name]])
  filtered.rows <- grep(blacklist_pattern, rownames(feat_scores))
  if (length(filtered.rows) > 0) {
    feat_scores <- feat_scores[-filtered.rows, ]
  }

  ht <- plot.top.k.features(
    feat_scores = feat_scores,
    top_features = top_features,
    normalize = normalize,
    reorder_columns = reorder_columns,
    row.title = row.title,
    column.title = column.title,
    rowPal = rowPal
  )

  return(ht)
}


plot.archetype.selected.genes <- function(ace,
                                          genes,
                                          palette = NULL,
                                          blacklist_pattern = "\\.|^RPL|^RPS|^MRP|^MT-|^MT|^RP|MALAT1|B2M|GAPDH",
                                          top_features = 3,
                                          normalize = FALSE,
                                          reorder_columns = TRUE,
                                          row.title = "Archetypes",
                                          column.title = "Genes",
                                          rowPal = "black",
                                          slot_name = "unified_feature_specificity") {
  feat_scores <- as.matrix(rowMaps(ace)[["unified_feature_specificity"]])
  filtered.rows <- match(intersect(rownames(ace), genes), rownames(ace))

  if (length(filtered.rows) > 0) {
    feat_scores <- feat_scores[-filtered.rows, ]
  }

  ht <- plot.top.k.features(
    feat_scores = feat_scores,
    top_features = top_features,
    normalize = normalize,
    reorder_columns = reorder_columns,
    row.title = row.title,
    column.title = column.title,
    rowPal = rowPal
  )

  return(ht)
}


plot.ACTIONet.archetype.footprint <- function(ace,
                                              markers,
                                              features_use = NULL,
                                              alpha_val = 0.9,
                                              assay_name = "logcounts",
                                              trans_attr = NULL,
                                              trans_th = 0,
                                              trans_fac = 2,
                                              grad_palette = "magma",
                                              point_size = 0.5,
                                              net_attr = "ACTIONet",
                                              coordinate_attr = "ACTIONet2D",
                                              single_plot = FALSE,
                                              arch.labels = NULL) {
  archetype_footprint <- ace$archetype_footprint
  if (is.null(arch.labels)) {
    arch.labels <- sapply(1:NCOL(archetype_footprint), function(i) sprintf("Archetype %d", i))
  }
  colnames(archetype_footprint) <- arch.labels

  if (single_plot == TRUE && NCOL(archetype_footprint) > 1) {
    n <- NCOL(archetype_footprint)
    d <- .plot_arrange_dim(n)
    point_size <- point_size / d[1]
  }

  out <- sapply(colnames(archetype_footprint), function(arch) {
    x <- archetype_footprint[, arch]

    nnz <- round(sum(x^2)^2 / sum(x^4))
    x.threshold <- sort(x, decreasing = TRUE)[nnz]
    x[x < x.threshold] <- 0
    x <- x / max(x)

    if (is.null(trans_attr)) {
      trans_attr <- x
    }
    p_out <- plot.ACTIONet.gradient(
      ace = ace,
      x = x,
      alpha_val = 0,
      log_scale = FALSE,
      nonparameteric = FALSE,
      trans_attr = trans_attr,
      trans_fac = trans_fac,
      trans_th = trans_th,
      point_size = point_size,
      stroke_size = point_size * 0.1,
      stroke_contrast_fac = 0.1,
      grad_palette = grad_palette,
      net_attr = net_attr,
      coordinate_attr = coordinate_attr
    ) +
      ggtitle(arch) +
      theme(plot.title = element_text(hjust = 0.5))

    return(p_out)
  }, simplify = FALSE)

  # n = length(out)
  if (length(out) == 1) {
    out <- out[[1]]
  }

  if (single_plot == TRUE && length(out) > 1) {
    # n = length(marker_set)
    # d = .plot_arrange_dim(n)

    out <- ggpubr::ggarrange(
      plotlist = out,
      nrow = d[1],
      ncol = d[2]
    )
  }

  return(out)
}


#' Report the top-rank features from a given enrichment table
#'
#' @param top_features Number of features to return
#' @param reorder_columns Whether to optimally re-order columns of the enrichment table
#'
#' @return Sorted table with the selected top-ranked
#'
#' @examples
#' feat_scores <- as.matrix(rowMaps(ace)[["unified_feature_specificity"]])
#' enrichment.table.top <- select.top.k.features(feat_scores, 3)
#' @export
select.top.k.features <- function(feat_scores,
                                  top_features = 3,
                                  normalize = FALSE,
                                  reorder_columns = TRUE) {
  W0 <- (feat_scores)
  if (normalize == TRUE) {
    W0 <- doubleNorm(W0)
  }

  IDX <- matrix(0, nrow = top_features, ncol = NCOL(W0))
  VV <- matrix(0, nrow = top_features, ncol = NCOL(W0))
  W <- (W0)

  for (i in 1:NROW(IDX)) {
    W.m <- as(MWM_hungarian(W), "dgTMatrix")
    IDX[i, W.m@j + 1] <- W.m@i + 1
    VV[i, W.m@j + 1] <- W.m@x
    W[IDX[i, W.m@j + 1], ] <- 0
  }

  if (reorder_columns == TRUE) {
    feat_scores_agg <- apply(IDX, 2, function(perm) as.numeric(ACTIONetExperiment:::fastColMeans(W0[perm, ])))
    CC <- cor(feat_scores_agg)
    D <- stats::as.dist(1 - CC)
    cols <- seriation::get_order(seriation::seriate(D, "OLO"))
    rows <- as.numeric(IDX[, cols])
  } else {
    cols <- 1:NCOL(W0)
    rows <- unique(as.numeric(IDX))
  }

  W <- feat_scores[rows, cols]

  return(W)
}


gate.archetypes <- function(ace,
                            i,
                            j,
                            H.slot = "H_unified") {
  H <- colMaps(ace)[[H.slot]]
  hx <- H[i, ]
  hy <- H[j, ]

  hx.nnz <- sum(hx)^2 / sum(hx^2)
  hx.threshold <- sort(hx, decreasing = T)[hx.nnz]

  hy.nnz <- sum(hy)^2 / sum(hy^2)
  hy.threshold <- sort(hx, decreasing = T)[hy.nnz]


  mask <- (hx > hx.threshold) | (hy > hy.threshold)
  fig <- plotly::plot_ly(x = hx[mask], y = hy[mask])

  fig <- add_trace(p = fig, type = "histogram2dcontour")

  fig
}