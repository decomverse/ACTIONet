#' Computes feature (i.e. gene) specificity scores for each cluster
#'
#' @param ace ACTIONet output object
#' @param cluster_attr Vector of length NCOL(ace) or column name of colData(ace) containing cluster labels.
#' @param output_prefix String to prefix names of rowMaps(ace) where output is stored.
#' @param assay_name Name of assay to be used. (default="logcounts")
#' @param features_use A vector of features of length NROW(ace) or the name of a column of rowData(ace) containing the feature names. Default uses rownames(ace). (default=NULL)

#' @return `ACE` object with specificity scores of each cluster added to rowMaps(ace) as a matrix with name defined by output_prefix
#'
#' @examples
#' ace <- compute.cluster.feature.specificity(ace, ace$clusters, "cluster_specificity_scores")
#' @export
compute.cluster.feature.specificity <- function(
  ace,
  cluster_attr,
  output_prefix,
  assay_name = "logcounts",
  features_use = NULL
) {

  features_use = .get_feature_vec(ace, features_use)
  clusters = ACTIONetExperiment:::.get_attr_or_split_idx(ace, cluster_attr, return_vec = TRUE)

  S <- SummarizedExperiment::assays(ace)[[assay_name]]

  # if (is.factor(clusters)) {
  #   UL <- levels(clusters)
  # } else {
  #   UL <- sort(unique(clusters))
  # }
  sa = ACTIONetExperiment::get.data.or.split(ace, attr = clusters, to_return = "levels")
  # UL <- sort(unique(clusters))
  # labels <- match(clusters, UL)
  #
  # # Compute gene specificity for each cluster
  # if (is.matrix(S)) {
  #   specificity.out <- compute_cluster_feature_specificity_full(S, labels)
  # } else {
  #   specificity.out <- compute_cluster_feature_specificity(S, labels)
  # }

  # Compute gene specificity for each cluster
  if (is.matrix(S)) {
    specificity.out <- compute_cluster_feature_specificity_full(S, sa[["index"]])
  } else {
    specificity.out <- compute_cluster_feature_specificity(S, sa[["index"]])
  }

  specificity.out <- lapply(specificity.out, function(scores) {
    rownames(scores) <- features_use
    colnames(scores) <- paste0("A", 1:ncol(scores))
    return(scores)
  })

  X <- specificity.out[["upper_significance"]]
  # colnames(X) <- UL
  colnames(X) <- sa[["keys"]]

  rowMaps(ace)[[sprintf("%s_feature_specificity", output_prefix)]] <- X
  rowMapTypes(ace)[[sprintf("%s_feature_specificity", output_prefix)]] <- "reduction"

  return(ace)
}


#' Annotate clusters using prior cell annotations
#' (It uses Fisher's exact test for computing overlaps -- approximate HGT is used)
#'
#' @param ace ACTIONet output object
#' @param clusters Cluster
#' @param labels Annotation of interest (clusters, celltypes, etc.) to test enrichment
#'
#' @return A named list: \itemize{
#' \item Labels: Inferred archetype labels
#' \item Labels.confidence: Confidence of inferred labels
#' \item Enrichment: Full enrichment matrix
#' }
#'
#' @examples
#' arch.annot <- annotate.clusters.using.labels(ace, ace$clusters, sce$celltypes)
#' @export
annotate.clusters.using.labels <- function(ace,
                                           clusters,
                                           labels) {
  clusters <- .preprocess_annotation_labels(clusters, ace)
  Labels <- .preprocess_annotation_labels(labels, ace)

  pop.size <- length(Labels)
  pos.size <- table(Labels)

  logPvals <- sapply(sort(unique(clusters)), function(i) {
    idx <- which(clusters == i)
    sample.size <- length(idx)
    success.size <- sapply(sort(unique(Labels)), function(i) {
      sum(Labels[idx] == i)
    })

    logPval <- HGT_tail(
      population.size = pop.size,
      success.count = pos.size,
      sample.size = sample.size,
      observed.success = success.size
    )

    return(logPval)
  })


  cl.Annot <- names(clusters)[match(sort(unique(clusters)), clusters)]
  Annot <- names(Labels)[match(sort(unique(Labels)), Labels)]

  colnames(logPvals) <- cl.Annot
  rownames(logPvals) <- Annot

  clusterLabels <- Annot[apply(logPvals, 2, which.max)]

  cellLabels <- match(clusterLabels[clusters], Annot)
  names(cellLabels) <- clusterLabels[clusters]

  res <- list(
    Labels = clusterLabels,
    cellLabels = cellLabels,
    Enrichment = logPvals
  )

  return(res)
}


#' Annotate clusters using known marker genes
#' (It uses permutation test on cluster specificity scores)
#'
#' @param ace ACTIONet output object
#' @param marker.genes A list of lists (each a set of markers for a given cell type)
#' @param specificity.slot.name An entry in the rowMaps(ace), precomputed using compute.cluster.feature.specificity() function
#' @param rand.sample.no Number of random permutations (default=1000)
#'
#' @return A named list: \itemize{
#' \item Labels: Inferred archetype labels
#' \item Labels.confidence: Confidence of inferred labels
#' \item Enrichment: Full enrichment matrix
#' }
#'
#' @examples
#' data("curatedMarkers_human") # pre-packaged in ACTIONet
#' marker.genes <- curatedMarkers_human$Blood$PBMC$Monaco2019.12celltypes$marker.genes
#' ace <- compute.cluster.feature.specificity(ace, ace$clusters, "cluster_specificity_scores")
#' arch.annot <- annotate.clusters.using.markers(ace, marker.genes = marker.genes, specificity.slot.name = "cluster_specificity_scores")
#' @export
annotate.clusters.using.markers <- function(ace,
                                            marker.genes,
                                            specificity.slot.name,
                                            rand.sample.no = 1000) {
  if (!(specificity.slot.name %in% names(rowMaps(ace)))) {
    message(sprintf("%s does not exist in rowMaps(ace)", specificity.slot.name))
  }

  if (is.matrix(marker.genes) | ACTIONetExperiment:::is.sparseMatrix(marker.genes)) {
    marker.genes <- apply(marker.genes, 2, function(x) {
      rownames(marker.genes)[x >
        0]
    })
  }

  specificity.panel <- Matrix::t(as.matrix(log1p(rowMaps(ace)[[specificity.slot.name]])))

  GS.names <- names(marker.genes)
  if (is.null(GS.names)) {
    GS.names <- sapply(1:length(GS.names), function(i) sprintf("Celltype %s", i))
  }

  markers.table <- do.call(rbind, lapply(names(marker.genes), function(celltype) {
    genes <- marker.genes[[celltype]]

    if (length(genes) == 0) {
      err <- sprintf("No markers left.\n")
      stop(err, call. = FALSE)
    }

    signed.count <- sum(sapply(genes, function(gene) grepl("\\+$|-$", gene)))
    is.signed <- signed.count > 0

    if (!is.signed) {
      df <- data.frame(
        Gene = genes,
        Direction = +1,
        Celltype = celltype,
        stringsAsFactors = FALSE
      )
    } else {
      pos.genes <- (as.character(sapply(
        genes[grepl("+", genes, fixed = TRUE)],
        function(gene) stringr::str_replace(gene, stringr::fixed("+"), "")
      )))
      neg.genes <- (as.character(sapply(
        genes[grepl("-", genes, fixed = TRUE)],
        function(gene) stringr::str_replace(gene, stringr::fixed("-"), "")
      )))

      df <- data.frame(
        Gene = c(pos.genes, neg.genes),
        Direction = c(rep(+1, length(pos.genes)), rep(-1, length(neg.genes))),
        Celltype = celltype,
        stringsAsFactors = FALSE
      )
    }
  }))

  markers.table <- markers.table[markers.table$Gene %in% colnames(specificity.panel), ]

  if (dim(markers.table)[1] == 0) {
    err <- sprintf("No markers left.\n")
    stop(err, call. = FALSE)
  }

  specificity.panel <- specificity.panel[, markers.table$Gene]

  IDX <- split(1:dim(markers.table)[1], markers.table$Celltype)

  print("Computing significance scores")
  set.seed(0)
  Z <- sapply(IDX, function(idx) {
    markers <- (as.character(markers.table$Gene[idx]))
    directions <- markers.table$Direction[idx]
    mask <- markers %in% colnames(specificity.panel)

    A <- as.matrix(specificity.panel[, markers[mask]])
    sgn <- as.numeric(directions[mask])
    stat <- A %*% sgn

    rand.stats <- sapply(1:rand.sample.no, function(i) {
      rand.samples <- sample.int(dim(specificity.panel)[2], sum(mask))
      rand.A <- as.matrix(specificity.panel[, rand.samples])
      rand.stat <- rand.A %*% sgn
    })

    cell.zscores <- as.numeric((stat - apply(rand.stats, 1, mean)) / apply(
      rand.stats,
      1, sd
    ))

    return(cell.zscores)
  })

  Z[is.na(Z)] <- 0
  Labels <- colnames(Z)[apply(Z, 1, which.max)]

  Labels.conf <- apply(Z, 1, max)

  names(Labels) <- rownames(specificity.panel)
  names(Labels.conf) <- rownames(specificity.panel)
  rownames(Z) <- rownames(specificity.panel)

  out <- list(
    Label = Labels,
    Confidence = Labels.conf,
    Enrichment = Z
  )

  return(out)
}


#' Annotate arbitary feature score matrix using known marker genes
#' (It uses permutation test on cluster specificity scores)
#'
#' @param profile An arbitrary matrix with rows corresponding to features and columns to any given annotation/grouping of cells
#' @param markers A list of lists (each a set of markers for a given cell type)
#'
#' @return A named list: \itemize{
#' \item Labels: Inferred archetype labels
#' \item Labels.confidence: Confidence of inferred labels
#' \item Enrichment: Full enrichment matrix
#' }
#'
#' @export
annotate.profile.using.markers <- function(profile, markers) {
  marker_mat <- .preprocess_annotation_markers(markers, rownames(profile))

  enrichment.out <- assess_enrichment(profile, marker_mat)

  X <- enrichment.out$logPvals
  rownames(X) <- colnames(marker_mat)
  colnames(X) <- colnames(profile)

  return(X)
}

#' A wrapper function For Leiden algorithm
#'
#' @param G Adjacency matrix of the input graph
#' @param resolution_parameter Resolution of the clustering.
#' The higher the resolution, the more clusters we will get (default=0.5).
#' @param initial.clustering Used as the inital clustering
#' @param seed Random seed
#'
#' @return ace with added annotation
#'
#' @examples
#' clusters <- cluster.graph(G, 1.0)
#' @export
cluster.graph <- function(G,
                          resolution_parameter = 0.5,
                          initial.clustering = NULL,
                          seed = 0) {
  if (is.matrix(G)) {
    G <- as(G, "sparseMatrix")
  }

  is.signed <- FALSE
  if (min(G) < 0) {
    is.signed <- TRUE
    print("Graph is signed. Switching to signed graph clustering mode.")
  }

  if (!is.null(initial.clustering)) {
    print("Perform graph clustering with *prior* initialization")

    if (is.signed) {
      clusters <- as.numeric(signed_cluster(
        A = G,
        resolution_parameter = resolution_parameter,
        initial_clusters_ = initial.clustering,
        seed = seed
      ))
    } else {
      clusters <- as.numeric(unsigned_cluster(
        A = G,
        resolution_parameter = resolution_parameter,
        initial_clusters_ = initial.clustering,
        seed = seed
      ))
    }
  } else {
    print("Perform graph clustering with *uniform* initialization")

    if (is.signed) {
      clusters <- as.numeric(signed_cluster(
        A = G,
        resolution_parameter = resolution_parameter,
        initial_clusters_ = NULL,
        seed = seed
      ))
    } else {
      clusters <- as.numeric(unsigned_cluster(
        A = G,
        resolution_parameter = resolution_parameter,
        initial_clusters_ = NULL,
        seed = seed
      ))
    }
  }
  return(clusters)
}


#' A wrapper function For Leiden algorithm applied to an ACE object
#'
#' @param ace Input results to be clustered

#' @param resolution_parameter Resolution of the clustering.
#' The higher the resolution, the more clusters we will get (default=0.5).
#' @param arch.init Whether to use archetype-assignments to initialize clustering (default=TRUE)
#' @param seed Random seed
#'
#' @return clusters
#'
#' @examples
#' clusters <- Leiden.clustering(ace)
#' plot.ACTIONet(ace, clusters)
#' @export
Leiden.clustering <- function(ace,
                              resolution_parameter = 1,
                              net.slot = "ACTIONet",
                              init.slot = "assigned_archetype",
                              seed = 0,
                              postprocess = T,
                              PP_lambda = 0,
                              PP_iters = 3,
                              PP_sig_threshold = 3) {
  if (!is.null(init.slot)) {
    initial.clusters <- ace[[init.slot]]
  } else {
    initial.clusters <- NULL
  }

  G <- colNets(ace)[[net.slot]]

  clusters <- cluster.graph(G, resolution_parameter, initial.clusters, seed)
  if (postprocess == T) {
    cc <- table(clusters)
    clusters[clusters %in% as.numeric(names(cc)[cc < 30])] <- -1
    clusters <- c(run_LPA(ace$ACTIONet, clusters, lambda = PP_lambda, iters = PP_iters, sig_threshold = PP_sig_threshold))
  }
  clusters <- as.numeric(clusters)
  names(clusters) <- paste("C", as.character(clusters), sep = "")

  return(clusters)
}


#' A wrapper function For HDBSCAN algorithm applied to an ACE object
#'
#' @param ace Input results to be clustered
#' minPoints, minClusterSize HDBSCAN parameters (default = 30,30)
#' archetype.slot Slot of archeypte to use for clustering (default='H_unified');
#'
#' @return clusters
#'
#' @examples
#' clusters <- HDBSCAN.clustering(ace)
#' plot.ACTIONet(ace, clusters)
#' @export
HDBSCAN.clustering <- function(ace,
                               minPoints = 30,
                               minClusterSize = 30,
                               archetype.slot = "H_unified") {
  X <- as.matrix(colMaps(ace)[[archetype.slot]])

  out_list <- run_HDBSCAN(
    X = X,
    minPoints = minPoints,
    minClusterSize = minClusterSize
  )

  return(out_list)
}


#' @export
clusterNetwork <- function(G, algorithm = "Leiden",
                           resolution_parameter = 1.0,
                           initial_clustering = NULL,
                           seed = 0,
                           net_slot = "ACTIONet") {
  algorithm <- tolower(algorithm)

  if (is(G, "ACTIONetExperiment")) {
    G <- colNets(G)[[net_slot]]
  }
  if (algorithm == "leiden") {
    if (is.matrix(G)) {
      G <- as(G, "sparseMatrix")
    }

    is.signed <- FALSE
    if (min(G) < 0) {
      is.signed <- TRUE
      print("Graph is signed. Switching to signed graph clustering mode.")
    }

    if (!is.null(initial_clustering)) {
      print("Perform graph clustering with *prior* initialization")

      if (is.signed) {
        clusters <- as.numeric(signed_cluster(
          A = G,
          resolution_parameter = resolution_parameter,
          initial_clusters_ = initial_clustering,
          seed = seed
        ))
      } else {
        clusters <- as.numeric(unsigned_cluster(
          A = G,
          resolution_parameter = resolution_parameter,
          initial_clusters_ = initial_clustering,
          seed = seed
        ))
      }
    } else {
      print("Perform graph clustering with *uniform* initialization")

      if (is.signed) {
        clusters <- as.numeric(signed_cluster(
          A = G,
          resolution_parameter = resolution_parameter,
          initial_clusters_ = NULL,
          seed = seed
        ))
      } else {
        clusters <- as.numeric(unsigned_cluster(
          A = G,
          resolution_parameter = resolution_parameter,
          initial_clusters_ = NULL,
          seed = seed
        ))
      }
    }
  }
  return(clusters)
}


#' @export
clusterCells <- function(ace, algorithm = "Leiden",
                         cluster_name = "Leiden",
                         resolution_parameter = 1.0,
                         initial_clustering = NULL,
                         seed = 0,
                         net_slot = "ACTIONet") {
  if (!is.null(initial_clustering)) {
    if (is.character(initial_clustering)) {
      initial_clustering <- as.factor(initial_clustering)
    }
  }
  if (algorithm == "fix") {
    cl <- initial_clustering
  } else {
    if (is.null(initial_clustering)) {
      initial_clustering <- ace$assigned_archetype
    }
    cl <- clusterNetwork(ace,
      algorithm = algorithm,
      resolution_parameter = resolution_parameter,
      initial_clustering = initial_clustering,
      seed = seed,
      net_slot = net_slot
    )
  }

  colData(ace)[[cluster_name]] <- cl
  ace <- findMarkers.ace(ace, cl, out.name = cluster_name)

  return(ace)
}
